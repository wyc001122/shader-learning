{
    "navMain": [
        {
            "id": 2,
            "slug": "built-in-functions",
            "name": "Built-in functions",
            "description": "Understand the role of fragment shaders in the graphics pipeline and explore a large collection of built-in GLSL functions.",
            "tasks": 33,
            "acceptedTasks": 11,
            "isOpen": false,
            "order": 0,
            "locked": false,
            "cover": true,
            "child": {
                "id": 2,
                "slug": "built-in-functions",
                "name": "Built-in functions",
                "description": "Understand the role of fragment shaders in the graphics pipeline and explore a large collection of built-in GLSL functions.",
                "order": 0,
                "createdBy": {
                    "id": 3,
                    "name": "Alexander"
                },
                "locked": false,
                "tasks": [
                    {
                        "id": 89,
                        "slug": "fragment-shader",
                        "moduleId": 2,
                        "name": "Fragment Shader",
                        "order": 0,
                        "cost": 5,
                        "score": 5,
                        "accepted": true,
                        "rejected": false,
                        "match": 1,
                        "locked": false,
                        "premiumLock": 0,
                        "premium": false,
                        "child": {
                            "task": {
                                "id": 89,
                                "slug": "fragment-shader",
                                "moduleId": 2,
                                "name": "Fragment Shader",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "void main() {\n  gl_FragColor = vec4(1.0, 1.0, 0.0, 1.0);\n}",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "void main() {\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1,\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "**Fragment shader** is a type of shader program used in computer graphics to control the appearance of individual pixels on a screen or surface. Fragment shaders are responsible for determining the final color of each pixel after all other stages of the rendering pipeline have been completed.\n\n<br>\n\n### How a Fragment Shader Works:\n\n1. **Input Data**: The fragment shader receives input data from the previous stages of the rendering pipeline, such as position, texture coordinates, normals, and other attributes associated with each pixel.\n\n2. **Processing**: The fragment shader calculates the final color of each pixel based on the input data and any additional parameters or textures provided. This calculation can involve various operations, such as texture sampling, lighting calculations, color blending, and more.\n\n3. **Output**: The fragment shader outputs the final color of each pixel, which is then combined with other pixels to generate the final image that is displayed on the screen.\n\nFragment shaders are written in specialized programming languages such as **GLSL** (OpenGL Shading Language) and are executed on the GPU (Graphics Processing Unit) for optimal performance.\n\n<br>\n\nIn OpenGL, a fragment shader has a single `main` function that produces a color value by writing it to the predefined output variable `gl_FragColor`. This variable represents the final color of the current fragment/pixel being processed by the shader. The `gl_FragColor` variable is of type `vec4`, which represents a 4-component vector containing red, green, blue, and alpha (transparency) values. Color components are normalized, ranging from 0.0 to 1.0.\n\n<br>\n\nYou can customize the logic inside the `main` function to calculate the final color based on your specific requirements, such as applying textures, performing lighting calculations, or blending colors.\n\n### Task\nWrite a shader program that modifies the output color to yellow, which is a combination of red and green.",
                                "hints": [],
                                "restrictions": [],
                                "order": 0,
                                "cost": 5,
                                "threshold": 95,
                                "likes": 37,
                                "dislikes": 1,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": false
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "void main() {\n      gl_FragColor = vec4(1.0, 1.0, 0.0, 1.0);\n}\n",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "void main() {\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "liked": false,
                            "disliked": false,
                            "accepted": true,
                            "answerViewed": false,
                            "submissions": [
                                {
                                    "score": 5,
                                    "accepted": true,
                                    "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                    "fragmentShader": "void main() {\n      gl_FragColor = vec4(1.0, 1.0, 0.0, 1.0);\n}\n",
                                    "at": "2025-03-13T05:48:08.000Z"
                                },
                                {
                                    "score": 5,
                                    "accepted": true,
                                    "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                    "fragmentShader": "void main() {\n   \n  gl_FragColor = vec4(1.0, 1.0, 0.0, 1.0);\n}\n",
                                    "at": "2025-03-13T03:29:34.000Z"
                                },
                                {
                                    "score": 5,
                                    "accepted": true,
                                    "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                    "fragmentShader": "void main() {\n  gl_FragColor = vec4(1.0, 1.0, 0.0, 1.0);\n}\n",
                                    "at": "2025-03-11T08:47:39.000Z"
                                },
                                {
                                    "score": 0,
                                    "accepted": false,
                                    "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                    "fragmentShader": "void main() {\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                                    "at": "2025-03-10T07:04:15.000Z"
                                },
                                {
                                    "score": 0,
                                    "accepted": false,
                                    "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                    "fragmentShader": "void main() {\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                                    "at": "2025-03-10T07:04:08.000Z"
                                }
                            ]
                        }
                    },
                    {
                        "id": 14,
                        "slug": "vec",
                        "moduleId": 2,
                        "name": "Vec",
                        "order": 1,
                        "cost": 5,
                        "score": 5,
                        "accepted": true,
                        "rejected": false,
                        "match": 1,
                        "locked": false,
                        "premiumLock": 0,
                        "premium": false,
                        "child": {
                            "task": {
                                "id": 14,
                                "slug": "vec",
                                "moduleId": 2,
                                "name": "Vec",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "void main() {\n  vec4 blueChannel = vec4(0.0, 0.0, 0.75, 0.0);\n  vec4 redChannel = vec4(0.5, 0.0, 0.0, 0.0);\n  vec4 alphaChannel = vec4(0.0, 0.0, 0.0, 1.0);\n  \n  gl_FragColor = blueChannel + redChannel + alphaChannel;\n}",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "void main() {\n  vec4 blueChannel = vec4(0.0, 0.0, 0.75, 0.0);\n  vec4 redChannel = vec4(0.5, 0.0, 0.0, 0.0);\n  vec4 alphaChannel = vec4(0.0, 0.0, 0.0, 1.0);\n  \n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1,\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "In GLSL, **vec** is a data type used to define vectors. Vectors are used to represent a collection of scalar values (such as floats, ints, etc.) organized in one, two, three, or four dimensions. The **vec** data type is followed by a number that specifies the dimensionality of the vector.\n\n<br>\n\n### Common vec types in GLSL:\n\n- **vec2**: two-dimensional vector containing two scalar values.\n\n- **vec3**: three-dimensional vector containing three scalar values.\n\n- **vec4**: four-dimensional vector containing four scalar values.\n\nYou can use vectors in GLSL to represent positions, directions, colors, texture coordinates, and more. Vector values can have the same math operators applied to them as scalar values do. These operators perform component-wise operations on each element of the vector. However, for these operators to work on vectors, the two vectors must have the same number of elements.\n\n<br>\n\n### Examples of using vec in GLSL:\n\n#### Defining a vec variable:\n```\nvec3 position = vec3(1.0, 2.0, 3.0);\n```\n\n#### Accessing components of a vec variable:\n```\nfloat x = position.x; // accesses the x component of the vec3 position\nfloat y = position.y; // accesses the y component of the vec3 position\nfloat z = position.z; // accesses the z component of the vec3 position\n```\n\n#### Performing operations on vec variables:\n```\nvec2 a = vec2(1.0, 2.0);\nvec2 b = vec2(3.0, 4.0);\n\nvec2 sum = a + b;        // vector addition\nvec2 difference = a - b; // vector subtraction\nvec2 scaled = a * 2.0;   // scalar multiplication\n```\n\n### Task\nFind the sum of three vectors in the program (`blueChannel`, `redChannel`, `alphaChannel`), and print the result using `gl_FragColor` variable.",
                                "hints": [],
                                "restrictions": [],
                                "order": 1,
                                "cost": 5,
                                "threshold": 95,
                                "likes": 20,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": false
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "void main() {\n  vec4 blueChannel = vec4(0.0, 0.0, 0.75, 0.0);\n  vec4 redChannel = vec4(0.5, 0.0, 0.0, 0.0);\n  vec4 alphaChannel = vec4(0.0, 0.0, 0.0, 1.0);\n  vec4 color = blueChannel + redChannel + alphaChannel;\n  gl_FragColor = color;\n}\n",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "void main() {\n  vec4 blueChannel = vec4(0.0, 0.0, 0.75, 0.0);\n  vec4 redChannel = vec4(0.5, 0.0, 0.0, 0.0);\n  vec4 alphaChannel = vec4(0.0, 0.0, 0.0, 1.0);\n  \n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "liked": false,
                            "disliked": false,
                            "accepted": true,
                            "answerViewed": false,
                            "submissions": [
                                {
                                    "score": 5,
                                    "accepted": true,
                                    "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                    "fragmentShader": "void main() {\n  vec4 blueChannel = vec4(0.0, 0.0, 0.75, 0.0);\n  vec4 redChannel = vec4(0.5, 0.0, 0.0, 0.0);\n  vec4 alphaChannel = vec4(0.0, 0.0, 0.0, 1.0);\n  vec4 color = blueChannel + redChannel + alphaChannel;\n  gl_FragColor = color;\n}\n",
                                    "at": "2025-03-13T03:26:46.000Z"
                                }
                            ]
                        }
                    },
                    {
                        "id": 145,
                        "slug": "swizzling",
                        "moduleId": 2,
                        "name": "Swizzling",
                        "order": 2,
                        "cost": 5,
                        "score": 5,
                        "accepted": true,
                        "rejected": false,
                        "match": 1,
                        "locked": false,
                        "premiumLock": 0,
                        "premium": false,
                        "child": {
                            "task": {
                                "id": 145,
                                "slug": "swizzling",
                                "moduleId": 2,
                                "name": "Swizzling",
                                "vertexShader": "varying vec4 color;\n\nvoid main() {\n  color = vec4(62.0 / 255.0, 84.0 / 255.0, 194.0 / 255.0, 1.0);\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "varying vec4 color;\n\nvoid main() {\n  gl_FragColor = color.bgra;\n}",
                                "defaultVertexShader": "varying vec4 color;\n\nvoid main() {\n  color = vec4(62.0 / 255.0, 84.0 / 255.0, 194.0 / 255.0, 1.0);\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "varying vec4 color;\n\nvoid main() {\n  gl_FragColor = color;\n}",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1,\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "**Swizzling** in GLSL refers to the technique of selecting and rearranging components of a vector to create a new vector. It allows you to access and manipulate individual components of a vector in a concise and flexible manner. *Swizzling* is achieved by using a combination of component names **x**, **y**, **z**, **w**, referring to the first, second, third, and fourth components, respectively.\n\n<br>\n\nAlso you can use the **r**, **g**, **b** and **a** swizzle mask instead of the **x**, **y**, **z**, **w** to access components of a vector. The **rgba** mask is commonly used when working with colors or texture data, as it corresponds to the red, green, blue, and alpha components typically associated with color information.\n\n<br>\n\n### Here are some examples of swizzling in GLSL:\n\n#### Accessing Components:\n```\nvec4 position = vec3(1.0, 0.5, 0.2);\n\nfloat x = position.x; // accesses the x component\nfloat y = position.y; // accesses the y component\nfloat z = position.z; // accesses the z component\n```\n\n#### Swizzling Color Components:\n```\nvec4 color = vec4(1.0, 0.5, 0.2, 1.0);\n\n// creates a vec3 with the red, green, and blue components\nvec3 rgb  = color.rgb;\n\n// reorders the components using rgba swizzle\nvec4 rgba = color.bgra;\n```\n\n#### Combining Color Swizzle and Operations:\n```\nvec3 baseColor = vec3(0.5, 0.3, 0.8);\nfloat alpha = 0.7;\n\n// creates a new color with specified RGB components and alpha\nvec4 finalColor = vec4(baseColor.rgb, alpha);\n```\n\n### Task\nUsing swizzle reorder pixel's color components from `rgba` to `bgra`.",
                                "hints": [],
                                "restrictions": [],
                                "order": 2,
                                "cost": 5,
                                "threshold": 99,
                                "likes": 12,
                                "dislikes": 1,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": false
                            },
                            "vertexShader": "varying vec4 color;\n\nvoid main() {\n  color = vec4(62.0 / 255.0, 84.0 / 255.0, 194.0 / 255.0, 1.0);\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "varying vec4 color;\n\nvoid main() {\n  vec4 bgra = color.bgra;\n  gl_FragColor = bgra;\n}",
                            "defaultVertexShader": "varying vec4 color;\n\nvoid main() {\n  color = vec4(62.0 / 255.0, 84.0 / 255.0, 194.0 / 255.0, 1.0);\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "varying vec4 color;\n\nvoid main() {\n  gl_FragColor = color;\n}",
                            "liked": false,
                            "disliked": false,
                            "accepted": true,
                            "answerViewed": false,
                            "submissions": [
                                {
                                    "score": 5,
                                    "accepted": true,
                                    "vertexShader": "varying vec4 color;\n\nvoid main() {\n  color = vec4(62.0 / 255.0, 84.0 / 255.0, 194.0 / 255.0, 1.0);\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                    "fragmentShader": "varying vec4 color;\n\nvoid main() {\n  vec4 bgra = color.bgra;\n  gl_FragColor = bgra;\n}",
                                    "at": "2025-03-13T13:08:16.000Z"
                                }
                            ]
                        }
                    },
                    {
                        "id": 19,
                        "slug": "uv-coordinates-&-uniforms",
                        "moduleId": 2,
                        "name": "UV Coordinates & Uniforms",
                        "order": 3,
                        "cost": 5,
                        "score": 5,
                        "accepted": true,
                        "rejected": false,
                        "match": 1,
                        "locked": false,
                        "premiumLock": 0,
                        "premium": false,
                        "child": {
                            "task": {
                                "id": 19,
                                "slug": "uv-coordinates-&-uniforms",
                                "moduleId": 2,
                                "name": "UV Coordinates & Uniforms",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(uv, 0.0, 1.0);\n}\n",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1,\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "Shader programs are used to create 2D images or textures. In order not to work with the specific dimensions of the resulting texture, we will use `UV` coordinates. This is the normalization of the texture coordinate, where the lower left corner of the texture is `(0, 0)` and the upper right is `(1.0, 1.0)`.\n\n<br>\n\n### Normalizing Pixel Coordinates\n\n<br>\n\nTo get the normalized coordinates of the current pixel, divide its position by the resolution of the texture:\n\n\n```\nvec2 uv = gl_FragCoord.xy / iResolution.xy;\n```\n\n### gl_FragCoord\n\n<br>\n\n`gl_FragCoord` is a built-in variable in a shader program that represents the pixel coordinates of the fragment being processed. It is a 4D vector that contains the X, Y, Z, and W components of the fragment's position:\n\n- • **X and Y**: screen-space coordinates of the fragment.\n- • **Z**: depth value. \n- • **W**: perspective divide values, respectively. \n\nThe `gl_FragCoord` variable is typically used to perform various calculations based on the position of the fragment.\n\n<br>\n\n### iResolution\n\n<br>\n\n`iResolution` is a uniform variable that holds the resolution of the texture. Uniforms are used to send some inputs from the CPU to all shader programs. Each program receives the same data which it can read but cannot change. The purpose of a uniform is to provide a way for the application to control the behavior of the shader without having to modify the shader code itself. This allows for greater flexibility in rendering, as the same shader can be used with different data inputs to produce different effects.\n\n### Task\nA shader is a set of instructions that are executed simultaneously for each pixel on the screen. It can produce different color result depending on the pixel data such as position on the screen.\n\n<br>\n\nUse the `x` component of the pixel's normalized coordinates as the red and the `y` component as the green when writing pixel's color. As a result, you should notice that the intensity of the red color increases from left to right, and the intensity of the green color increases from bottom to top. In the upper right corner we get yellow color as a result of mixing green and red.",
                                "hints": [],
                                "restrictions": [],
                                "order": 3,
                                "cost": 5,
                                "threshold": 95,
                                "likes": 29,
                                "dislikes": 3,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": false
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy/iResolution.xy;\n  gl_FragColor = vec4(uv.x, uv.y, 0.0, 1.0);\n}\n",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "liked": false,
                            "disliked": false,
                            "accepted": true,
                            "answerViewed": false,
                            "submissions": [
                                {
                                    "score": 5,
                                    "accepted": true,
                                    "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                    "fragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy/iResolution.xy;\n  gl_FragColor = vec4(uv.x, uv.y, 0.0, 1.0);\n}\n",
                                    "at": "2025-03-13T13:15:26.000Z"
                                }
                            ]
                        }
                    },
                    {
                        "id": 1,
                        "slug": "step",
                        "moduleId": 2,
                        "name": "Step",
                        "order": 4,
                        "cost": 5,
                        "score": 0,
                        "accepted": true,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": 0,
                        "premium": false,
                        "child": {
                            "task": {
                                "id": 1,
                                "slug": "step",
                                "moduleId": 2,
                                "name": "Step",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = gl_FragCoord.xy / iResolution;\n\n    gl_FragColor = vec4(step(0.5, uv.x), 0.0, 0.0, 1.0);\n}",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1,\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "The `step` is a threshold function. It returns `0.0` if the passed `x` value is less than the `edge` threshold value, otherwise it returns `1.0`.\n\n<br>\n\n### Function Signature\n\n```\nfloat step(float edge, float x)\n```\n\n### How It Works\n\n<br>\n\nHere's a breakdown of how the step function works:\n\n- If `x < edge`, the function returns `0.0`.\n- If `x >= edge`, the function returns `1.0`.\n\n### Practical Applications\n\n<br>\n\nThis function is commonly used in shaders to create step-like effects, such as creating sharp transitions or defining regions based on a threshold value.\n\n<br>\n\n### Example Usage\n\n<br>\n\nLet's look at an example of how the Step function can be used in GLSL shaders:\n```\nfloat edge = 0.5;\nfloat x = 0.3;\nfloat result = step(edge, x); // will return 0.0 since `x` < `edge`\n```\n\n### Task\nWrite a shader that splits the screen into two parts: the left half should be black and the right half should be red. The shader should work for any screen resolution. To achieve this, consider using the `iResolution` uniform variable and `gl_FragColor` to control the position of the split.\n\n<br>\n\n### Requirements\n\n<br>\n\nThe shader should avoid using branching or conditional statements in its code, and instead rely on the `step` function to determine the color of each pixel.",
                                "hints": [],
                                "restrictions": [],
                                "order": 4,
                                "cost": 5,
                                "threshold": 95,
                                "likes": 24,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 2,
                                        "default": false,
                                        "keyword": "if",
                                        "message": "avoid using branching or conditional statements",
                                        "severity": 2
                                    },
                                    {
                                        "id": 3,
                                        "default": false,
                                        "keyword": "for",
                                        "message": "avoid using branching or conditional statements",
                                        "severity": 2
                                    },
                                    {
                                        "id": 4,
                                        "default": false,
                                        "keyword": "while",
                                        "message": "avoid using branching or conditional statements",
                                        "severity": 2
                                    },
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": false
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy/iResolution.xy;\n  float x = step(0.5,uv.x);\n  gl_FragColor = vec4(x, 0.0, 0.0, 1.0);\n}\n",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "liked": false,
                            "disliked": false,
                            "accepted": true,
                            "answerViewed": true,
                            "submissions": [
                                {
                                    "score": 5,
                                    "accepted": true,
                                    "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                    "fragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy/iResolution.xy;\n  float x = step(0.5,uv.x);\n  gl_FragColor = vec4(x, 0.0, 0.0, 1.0);\n}\n",
                                    "at": "2025-03-13T13:30:16.000Z"
                                }
                            ]
                        }
                    },
                    {
                        "id": 144,
                        "slug": "step-invert",
                        "moduleId": 2,
                        "name": "Step - Invert",
                        "order": 5,
                        "cost": 5,
                        "score": 5,
                        "accepted": true,
                        "rejected": false,
                        "match": 1,
                        "locked": false,
                        "premiumLock": 0,
                        "premium": false,
                        "child": {
                            "task": {
                                "id": 144,
                                "slug": "step-invert",
                                "moduleId": 2,
                                "name": "Step - Invert",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = gl_FragCoord.xy / iResolution;\n\n    gl_FragColor = vec4(1.0 - step(0.5, uv.x), 0.0, 0.0, 1.0);\n}",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1,\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "You can invert the result of the `step` function by subtracting the step function result from `1`.\n\n<br>\n\n### How It Works\n\n<br>\n\nThe `step` function returns `0.0` if the input value is less than the threshold and `1.0` if the input value is greater than or equal to the threshold. By subtracting this result from `1.0`, you effectively invert the output:\n\n- • If the original result is `0.0`, the inverted result will be `1.0`.\n- • If the original result is `1.0`, the inverted result will be `0.0`.\n\n### Example\n\n<br>\n\nHere's an example code snippet to illustrate how to invert the result of the `step` function in GLSL:\n\n```\nfloat invertedStep = 1.0 - step(threshold, value);\n```\n\nAs a result, the `invertedStep` will be `0.0` if the `value` is greater than or equal to the `threshold`, and `1.0` otherwise.\n\n### Task\nWrite a shader that splits the screen into two parts: the left half should be red and the right half should be black.\n\n<br>\n\n### Requirements\n\n<br>\n\nThe shader should avoid using branching or conditional statements in its code, and instead rely on the `step` function to determine the color of each pixel.",
                                "hints": [],
                                "restrictions": [],
                                "order": 5,
                                "cost": 5,
                                "threshold": 99,
                                "likes": 8,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": false
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(step(uv.x,.5), 0.0, 0.0, 1.0);\n}",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}",
                            "liked": false,
                            "disliked": false,
                            "accepted": true,
                            "answerViewed": false,
                            "submissions": [
                                {
                                    "score": 5,
                                    "accepted": true,
                                    "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                    "fragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(step(uv.x,.5), 0.0, 0.0, 1.0);\n}",
                                    "at": "2025-03-13T13:22:25.000Z"
                                }
                            ]
                        }
                    },
                    {
                        "id": 146,
                        "slug": "max",
                        "moduleId": 2,
                        "name": "Max",
                        "order": 6,
                        "cost": 5,
                        "score": 5,
                        "accepted": true,
                        "rejected": false,
                        "match": 1,
                        "locked": false,
                        "premiumLock": 0,
                        "premium": false,
                        "child": {
                            "task": {
                                "id": 146,
                                "slug": "max",
                                "moduleId": 2,
                                "name": "Max",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  float t1 = 1.0 - step(0.25, uv.x);\n  float t2 = step(0.75, uv.x);\n\n  vec3 color = vec3(1.0, 0.3, 0.3);\n\n  gl_FragColor = vec4(color * max(t1, t2), 1.0);\n}\n",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  vec3 color = vec3(1.0, 0.3, 0.3);\n\n  gl_FragColor = vec4(color, 1.0);\n}\n",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1,\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "The `max` function in GLSL is used to return the maximum value between two input values. It takes two parameters and returns the greater of the two values. Here's a detailed explanation of how the `max` function works in GLSL:\n\n<br>\n\n### Function Signature\n\n```\nfloat max(float x, float y);\n```\n\n### How It Works\n\n<br>\n\nHere's a breakdown of how the `max` function works:\n- If `x` is greater than or equal to `y`, the function returns `x`.\n- If `y` is greater than `x`, the function returns `y`.\n\n### Example Usage\n```\nfloat a = 5.0;\nfloat b = 3.0;\nfloat result = max(a, b); // will be 5.0\n```\n\nThe `max` function is widely used for tasks such as clamping values and simplifying conditional logic.\n\n### Task\nUsing the `max` and `step` functions, paint only those pixels whose normalized x-coordinate is less than `0.25` or greater than `0.75`.\n\n<br>\n\n### Requirements\n\n<br>\n\nThe shader should avoid using branching or conditional statements in its code, and instead rely on the `step` and `max` functions to determine the color of each pixel.",
                                "hints": [],
                                "restrictions": [],
                                "order": 6,
                                "cost": 5,
                                "threshold": 99,
                                "likes": 33,
                                "dislikes": 3,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 45,
                                        "default": false,
                                        "keyword": "while",
                                        "message": "avoid using branching or conditional statements",
                                        "severity": 2
                                    },
                                    {
                                        "id": 46,
                                        "default": false,
                                        "keyword": "clamp",
                                        "message": "clamp is prohibited in this task",
                                        "severity": 2
                                    },
                                    {
                                        "id": 47,
                                        "default": false,
                                        "keyword": "if",
                                        "message": "avoid using branching or conditional statements",
                                        "severity": 2
                                    },
                                    {
                                        "id": 48,
                                        "default": false,
                                        "keyword": "for",
                                        "message": "avoid using branching or conditional statements",
                                        "severity": 2
                                    },
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": false
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  vec3 color = vec3(1.0, 0.3, 0.3);\n  float flag = step(0.25,abs(0.5-uv.x));\n  gl_FragColor = vec4(color*flag, 1.0);\n}\n",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  vec3 color = vec3(1.0, 0.3, 0.3);\n\n  gl_FragColor = vec4(color, 1.0);\n}\n",
                            "liked": false,
                            "disliked": false,
                            "accepted": true,
                            "answerViewed": false,
                            "submissions": [
                                {
                                    "score": 5,
                                    "accepted": true,
                                    "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                    "fragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  vec3 color = vec3(1.0, 0.3, 0.3);\n  float flag = step(0.25,abs(0.5-uv.x));\n  gl_FragColor = vec4(color*flag, 1.0);\n}\n",
                                    "at": "2025-03-13T13:28:18.000Z"
                                }
                            ]
                        }
                    },
                    {
                        "id": 85,
                        "slug": "step-union",
                        "moduleId": 2,
                        "name": "Step Union",
                        "order": 7,
                        "cost": 5,
                        "score": 5,
                        "accepted": true,
                        "rejected": false,
                        "match": 1,
                        "locked": false,
                        "premiumLock": 0,
                        "premium": false,
                        "child": {
                            "task": {
                                "id": 85,
                                "slug": "step-union",
                                "moduleId": 2,
                                "name": "Step Union",
                                "vertexShader": "void main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  float w0 = 50.0 / iResolution.x;\n  float w1 = 50.0 / iResolution.y;\n  \n  float t1 = step(1.0 - w0, uv.x);\n  float t2 = 1.0 - step(w0, uv.x);\n  float t3 = step(1.0 - w1, uv.y);\n  float t4 = 1.0 - step(w1, uv.y);\n\n  float t = max(t1, max(t2, max(t3, t4)));\n\n  gl_FragColor = vec4(uv * t, 0.0, 1.0);\n}",
                                "defaultVertexShader": "void main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1,\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "The union of `step` functions is a new function that returns **1** if a value is greater than the threshold value of at least one `step` function from the union. To use union, you can simply compute all the results of the `step` functions at a given point and take the maximum of them.\n\n<br>\n\n### Implementation\n\n<br>\n\nHere's how you can implement this in GLSL:\n\n```\nfloat stepUnion(float x) {\n    // check if the value is less than 0.25.\n    float r0 = 1.0 - step(0.25, x);\n\n    // check if the value is greater than 0.75.\n    float r1 = step(0.75, x);\n\n    // check if the value is less than 0.25 or greater than 0.75.\n    return max(r0, r1);\n}\n```\n\nThe function returns **1** if **x** is less than **0.25** or greater than **0.75**, and **0** otherwise.\n\n<br>\n\n### Examples\n\n<br>\n\nLet's see how this function works with different input values:\n\n```\nstepUnion(0.1); // will be 1 since 0.1 is less than 0.25.\nstepUnion(0.5); // will be 0 since 0.5 is greater than 0.25 and less than 0.75.\nstepUnion(0.9); // will be 1 since 0.1 is greater than 0.75.\n```\n\nBy using the maximum of the results, you can easily determine if a value falls outside a specified range. \n\n### Task\nCreate a shader program that draws a rectangular frame border around the screen. The border width is `50` pixels. Use `uv` coordinates as the frame border color.\n\n<br>\n\nUse the `step` function to draw each border separately. Next, combine the borders together to create a frame. To do this, you only need to compute the union of the test results.\n\n<br>\n\n### Requirements\n\n<br>\n\nThe shader should avoid using branching or conditional statements in its code, and instead rely on the `step` and `max` functions to determine the color of each pixel.",
                                "hints": [],
                                "restrictions": [],
                                "order": 7,
                                "cost": 5,
                                "threshold": 99,
                                "likes": 32,
                                "dislikes": 6,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 5,
                                        "default": false,
                                        "keyword": "if",
                                        "message": "avoid using branching or conditional statements",
                                        "severity": 2
                                    },
                                    {
                                        "id": 22,
                                        "default": false,
                                        "keyword": "for",
                                        "message": "avoid using branching or conditional statements",
                                        "severity": 2
                                    },
                                    {
                                        "id": 23,
                                        "default": false,
                                        "keyword": "while",
                                        "message": "avoid using branching or conditional statements",
                                        "severity": 2
                                    },
                                    {
                                        "id": 44,
                                        "default": false,
                                        "keyword": "clamp",
                                        "message": "clamp is prohibited in this task",
                                        "severity": 0
                                    },
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": false
                            },
                            "vertexShader": "void main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\n\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  // float color_left = stepUnion(gl_FragCoord.xy);\n  float r0 = (1.0 - step(50., gl_FragCoord.x));\n  float r1 = step(iResolution.x-50., gl_FragCoord.x);\n  float xLimit = max(r0, r1);\n  float y0 = (1.0 - step(50., gl_FragCoord.y));\n  float y1 = step(iResolution.y-50., gl_FragCoord.y);\n  float yLimit = max(y0,y1);\n  float redLimit = max(xLimit,yLimit);\n  gl_FragColor = vec4(redLimit*uv, 0.0, 1.0);\n}\n",
                            "defaultVertexShader": "void main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "liked": false,
                            "disliked": false,
                            "accepted": true,
                            "answerViewed": false,
                            "submissions": [
                                {
                                    "score": 5,
                                    "accepted": true,
                                    "vertexShader": "void main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                    "fragmentShader": "uniform vec2 iResolution;\n\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  // float color_left = stepUnion(gl_FragCoord.xy);\n  float r0 = (1.0 - step(50., gl_FragCoord.x));\n  float r1 = step(iResolution.x-50., gl_FragCoord.x);\n  float xLimit = max(r0, r1);\n  float y0 = (1.0 - step(50., gl_FragCoord.y));\n  float y1 = step(iResolution.y-50., gl_FragCoord.y);\n  float yLimit = max(y0,y1);\n  float redLimit = max(xLimit,yLimit);\n  gl_FragColor = vec4(redLimit*uv, 0.0, 1.0);\n}\n",
                                    "at": "2025-03-13T13:52:01.000Z"
                                }
                            ]
                        }
                    },
                    {
                        "id": 23,
                        "slug": "fract",
                        "moduleId": 2,
                        "name": "Fract",
                        "order": 8,
                        "cost": 5,
                        "score": 5,
                        "accepted": true,
                        "rejected": false,
                        "match": 1,
                        "locked": false,
                        "premiumLock": 0,
                        "premium": false,
                        "child": {
                            "task": {
                                "id": 23,
                                "slug": "fract",
                                "moduleId": 2,
                                "name": "Fract",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "\nuniform vec2 iResolution;\nuniform float iTime;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  float x = fract(uv.x * 10.0);\n  gl_FragColor = vec4(step(0.5, x), 0.0, 0.0, 1.0);\n}\n",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1,\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "The `fract` function is used to return the fractional part of a floating-point value. The function takes a single argument, which can be a `float`, `vec2`, `vec3`, or `vec4`, and returns a value between `0.0` and `1.0`. \n\n<br>\n\n### Function Signature\n\n```\nfloat fract(float x)\n```\n\n### How It Works\n\n<br>\n\nThe `fract` function works by subtracting the integer part of the input value, leaving only the fractional part. For example, `fract(3.14)` would return 0.14, as the integer part of 3.14 is 3.\n\n<br>\n\n### Examples\n\n<br>\n\nHere are some examples of using the fract function in GLSL:\n#### Single float input:\n```\nfloat x = 3.75;\nfloat fractionalPart = fract(x); // will be 0.75\n```\n#### Vector input:\n```\nvec2 v = vec2(1.25, 2.75);\nvec2 fractionalParts = fract(v); // will be vec2(0.25, 0.75)\n```\n\nThe `fract` function is particularly useful in procedural texture generation, animation, and other graphics applications where you need to work with periodic patterns or wrap-around effects.\n\n### Task\nCreate a shader program that divides the normalized coordinate range of `[0, 1]` into `10` equal intervals across the entire width of the texture. Each interval should be `0.1` of the total screen width. The left half of each interval should be black, and the right half should be red. As a result, the program should produce a sequence of alternating black and red intervals across the entire width of the texture.\n\n<br>\n\n### Requirements\n\n<br>\n\nThe shader should avoid using branching or conditional statements in its code, and instead rely on the fract and step functions to determine the color of each pixel.\n",
                                "hints": [],
                                "restrictions": [],
                                "order": 8,
                                "cost": 5,
                                "threshold": 95,
                                "likes": 22,
                                "dislikes": 2,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 7,
                                        "default": false,
                                        "keyword": "mod",
                                        "message": "mod function is not allowed in this task",
                                        "severity": 2
                                    },
                                    {
                                        "id": 16,
                                        "default": false,
                                        "keyword": "if",
                                        "message": "avoid using branching or conditional statements",
                                        "severity": 2
                                    },
                                    {
                                        "id": 24,
                                        "default": false,
                                        "keyword": "for",
                                        "message": "avoid using branching or conditional statements",
                                        "severity": 2
                                    },
                                    {
                                        "id": 25,
                                        "default": false,
                                        "keyword": "while",
                                        "message": "avoid using branching or conditional statements",
                                        "severity": 2
                                    },
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": false
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  float x = step(0.5,fract(uv.x*10.0));\n  gl_FragColor = vec4(x, 0.0, 0.0, 1.0);\n}\n",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "liked": false,
                            "disliked": false,
                            "accepted": true,
                            "answerViewed": false,
                            "submissions": [
                                {
                                    "score": 5,
                                    "accepted": true,
                                    "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                    "fragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  float x = step(0.5,fract(uv.x*10.0));\n  gl_FragColor = vec4(x, 0.0, 0.0, 1.0);\n}\n",
                                    "at": "2025-03-13T14:08:13.000Z"
                                }
                            ]
                        }
                    },
                    {
                        "id": 147,
                        "slug": "tile-pattern",
                        "moduleId": 2,
                        "name": "Tile Pattern",
                        "order": 9,
                        "cost": 5,
                        "score": 5,
                        "accepted": true,
                        "rejected": false,
                        "match": 1,
                        "locked": false,
                        "premiumLock": 0,
                        "premium": false,
                        "child": {
                            "task": {
                                "id": 147,
                                "slug": "tile-pattern",
                                "moduleId": 2,
                                "name": "Tile Pattern",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\n\nfloat pattern(vec2 uv) {\n  uv = uv * 2.0 - 1.0;\n  float t = pow(uv.x * uv.x, 0.3) + pow(uv.y * uv.y, 0.3) - 1.0;\n  return step(0.0, t) * t * 10.0 + step(0.2, t);\n}\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  vec2 grid = vec2(5.0, 3.0);\n  vec2 tiled = fract(uv * grid);\n  \n  gl_FragColor = vec4(pattern(tiled), 0.0, 0.0, 1.0);\n}\n",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\n\nfloat pattern(vec2 uv) {\n  uv = uv * 2.0 - 1.0;\n  float t = pow(uv.x * uv.x, 0.3) + pow(uv.y * uv.y, 0.3) - 1.0;\n  return step(0.0, t) * t * 10.0 + step(0.2, t);\n}\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(pattern(uv), 0.0, 0.0, 1.0);\n}\n",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1,\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "By manipulating the `UV` coordinates and using the `fract` function you can create repeating patterns across the screen.\n\n<br>\n\n### Example\n\n<br>\n\nHere's an example code snippet demonstrating how to create a table with repeating cells in a fragment shader:\n\n```\nfloat columns = 2.0;\nfloat rows    = 8.0;\n\n// Calculate repeated cells based on UV coordinates\nvec2 repeatedUV = fract(uv * vec2(columns, rows));\n```\n\n### Adjusting the Pattern\n\n<br>\n\nYou can adjust the `columns` and `rows` values to change the size and density of the repeated cells. For example, increasing the number of columns and rows will create smaller, more densely packed cells.\n\n### Task\nUsing tiling, repeat the pattern as many times as necessary.",
                                "hints": [],
                                "restrictions": [],
                                "order": 9,
                                "cost": 5,
                                "threshold": 98,
                                "likes": 14,
                                "dislikes": 1,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": false
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\n\nfloat pattern(vec2 uv) {\n  uv = uv * 2.0 - 1.0;\n;\n  float t = pow(uv.x * uv.x, 0.3) + pow(uv.y * uv.y, 0.3) - 1.0;\n  return step(0.0, t) * t * 10.0 + step(0.2, t);\n}\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  float cols =5.;\n  float rows = 3.;\n  uv = fract(uv * vec2(cols, rows));\n  gl_FragColor = vec4(pattern(uv), 0.0, 0.0, 1.0);\n}\n",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\n\nfloat pattern(vec2 uv) {\n  uv = uv * 2.0 - 1.0;\n  float t = pow(uv.x * uv.x, 0.3) + pow(uv.y * uv.y, 0.3) - 1.0;\n  return step(0.0, t) * t * 10.0 + step(0.2, t);\n}\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(pattern(uv), 0.0, 0.0, 1.0);\n}\n",
                            "liked": false,
                            "disliked": false,
                            "accepted": true,
                            "answerViewed": false,
                            "submissions": [
                                {
                                    "score": 5,
                                    "accepted": true,
                                    "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                    "fragmentShader": "uniform vec2 iResolution;\n\nfloat pattern(vec2 uv) {\n  uv = uv * 2.0 - 1.0;\n;\n  float t = pow(uv.x * uv.x, 0.3) + pow(uv.y * uv.y, 0.3) - 1.0;\n  return step(0.0, t) * t * 10.0 + step(0.2, t);\n}\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  float cols =5.;\n  float rows = 3.;\n  uv = fract(uv * vec2(cols, rows));\n  gl_FragColor = vec4(pattern(uv), 0.0, 0.0, 1.0);\n}\n",
                                    "at": "2025-03-13T14:15:58.000Z"
                                }
                            ]
                        }
                    },
                    {
                        "id": 86,
                        "slug": "fract-grid",
                        "moduleId": 2,
                        "name": "Fract - Grid",
                        "order": 10,
                        "cost": 5,
                        "score": 5,
                        "accepted": true,
                        "rejected": false,
                        "match": 1,
                        "locked": false,
                        "premiumLock": 0,
                        "premium": false,
                        "child": {
                            "task": {
                                "id": 86,
                                "slug": "fract-grid",
                                "moduleId": 2,
                                "name": "Fract - Grid",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "void main() {\n  float cellSize = 50.0;\n  float margin = 10.0;\n  vec2 cell = gl_FragCoord.xy / (cellSize + margin);\n  \n  float t = step(margin / (cellSize + margin), fract(cell.x));\n  t *= step(margin / (cellSize + margin), fract(cell.y));\n  \n  gl_FragColor = vec4(t, 0.0, 0.0, 1.0);\n}",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "void main() {\n  vec2 fragPos = gl_FragCoord.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1,\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "When drawing cells with margins, you need to calculate the total size of the cell, which includes its width, height, and margin. This can be done by adding the width and margin on the left side, as well as the height and margin on the bottom. Once you have this information, you can determine the position of the pixel within the cell by comparing its coordinates to the cell's boundaries. If the pixel falls within the margin, you can fill it accordingly. Otherwise, fill it inside the cell itself.\n\n### Task\nWrite a shader that draws a grid. Each cell in the grid should be `50x50` pixels in size, with a margin of `10` pixels between cells.\n\n<br>\n\n### Requirements\n\n<br>\n\nThe shader should avoid using branching or conditional statements in its code, and instead rely on the `fract` and `step` functions to determine the color of each pixel.",
                                "hints": [],
                                "restrictions": [],
                                "order": 10,
                                "cost": 5,
                                "threshold": 95,
                                "likes": 27,
                                "dislikes": 1,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 8,
                                        "default": false,
                                        "keyword": "mod",
                                        "message": "mod function is not allowed in this task",
                                        "severity": 2
                                    },
                                    {
                                        "id": 15,
                                        "default": false,
                                        "keyword": "if",
                                        "message": "avoid using branching or conditional statements",
                                        "severity": 2
                                    },
                                    {
                                        "id": 26,
                                        "default": false,
                                        "keyword": "for",
                                        "message": "avoid using branching or conditional statements",
                                        "severity": 2
                                    },
                                    {
                                        "id": 27,
                                        "default": false,
                                        "keyword": "while",
                                        "message": "avoid using branching or conditional statements",
                                        "severity": 2
                                    },
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": false
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "void main() {\n  vec2 fragPos = gl_FragCoord.xy;\n  float x = step(1./6.,fract(gl_FragCoord.y/60.0));\n  float y = step(1./6.,fract(gl_FragCoord.x/60.0));\n  // float y = step(180.0,gl_FragCoord.x);\n  float flag = x*y;\n  // float color = step(1./6.,x);\n  gl_FragColor = vec4(flag, 0.0, 0.0, 1.0);\n}\n",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "void main() {\n  vec2 fragPos = gl_FragCoord.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "liked": false,
                            "disliked": false,
                            "accepted": true,
                            "answerViewed": false,
                            "submissions": [
                                {
                                    "score": 5,
                                    "accepted": true,
                                    "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                    "fragmentShader": "void main() {\n  vec2 fragPos = gl_FragCoord.xy;\n  float x = step(1./6.,fract(gl_FragCoord.y/60.0));\n  float y = step(1./6.,fract(gl_FragCoord.x/60.0));\n  // float y = step(180.0,gl_FragCoord.x);\n  float flag = x*y;\n  // float color = step(1./6.,x);\n  gl_FragColor = vec4(flag, 0.0, 0.0, 1.0);\n}\n",
                                    "at": "2025-03-13T14:36:04.000Z"
                                }
                            ]
                        }
                    },
                    {
                        "id": 24,
                        "slug": "mod",
                        "moduleId": 2,
                        "name": "Mod",
                        "order": 11,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": 0,
                        "premium": false,
                        "child": {
                            "task": {
                                "id": 24,
                                "slug": "mod",
                                "moduleId": 2,
                                "name": "Mod",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  uv *= 9.0;\n  float x = fract(uv.x);\n  x = step(0.5, x);\n  \n  x *= step(1.0, mod(uv.x + 1.0, 3.0));\n\n  gl_FragColor = vec4(x, 0.0, 0.0, 1.0);\n}",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  uv *= 9.0;\n  float x = fract(uv.x);\n  x = step(0.5, x);\n\n  gl_FragColor = vec4(x, 0.0, 0.0, 1.0);\n}",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1,\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "The `mod` function is used to calculate the remainder of a division operation between two numbers. This function is particularly useful in graphics programming for creating repeating patterns, among other applications.\n\n<br>\n\n### Function Signature\n```\nfloat mod(float x, float y);\n```\n\n### How It Works\n\n<br>\n\nThe `mod` function takes two arguments: \n\n- • **Dividend**: the number being divided\n- • **Divisor**: the number by which the dividend is being divided. \n\nThe function returns the remainder of the division operation.\n\n<br>\n\n### Comparison with Modulo Operator\n\n<br>\n\nThe `mod` function works similarly to the modulo operator (`%`) found in many programming languages. However, there are some differences in how negative numbers are handled. In GLSL, the `mod` function always returns a non-negative result.\n\n<br>\n\n### Examples\n\n#### Basic usage with positive numbers:\n```\nfloat result = mod(10.0, 3.0); // Result will be 1.0 (10 / 3 has a remainder of 1)\n```\n\n#### Handling negative numbers:\n```\nfloat result = mod(-10.0, 3.0); // Result will be 2.0 (-10 / 3 has a remainder of 2)\n```\n\n### Practical Applications\n\n<br>\n\n• **Creating Repeating Patterns:** By using the mod function, you can create seamless, repeating textures or patterns.\n\n• **Animation:** It can be used to loop animations by wrapping values within a certain range.\n\n• **Grid Systems:** Useful for creating grid-based effects or dividing the screen into segments.\n\n### Task\nCreate a pattern of alternating black and red columns, with `9` columns of each color. Then, hide every third column that is colored red.\n\n<br>\n\n### Requirements\n\n<br>\n\nThe shader should avoid using branching or conditional statements in its code, and instead rely on the `mod` and `step` functions to determine the color of each pixel.",
                                "hints": [],
                                "restrictions": [],
                                "order": 11,
                                "cost": 5,
                                "threshold": 95,
                                "likes": 19,
                                "dislikes": 4,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 17,
                                        "default": false,
                                        "keyword": "for",
                                        "message": "avoid using branching or conditional statements",
                                        "severity": 2
                                    },
                                    {
                                        "id": 18,
                                        "default": false,
                                        "keyword": "if",
                                        "message": "avoid using branching or conditional statements",
                                        "severity": 2
                                    },
                                    {
                                        "id": 28,
                                        "default": false,
                                        "keyword": "while",
                                        "message": "avoid using branching or conditional statements",
                                        "severity": 2
                                    },
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": false
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  uv *= 9.0;\n  float x = fract(uv.x);\n  x = step(0.5, x);\n\n  gl_FragColor = vec4(x, 0.0, 0.0, 1.0);\n}",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  uv *= 9.0;\n  float x = fract(uv.x);\n  x = step(0.5, x);\n\n  gl_FragColor = vec4(x, 0.0, 0.0, 1.0);\n}",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 15,
                        "slug": "mix",
                        "moduleId": 2,
                        "name": "Mix",
                        "order": 12,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": 0,
                        "premium": false,
                        "child": {
                            "task": {
                                "id": 15,
                                "slug": "mix",
                                "moduleId": 2,
                                "name": "Mix",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  vec3 color2 = vec3(0.38, 0.12, 0.93);\n  vec3 color1 = vec3(1.00, 0.30, 0.30);\n\n  float t = step(0.25, uv.x) * (uv.x - 0.25);\n  \n  gl_FragColor = vec4(mix(color1, color2, t), 1.0);\n}",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  vec3 color2 = vec3(0.38, 0.12, 0.93);\n  vec3 color1 = vec3(1.00, 0.30, 0.30);\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1,\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "the `mix` function is used to perform linear interpolation between two values based on a third interpolation factor. This function is commonly used in shaders to smoothly transition between two values, such as colors, positions, or other attributes.\n\n<br>\n\n### Function Signature\n\n```\nT mix(T start, T end, T t)\n```\n\n### How It Works\n\n<br>\n\nThe `mix` function takes three arguments: `start`, `end`, and `t`, where `start` and `end` are the values to interpolate between, and `t` is the interpolation factor. The `mix` function calculates the result as follows:\n\n```\nmix(start, end, t) = start * (1 - t) + end * t\n```\n\nHere's a breakdown of how the `mix` function works:\n\n1. When `t` is `0`, the result is equal to `start`.\n2. When `t` is `1`, the result is equal to `end`.\n3. When `t` is between `0` and `1`, the result is a linear interpolation between `start` and `end`.\n\n### Examples\n\n#### Color interpolation:\n```\nvec3 color1 = vec3(1.0, 0.0, 0.0); // red color\nvec3 color2 = vec3(0.0, 0.0, 1.0); // blue color\nfloat factor = 0.5;                // interpolation factor\n\n// result will be a purple color (halfway between red and blue)\nvec3 resultColor = mix(color1, color2, factor); \n```\n\n#### Interpolating between two positions:\n```\nvec3 position1 = vec3(0.0, 0.0, 0.0);\nvec3 position2 = vec3(1.0, 1.0, 1.0);\nfloat factor = 0.3;\n\n// result will be a position 30% of the way from position1 to position2\nvec3 interpolatedPosition = mix(position1, position2, factor);\n```\n\n### Task\nUsing the `mix` function create a linear gradient that transitions from a given `color1` to `color2`. Use the  `x` normalized coordinate of the pixel as the interpolation factor. Apply the `step` function so that color transition starts from position `0.25` and ends at `1.0`.",
                                "hints": [],
                                "restrictions": [],
                                "order": 12,
                                "cost": 5,
                                "threshold": 95,
                                "likes": 11,
                                "dislikes": 6,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": false
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  vec3 color2 = vec3(0.38, 0.12, 0.93);\n  vec3 color1 = vec3(1.00, 0.30, 0.30);\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  vec3 color2 = vec3(0.38, 0.12, 0.93);\n  vec3 color1 = vec3(1.00, 0.30, 0.30);\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 87,
                        "slug": "mix-bilinear-interpolation",
                        "moduleId": 2,
                        "name": "Mix - Bilinear Interpolation",
                        "order": 13,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": 0,
                        "premium": false,
                        "child": {
                            "task": {
                                "id": 87,
                                "slug": "mix-bilinear-interpolation",
                                "moduleId": 2,
                                "name": "Mix - Bilinear Interpolation",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  vec3 red = vec3(1.0, 0.0, 0.0);\n  vec3 black = vec3(0.0, 0.0, 0.0);\n  vec3 blue = vec3(0.0, 0.0, 1.0);\n  vec3 green = vec3(0.0, 1.0, 0.0);\n  \n  vec3 r1 = mix(red, black, uv.x);\n  vec3 r2 = mix(blue, green, uv.x);\n  vec3 color = mix(r1, r2, uv.y);\n    \n  gl_FragColor = vec4(color, 1.0);\n}",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  vec3 red = vec3(1.0, 0.0, 0.0);\n  vec3 black = vec3(0.0, 0.0, 0.0);\n  vec3 blue = vec3(0.0, 0.0, 1.0);\n  vec3 green = vec3(0.0, 1.0, 0.0);\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1,\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "**Bilinear interpolation** is a method used to determine the color of a pixel by performing linear interpolations in both the **X** and **Y** directions.\n\n<br>\n\n### Implementation Steps\n\n1. **Horizontal Interpolation.** Perform two linear interpolations in the x-direction (horizontal) to find intermediate colors by blending the horizontally adjacent colors.\n\n2. **Vertical Interpolation.** Perform one linear interpolation along the y-axis (vertical) using the intermediate colors from the previous step to find the resulting color for the pixel.\n\nThis technique is commonly used in image processing and texture mapping to achieve smooth transitions between colors.\n\n### Task \nTo fill the screen using bilinear interpolation, follow these steps:\n\n1. Assign the color blue to the left-top corner of the screen.\n2. Assign the color red to the left-bottom corner of the screen.\n3. Assign the color green to the right-top corner of the screen.\n4. Assign the color black to the right-bottom corner of the screen.\n5. Use bilinear interpolation to blend the colors in between the corners and fill the screen with a smooth gradient.",
                                "hints": [],
                                "restrictions": [],
                                "order": 13,
                                "cost": 5,
                                "threshold": 95,
                                "likes": 9,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": false
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  vec3 red = vec3(1.0, 0.0, 0.0);\n  vec3 black = vec3(0.0, 0.0, 0.0);\n  vec3 blue = vec3(0.0, 0.0, 1.0);\n  vec3 green = vec3(0.0, 1.0, 0.0);\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  vec3 red = vec3(1.0, 0.0, 0.0);\n  vec3 black = vec3(0.0, 0.0, 0.0);\n  vec3 blue = vec3(0.0, 0.0, 1.0);\n  vec3 green = vec3(0.0, 1.0, 0.0);\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 20,
                        "slug": "smoothstep",
                        "moduleId": 2,
                        "name": "Smoothstep",
                        "order": 14,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": 0,
                        "premium": false,
                        "child": {
                            "task": {
                                "id": 20,
                                "slug": "smoothstep",
                                "moduleId": 2,
                                "name": "Smoothstep",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  vec3 red = vec3(1.0, 0.0, 0.0);\n  vec3 green = vec3(0.0, 1.0, 0.0);\n  float mixFactor = smoothstep(0.25, 0.75, uv.x);\n  \n  gl_FragColor = vec4(mix(red, green, mixFactor), 1.0);\n}\n",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1,\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "The `smoothstep` function is used to perform smooth interpolation between two values based on a third interpolation factor. This function provides a smoother transition compared to linear interpolation by applying a smooth curve to the interpolation process.\n\n<br>\n\n### Function Signature\n```\nsmoothInterpolation = smoothstep(edge0, edge1, x)\n```\n\n### How It Works\n\n<br>\n\nThe `smoothstep` function takes three arguments: \n\n<br>\n\n• **edge0**: The lower threshold value.\n\n• **edge1**: The upper threshold value.\n\n• **x**: The interpolation factor.\n\n<br>\n\nCalculation details:\n\n<br>\n\n1\\. If `x` is less than or equal to `edge0`, the result is `0`.\n\n2\\. If `x` is greater than or equal to `edge1`, the result is `1`.\n\n3\\. If `x` is between `edge0` and `edge1`, the result is smoothly interpolated between `0` and `1` using a *Hermite interpolation* function.\n\n<br>\n\nThe *Hermite interpolation* function used by `smoothstep` ensures that the transition between `0` and `1` is smooth and continuous, resulting in a visually pleasing effect.\n\n<br>\n\n### Examples\n```\n// result will be a smooth color interpolation between red and blue\nvec3 out = mix(color1, color2, smoothstep(0.2, 0.8, factor));\n```\n\nIn this example, the `out` color value is transitioning smoothly from `0.2` to `0.8` based on the `factor` value:\n\n<br>\n\n• **When factor is less than 0.2**: the `smoothstep` function evaluates to `0.0`, resulting in the output being closer to `color1`.\n\n• **When factor is greater than 0.8**: the `smoothstep` function evaluates to `1.0`, resulting in the output being closer to `color2`.\n\n• **When factor is between 0.2 and 0.8:** the transition is smooth and continuous, providing more control over where the blending occurs.\n\n### Task\nCreate a gradient effect that smoothly transitions from red to green. The color change should be most noticeable between the x-coordinates of `0.25` and `0.75`.\n\n<br>\n\n### Requirements\n\n<br>\n\nThe shader should avoid using branching or conditional statements in its code, and instead rely on the `smoothstep` and `mix` functions to determine the color of each pixel.",
                                "hints": [],
                                "restrictions": [],
                                "order": 14,
                                "cost": 5,
                                "threshold": 95,
                                "likes": 9,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 19,
                                        "default": false,
                                        "keyword": "while",
                                        "message": "avoid using branching or conditional statements",
                                        "severity": 2
                                    },
                                    {
                                        "id": 20,
                                        "default": false,
                                        "keyword": "for",
                                        "message": "avoid using branching or conditional statements",
                                        "severity": 2
                                    },
                                    {
                                        "id": 21,
                                        "default": false,
                                        "keyword": "if",
                                        "message": "avoid using branching or conditional statements",
                                        "severity": 2
                                    },
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": false
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 21,
                        "slug": "abs",
                        "moduleId": 2,
                        "name": "ABS",
                        "order": 15,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": 0,
                        "premium": false,
                        "child": {
                            "task": {
                                "id": 21,
                                "slug": "abs",
                                "moduleId": 2,
                                "name": "ABS",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  // map to interval from -1 to 1\n  float t = uv.x * 2.0 - 1.0;\n  t = abs(t);\n  \n  gl_FragColor = vec4(t, 0.0, 0.0, 1.0);\n}\n",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  gl_FragColor = vec4(uv.x, 0.0, 0.0, 1.0);\n}\n",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1,\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "The `abs` function is used to calculate the absolute value of a scalar or vector input. The absolute value of a number is its magnitude without regard to its sign. The `abs` function can be applied to scalar values (e.g., floats) as well as vector values (e.g., `vec2`, `vec3`, `vec4`).\n\n<br>\n\n### Function Signature\n```\nfloat abs(float x);\n```\n\n### How It Works\n\n<br>\n\nThe `abs` function operates by:\n\n- • Returning the input value if it is positive or zero.\n- • Returning the negation of the input value if it is negative.\n\nThis ensures that the output of the `abs` function is always positive or zero.\n\n<br>\n\n### Example\n\n```\nfloat number = -5.0;\nfloat absValue = abs(number); // will be 5.0\n```\n\n### Practical Applications\n\n<br>\n\nBy using the `abs` function in GLSL, you can easily mirror functions with respect to the zero value by leveraging the symmetry provided by absolute values. This technique is particularly useful for creating **symmetrical** effects or transformations in shaders.\n\n### Task\nCreate a gradient that linearly transitions from `0.0` (black) at the center to `1.0` (red) at the edges.\n\n<br>\n\n### Requirements\n\n<br>\n\nThe shader should avoid using branching or conditional statements in its code, and instead rely on the `abs` function to determine the color of each pixel.",
                                "hints": [],
                                "restrictions": [],
                                "order": 15,
                                "cost": 5,
                                "threshold": 95,
                                "likes": 8,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 29,
                                        "default": false,
                                        "keyword": "while",
                                        "message": "avoid using branching or conditional statements",
                                        "severity": 2
                                    },
                                    {
                                        "id": 30,
                                        "default": false,
                                        "keyword": "if",
                                        "message": "avoid using branching or conditional statements",
                                        "severity": 2
                                    },
                                    {
                                        "id": 31,
                                        "default": false,
                                        "keyword": "for",
                                        "message": "avoid using branching or conditional statements",
                                        "severity": 2
                                    },
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": false
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  gl_FragColor = vec4(uv.x, 0.0, 0.0, 1.0);\n}\n",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  gl_FragColor = vec4(uv.x, 0.0, 0.0, 1.0);\n}\n",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 88,
                        "slug": "abs-rhomb",
                        "moduleId": 2,
                        "name": "ABS - Rhomb",
                        "order": 16,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": 0,
                        "premium": false,
                        "child": {
                            "task": {
                                "id": 88,
                                "slug": "abs-rhomb",
                                "moduleId": 2,
                                "name": "ABS - Rhomb",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  uv -= 0.5;\n\n  float t = abs(uv.x) + abs(uv.y);\n  t = 1.0 - step(0.5, t);\n  \n  gl_FragColor = vec4(t, 0.0, 0.0, 1.0);\n}\n",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1,\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "Mathematically, a rhombus can be represented as an area bounded by 4 straight lines:\n\n<br>\n\n![Image 1 - Rombus Area](/files/rhomb-full.png)\n\n<br>\n\nLet's focus on determining the equation of the top left border of the rhombus:\n\n<br>\n\n![Image 2 - Rombus top-left border](/files/rhomb-first-line.png)\n\n<br>\n\nIn general, the equation of a straight line has the form:\n```\nY = K * X + B\n```\n\nWhere:\n\n\\- **K** is the slope coefficient of the line, which determines the angle at which the line intersects the x-axis.\n\n\\- **B** is the displacement of the line along the y-axis.\n\n<br>\n\nFor the top-left border, we observe that the **Y** parameter increases at the same rate as **X**, indicating a slope coefficient of 1. The displacement along the y-axis is 0.5. Therefore, the equation of our boundary takes the form:\n\n```\nY = X + 0.5\n```\n\nNext, we aim to describe the area below this straight line:\n\n<br>\n\n![Image 3 - Area below the line](/files/rhomb-first-area.png)\n\n<br>\n\nTo achieve this, we convert our equation into an inequality. Since we are concerned with the area under the line, we replace the equal sign with the less than sign:\n\n```\nY < X + 0.5\n```\n\nSimilarly, we can determine the equations for the remaining three boundaries and find their intersection.\n\n### Task\nWrite a shader that draws the full screen rhombus.\n\n<br>\n\n### Requirements\n\n<br>\n\nThe shader should avoid using branching or conditional statements in its code, and instead rely on the `abs` and `step` functions to determine the color of each pixel.",
                                "hints": [],
                                "restrictions": [],
                                "order": 16,
                                "cost": 5,
                                "threshold": 95,
                                "likes": 13,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 32,
                                        "default": false,
                                        "keyword": "if",
                                        "message": "avoid using branching or conditional statements",
                                        "severity": 2
                                    },
                                    {
                                        "id": 33,
                                        "default": false,
                                        "keyword": "while",
                                        "message": "avoid using branching or conditional statements",
                                        "severity": 2
                                    },
                                    {
                                        "id": 34,
                                        "default": false,
                                        "keyword": "for",
                                        "message": "avoid using branching or conditional statements",
                                        "severity": 2
                                    },
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": false
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 22,
                        "slug": "ceil",
                        "moduleId": 2,
                        "name": "Ceil",
                        "order": 17,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": 0,
                        "premium": false,
                        "child": {
                            "task": {
                                "id": 22,
                                "slug": "ceil",
                                "moduleId": 2,
                                "name": "Ceil",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  float t = ceil(uv.x * 10.0) / 10.0;\n  \n  gl_FragColor = vec4(t, 0.0, 0.0, 1.0);\n}",
                                "postProcessShader": "",
                                "properties": "",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "\nuniform vec2 iResolution;\nuniform float iTime;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                                "defaultPostProcessShader": "",
                                "defaultProperties": "",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1,\"model\":null,\"meshes\":[{\"name\":\"main\",\"materialId\":0}],\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"materials\":[],\"actions\":[],\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250,\"customDepthBufferTexture\":false,\"glslVersion\":1}",
                                "description": "In GLSL, the `ceil` function is used to calculate the smallest integer value that is greater than or equal to a given scalar or vector input. The ceil function rounds up the input value to the nearest integer value that is not less than the input value. This function is particularly useful when you need to round up a value to the next whole number.\n\n<br>\n\n### Function Signature\n```\nfloat ceil(float x)\n```\n\nWhere `x` is the input value for which the ceiling value is to be calculated. The output of the `ceil` function will be the ceiling value of `x`.\n\n<br>\n\n### How It Works\n\n1. If the input value `x` is already an integer, the `ceil` function will return the same integer value without any change.\n\n2. If the input value `x` is a floating-point number, the `ceil` function will round up the value to the next whole number.\n\n3. The `ceil` function always returns a floating-point value, even if the input is an integer.\n\n### Examples\n\n#### Basic usage with float numbers:\n```\nfloat number = 3.5;\nfloat ceilVal = ceil(number); // will be 4.0\n```\n\n#### Handling vectors:\n```\nvec3 vector = vec3(2.3, 5.8, -4.7);\nvec3 ceilVec = ceil(vector); // will be vec3(3.0, 6.0, -4.0)\n```\n\n### Task\nCreate `10` equally sized vertical sections on the screen and label them with sequential numbers from `1` to `10`. Adjust the intensity of the red color in each section based on its assigned number (`0.1`, `0.2` ... `1.0`). This will result in a gradient effect where the red color becomes progressively stronger from left to right.\n\n<br>\n\n### Requirements\n\n<br>\n\nThe shader should avoid using branching or conditional statements in its code, and instead rely on the `ceil` function to determine the color of each pixel.",
                                "hints": [],
                                "restrictions": [],
                                "order": 17,
                                "cost": 5,
                                "threshold": 95,
                                "likes": 7,
                                "dislikes": 1,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 9,
                                        "default": false,
                                        "keyword": "mod",
                                        "message": "mod function is not allowed in this task",
                                        "severity": 2
                                    },
                                    {
                                        "id": 10,
                                        "default": false,
                                        "keyword": "fract",
                                        "message": "fract function is not allowed in this task",
                                        "severity": 2
                                    },
                                    {
                                        "id": 11,
                                        "default": false,
                                        "keyword": "floor",
                                        "message": "floor function is not allowed in this task",
                                        "severity": 2
                                    },
                                    {
                                        "id": 35,
                                        "default": false,
                                        "keyword": "step",
                                        "message": "step function is not allowed in this task",
                                        "severity": 2
                                    },
                                    {
                                        "id": 36,
                                        "default": false,
                                        "keyword": "while",
                                        "message": "avoid using branching or conditional statements",
                                        "severity": 2
                                    },
                                    {
                                        "id": 37,
                                        "default": false,
                                        "keyword": "if",
                                        "message": "avoid using branching or conditional statements",
                                        "severity": 2
                                    },
                                    {
                                        "id": 38,
                                        "default": false,
                                        "keyword": "int",
                                        "message": "int is not allowed in this task",
                                        "severity": 2
                                    },
                                    {
                                        "id": 39,
                                        "default": false,
                                        "keyword": "for",
                                        "message": "avoid using branching or conditional statements",
                                        "severity": 2
                                    },
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": false
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "\nuniform vec2 iResolution;\nuniform float iTime;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "postProcessShader": "",
                            "properties": "",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "\nuniform vec2 iResolution;\nuniform float iTime;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "defaultPostProcessShader": "",
                            "defaultProperties": "",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 28,
                        "slug": "int-floor",
                        "moduleId": 2,
                        "name": "Int / Floor",
                        "order": 18,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": 0,
                        "premium": false,
                        "child": {
                            "task": {
                                "id": 28,
                                "slug": "int-floor",
                                "moduleId": 2,
                                "name": "Int / Floor",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\n\nvec3 palette[5] = vec3[5](\n  vec3(1.0, 0.0, 0.0),\n  vec3(0.0, 1.0, 0.0),\n  vec3(0.0, 0.0, 1.0),\n  vec3(1.0, 1.0, 0.0),\n  vec3(0.0, 0.0, 0.0)\n);\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  float paletteSize = 5.0;\n  float positionOnPalette = uv.x * (paletteSize - 1.0);\n  \n  int prevColorIndex = int(positionOnPalette);\n  int nextColorIndex = prevColorIndex + 1;\n\n  vec3 prevColor = palette[prevColorIndex];\n  vec3 nextColor = palette[nextColorIndex];\n  \n  vec3 color = mix(prevColor, nextColor, fract(positionOnPalette));\n\n  gl_FragColor = vec4(color, 1.0);\n}",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\n\nvec3 palette[5] = vec3[5] (\n  vec3(1.0, 0.0, 0.0),\n  vec3(0.0, 1.0, 0.0),\n  vec3(0.0, 0.0, 1.0),\n  vec3(1.0, 1.0, 0.0),\n  vec3(0.0, 0.0, 0.0)\n);\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1,\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "### Int Function\n\n<br>\n\nThe `int` function in GLSL is used to convert a floating-point value to an integer value by truncating the decimal part. It essentially removes the fractional part of the input value and returns the integer part.\n\n#### Signature\n```\nint int(x)\n```\n\nWhere `x` is a floating-point value that you want to convert to an integer. The output of the `int` function will be integer part of the input value `x`.\n\n#### Example\n\n```\nfloat floatVal = 3.7;\nint intVal = int(floatVal); // will be 3\n```\n\n### Floor Function\n\n<br>\n\nThe `floor` function rounds down the input value to the nearest integer value that is not greater than the input value.\n\n#### Signature\n```\nfloat floor(float x)\n```\n\nWhere `x` is a floating-point value that you want to round down to the nearest integer. The output of the `floor` function will be the largest integer less than or equal to the input value `x`.\n\n#### Example\n```\nfloat val = 3.7;\nfloat flooredVal = floor(val); // will be 3.0\n```\n\n### Task\nCreate a shader program that generates a gradient image using an array of 5 colors. The colors are defined in the following array:\n\n```\nvec3 palette[5] = vec3[5]\n(\n    vec3(1.0, 0.0, 0.0),\n    vec3(0.0, 1.0, 0.0),\n    vec3(0.0, 0.0, 1.0),\n    vec3(1.0, 1.0, 0.0),\n    vec3(0.0, 0.0, 0.0)\n);\n```\n\nThe program should determine which color range the current pixel falls within and interpolate its color accordingly. This will result in a smooth gradient transition between the colors in the array.\n\n#### Hint\n\n<br>\n\n![](/files/int-floor-hint.png)\n\n<br>",
                                "hints": [],
                                "restrictions": [],
                                "order": 18,
                                "cost": 5,
                                "threshold": 95,
                                "likes": 15,
                                "dislikes": 4,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 14,
                                        "default": false,
                                        "keyword": "ceil",
                                        "message": "ceil function is not allowed in this task",
                                        "severity": 2
                                    },
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": false
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\n\nvec3 palette[5] = vec3[5] (\n  vec3(1.0, 0.0, 0.0),\n  vec3(0.0, 1.0, 0.0),\n  vec3(0.0, 0.0, 1.0),\n  vec3(1.0, 1.0, 0.0),\n  vec3(0.0, 0.0, 0.0)\n);\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\n\nvec3 palette[5] = vec3[5] (\n  vec3(1.0, 0.0, 0.0),\n  vec3(0.0, 1.0, 0.0),\n  vec3(0.0, 0.0, 1.0),\n  vec3(1.0, 1.0, 0.0),\n  vec3(0.0, 0.0, 0.0)\n);\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 25,
                        "slug": "distance-length",
                        "moduleId": 2,
                        "name": "Distance / Length",
                        "order": 19,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": 0,
                        "premium": false,
                        "child": {
                            "task": {
                                "id": 25,
                                "slug": "distance-length",
                                "moduleId": 2,
                                "name": "Distance / Length",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  float dist = distance(uv, vec2(0.5));\n  float t = 1.0 - step(0.25, dist);\n  \n  gl_FragColor = vec4(t, 0.0, 0.0, 1.0);\n}\n",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1,\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "### The length Function\n\n<br>\n\nThe `length` function in GLSL calculates the Euclidean length (magnitude) of a vector.\n\n#### Function Signature\n\n```\nfloat length(vec v)\n```\n\nIt takes a single argument, which is the vector for which you want to calculate the length. \n\n#### Example\n```\nvec3 vec = vec3(2.0, 4.0, 4.0);\nfloat vecLength = length(vec); // will be 6.0\n```\n\n### The distance Function\n\n<br>\n\nThe `distance` function in GLSL calculates the Euclidean distance between two points or vectors. \n\n#### Function Signature\n\n```\nfloat distance(vec p0, vec p1)\n```\n\nIt takes two arguments, which are the two points or vectors between which you want to calculate the distance. \n\n\n#### Example\n```\nvec3 p0 = vec3(1.0, 2.0, 2.0);\nvec3 p1 = vec3(4.0, 2.0, 6.0);\nfloat dist = distance(p0, p1); // will be 5.0\n```\n\n### Interchangeability\n\n<br>\n\nThe `length` and `distance` functions are interchangeable:\n\n```\nlength(p1 - p0) = distance(p0, p1)\n```\n\n### Task\nTry to fill pixels in red that are within `0.25` of the texture center in normalized coordinates.",
                                "hints": [],
                                "restrictions": [],
                                "order": 19,
                                "cost": 5,
                                "threshold": 95,
                                "likes": 4,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": false
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 26,
                        "slug": "aspect-ratio",
                        "moduleId": 2,
                        "name": "Aspect Ratio",
                        "order": 20,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": 0,
                        "premium": false,
                        "child": {
                            "task": {
                                "id": 26,
                                "slug": "aspect-ratio",
                                "moduleId": 2,
                                "name": "Aspect Ratio",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  vec2 ratio = vec2(iResolution.x / iResolution.y, 1.0);  \n  \n  float dist = distance(uv * ratio, vec2(0.5) * ratio);\n  float t = 1.0 - step(0.25, dist);\n  \n  gl_FragColor = vec4(t, 0.0, 0.0, 1.0);\n}",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1,\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "To avoid distortion when using texture coordinates, it is important to consider the aspect ratio of the texture. This can be achieved by calculating the ratio of its width to height:\n\n```\nratio = width / height\n```\n\n### Using Aspect Ratio to Adjust Object Size and Position\n\n<br>\n\nYou can adjust the object size and position using the aspect ratio:\n```\nx = x * ratio\nwidth = width * ratio\n```\nOr\n```\ny = y / ratio\nheight = height / ratio\n```\n\n### Choosing the Right Adjustment\n\n<br>\n\nThe decision to multiply the **X** by the aspect ratio or divide the **Y** by the aspect ratio depends on the orientation of the object being drawn and the desired outcome:\n\n<br>\n\n• **Landscape Orientation:** If the object is wider than it is tall, multiplying the **X** by the aspect ratio will stretch the object horizontally to fit the screen.\n\n\n• **Portrait Orientation:** If the object is taller than it is wide, dividing the **Y** position by the aspect ratio will stretch the object vertically to fit the screen.\n\n<br>\n\nUltimately, it depends on how you want the object to appear on different screen sizes and aspect ratios.\n\n### Task\nWrite a shader that draws a red circle in the center of the screen. The circle should have a radius of `0.25` times the height of the screen. For aspect ratio correction, adjust the circle's dimensions to account for landscape orientation.",
                                "hints": [],
                                "restrictions": [],
                                "order": 20,
                                "cost": 5,
                                "threshold": 95,
                                "likes": 6,
                                "dislikes": 1,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": false
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 31,
                        "slug": "atan",
                        "moduleId": 2,
                        "name": "Atan",
                        "order": 21,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": 0,
                        "premium": false,
                        "child": {
                            "task": {
                                "id": 31,
                                "slug": "atan",
                                "moduleId": 2,
                                "name": "Atan",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  vec2 center = vec2(0.5, 0.5);\n\n  vec2 ratio = vec2(iResolution.x / iResolution.y, 1.0);\n  uv *= ratio;\n  center *= ratio;\n  \n  float dist = distance(uv, center);\n  vec2 dir = (uv - center);\n  float angle = atan(dir.y, dir.x) / 3.14;\n  \n  vec3 color1 = vec3(1.0, 0.0, 0.0);\n  vec3 color2 = vec3(0.0, 1.0, 0.0);\n  \n  vec3 color = mix(color1, color2, abs(angle));\n\n  // Limit the gradient to a circular area\n  color -= step(0.5, dist);\n  \n  gl_FragColor = vec4(color, 1.0);\n}",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1,\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "In GLSL, the `atan(y, x)` function is used to calculate the angle in radians between the positive x-axis and the point `(x, y)` in a 2D Cartesian coordinate system. This function is commonly used in computer graphics and shader programming to determine the direction of a vector or to perform rotations based on the angle between two points.\n\n<br>\n\n### Function Signature\n```\nfloat atan(float y, float x);\n```\n\n### How It Works\n\n<br>\n\nThe `atan(y, x)` function computes the arctangent of `y/x` within the range `[-π, π]`. The resulting angle is positive if the point `(x, y)` is in the first or second quadrant, and negative if it is in the third or fourth quadrant (Image 1). This function handles the sign of `y` and `x` appropriately to determine the correct quadrant of the angle.\n\n<br>\n\n![Image 1 - Atan Circle](/files/atan2.png)\n\n<br>\n\n### Example\n\n<br>\n\nHere's an example of using `atan(y, x)` to rotate a 2D shape towards a target point:\n\n```\nfloat dx = targetX - positionX;\nfloat dy = targetY - positionY;\nfloat angle = atan(dy, dx); // Calculate angle for rotation\n```\n\n### Task\nCreate a gradient that transitions from red to green. The weight of each pixel should be determined by the angle between the center-to-pixel ray and the x-axis. Limit the gradient to a circular area with a diameter equal to the height of the texture.\n\n<br>\n\n### Notes\n\n<br>\n\nPerform all calculations after adjusting the coordinates for the aspect ratio.",
                                "hints": [],
                                "restrictions": [],
                                "order": 21,
                                "cost": 5,
                                "threshold": 90,
                                "likes": 16,
                                "dislikes": 9,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": false
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 30,
                        "slug": "sin",
                        "moduleId": 2,
                        "name": "Sin",
                        "order": 22,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": 0,
                        "premium": false,
                        "child": {
                            "task": {
                                "id": 30,
                                "slug": "sin",
                                "moduleId": 2,
                                "name": "Sin",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\n\nconst float PI = 3.14;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  vec2 ratio = vec2(iResolution.x / iResolution.y, 1.0);\n  vec2 center = vec2(0.5);\n  \n  float dist = distance(uv * ratio, center * ratio);\n  float red = sin(dist * PI * 2.0 * 5.0) * 0.5 + 0.5;\n  \n  gl_FragColor = vec4(red, 0.0, 0.0, 1.0);\n}",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\n\nconst float PI = 3.14;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1,\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "The `sin` function returns a numeric value from `-1.0` to `1.0` that represents the sine of the passed (in radians) angle.\n\n<br>\n\n### Function Signature\n```\nfloat sin(float angle);\n```\n\n### How It Works\n\n<br>\n\nThe sine function has a period of 2π, which means that it repeats itself every 2π units. By multiplying the sine argument by a factor of 2π, we can create a wave pattern.\n\n### Task\nCreate an image with a repeating pattern of red and black circles using `5` periods of sine and pixel-to-center distance. This will create a repeating pattern of peaks and troughs. Finally, bring the values of the sine to the interval from `0` to `1` and apply the red color to the circles based on that value. Use a value of `3.14` for π.",
                                "hints": [],
                                "restrictions": [],
                                "order": 22,
                                "cost": 5,
                                "threshold": 95,
                                "likes": 9,
                                "dislikes": 5,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": false
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\n\nconst float PI = 3.14;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\n\nconst float PI = 3.14;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 215,
                        "slug": "vector-normaliztion",
                        "moduleId": 2,
                        "name": "Vector Normaliztion",
                        "order": 23,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": 0,
                        "premium": false,
                        "child": {
                            "task": {
                                "id": 215,
                                "slug": "vector-normaliztion",
                                "moduleId": 2,
                                "name": "Vector Normaliztion",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  vec2 normal = normalize(uv - vec2(0.25, 0.5));\n  float t = (normal.x);\n\n  if (uv.x > 0.5) {\n    normal = normalize(uv - vec2(0.75, 0.5));\n    t = (normal.y);\n  }\n\n  gl_FragColor = vec4(t, t, t, 1.0);\n}",
                                "postProcessShader": "",
                                "properties": "",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}",
                                "defaultPostProcessShader": "",
                                "defaultProperties": "",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1,\"model\":null,\"meshes\":[{\"name\":\"main\",\"materialId\":0}],\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"materials\":[],\"actions\":[],\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250,\"customDepthBufferTexture\":false,\"glslVersion\":1}",
                                "description": "When working with vector values, we are often interested in the direction rather than the magnitude (length) of the vector. For example, when calculating lighting, we are interested in the direction of the illuminated surface's normal, the light rays, and the observer's view. In such cases, it is convenient to use unit vectors. A unit vector is a vector with a length of 1. It is also called a *normalized* vector.\n\n<br>\n\nFor any non-zero vector **V**, we can calculate a unit vector **N** that is directed the same way as vector **V**. This process is called vector *normalization*. To normalize a vector, we need to divide its components by its length:\n```\nN = V / length(V);\n```\nOr use the built-in `normalize` function:\n```\nN = normalize(V);\n```\nIn 2D, if we draw a unit vector with its tail at the origin, its head will lie on a circle with a radius of 1 centered at the origin:\n\n![](/files/vector-normalization-unit-circle.png)\n\nThus, the components of a normalized vector can be represented using trigonometric functions:\n```\nN = vec2(cos(𝜃), sin(𝜃))\n```\nwhere `𝜃` is the angle between the vector and the positive X-axis.\n\n\n### Task\nWrite a shader program that divides the screen into two equal parts. The origin of the left part is at `(0.25, 0.5)`, and the origin of the right part is at `(0.75, 0.5)`. In the left part, display the cosine of the angle between the positive X-axis and the vector directed from  the origin to the current pixel position. In the right part, display the sine of the angle between the positive X-axis and the vector directed from the origin to the current pixel position.",
                                "hints": [],
                                "restrictions": [],
                                "order": 23,
                                "cost": 5,
                                "threshold": 95,
                                "likes": 5,
                                "dislikes": 2,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": false
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}",
                            "postProcessShader": "",
                            "properties": "",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}",
                            "defaultPostProcessShader": "",
                            "defaultProperties": "",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 29,
                        "slug": "dot",
                        "moduleId": 2,
                        "name": "Dot",
                        "order": 24,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": 0,
                        "premium": false,
                        "child": {
                            "task": {
                                "id": 29,
                                "slug": "dot",
                                "moduleId": 2,
                                "name": "Dot",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  vec2 ratio = vec2(iResolution.x / iResolution.y, 1.0);\n\n  vec2 p0 = vec2(0.5, 0.75) * ratio; // apex\n  vec2 p1 = vec2(0.5, 0.0) * ratio;  // apex projection\n  vec2 p2 = uv * ratio;              // current point\n\n  vec2 dir1 = p1 - p0; // perpendicular to the base\n  vec2 dir2 = p2 - p0; // from apex to current point\n  \n  vec2 n1 = normalize(dir1);\n  vec2 n2 = normalize(dir2);\n\n  float t = dot(n1, n2);   // get cosine\n  float d = dot(n1, dir2); // get distance\n  \n  float red = step(0.5, t);    // check angle\n  red *= (1.0 - step(0.5, d)); // check distance\n\n  gl_FragColor = vec4(red, 0.0, 0.0, 1.0);\n}",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1,\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "The `dot` calculates the dot product of two vectors. it can be used to calculate the angle between two vectors or to project one vector onto another.\n\n```\nfloat dot(float x, float y)\nfloat dot(vec2 x, vec2 y)\nfloat dot(vec3 x, vec3 y)\nfloat dot(vec4 x, vec4 y)\n```\n\n### Algebraic definition \n\n<br>\n\nThe dot product of two vectors **v1** and **v2** is equal to the sum of the products of their corresponding components:\n\n```\nv1 * v2 = v1[0] * v2[0] + … + v1[n] * v2[n];\n```\n\n### Geometrical definition\n\n<br>\n\nThe dot product of two vectors **v1** and **v2** is equal to the product of their magnitudes and the cosine of the angle between them:\n\n```\nv1 * v2 = length(v1) * length(v2) * cos(angle between v1 and v2)\n```\n\nIn the case when both vectors are normalized (vector length is equal to 1), the dot product is equal to cosine of the angle between two vectors:\n\n```\nv1 * v2 = cos(angle between v1 and v2);\n```\n\n### Task\nWrite a program that draws a triangle in the center of the screen. The triangle should have an apex at `(0.5, 0.75)` in normalized device coordinates, and an apex angle of `120` degrees. The height of the triangle should be `0.5` times the height of the screen.\n\n<br>\n\n### Hint\n\n<br>\n\nFirst, we can shoot a ray **h** from the apex perpendicular to the base of the triangle. This **h** vector divides the top corner of the triange into two 60-degree parts. \n\n<br>\n\n![](/files/dot-task.png)\n\n<br>\n\nIf we take the dot product of the height vector **h** and the vector from apex to the triangle bottom vertex, we get a value equal to the cosine of 60 degrees. \n\n<br>\n\nThink what happens to the value of the dot product when the fragment fits into a triangle and when it doesn't.",
                                "hints": [],
                                "restrictions": [],
                                "order": 24,
                                "cost": 5,
                                "threshold": 95,
                                "likes": 11,
                                "dislikes": 8,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": false
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 32,
                        "slug": "clamp",
                        "moduleId": 2,
                        "name": "Clamp",
                        "order": 25,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": 0,
                        "premium": false,
                        "child": {
                            "task": {
                                "id": 32,
                                "slug": "clamp",
                                "moduleId": 2,
                                "name": "Clamp",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  float lineWidth = 0.2;\n  vec3  lineColor = vec3(1.0, 0.3, 0.3);\n  \n  float value = clamp(uv.x, 0.25, 0.75);\n  float dist  = abs(uv.y - value);\n  float line  = 1.0 - step(lineWidth * 0.5, dist);\n  \n  gl_FragColor = vec4(lineColor * line, 1.0);\n}",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  float lineWidth = 0.2;\n  vec3  lineColor = vec3(1.0, 0.3, 0.3);\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1,\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "In GLSL, the `clamp` function is used to restrict a value within a specified range. It ensures that the input value is not less than a minimum value and not greater than a maximum value. The `clamp` function is commonly used in shaders to limit the output of calculations to a specific range, preventing values from going out of bounds.\n\n<br>\n\n### Function Signature\n\n```\nfloat clamp(float value, float minVal, float maxVal)\n```\n\n### How It Works\n\n<br>\n\nThe `clamp` function takes two arguments: \n\n  - • **value**: The input value that you want to constrain within the specified range.\n  - • **minVal**: The minimum value that `value` should not go below.\n  - • **maxVal**: The maximum value that `value` should not exceed.\n\nThe function returns the clamped value of `value`, which is constrained between `minVal` and `maxVal`.\n\n<br>\n\n### Example\n\n```\nclamp(0.8, 0.0, 1.0);  // will be 0.8, since value is between 0.0 and 1.0\nclamp(-0.5, 0.0, 1.0); // will be 0.0, since value is less than 0.0\nclamp(1.5, 0.0, 1.0);  // will be 1.0, since value is greater than 1.0\n```\n\n### Task\nWrite a GLSL program that draws a diagonal line from the bottom left corner of the texture to the top right corner. The line should have a width of `0.2` in normalized coordinates and be colored in `(1.0, 0.3, 0.3)`. Additionally, ensure that the line is limited to values between `0.25` and `0.75` in Y coordinate.\n\n<br>\n\n### Requirements\n\n<br>\n\nThe shader should avoid using branching or conditional statements in its code.",
                                "hints": [],
                                "restrictions": [],
                                "order": 25,
                                "cost": 5,
                                "threshold": 99,
                                "likes": 5,
                                "dislikes": 4,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 40,
                                        "default": false,
                                        "keyword": "if",
                                        "message": "avoid using branching or conditional statements",
                                        "severity": 2
                                    },
                                    {
                                        "id": 41,
                                        "default": false,
                                        "keyword": "for",
                                        "message": "avoid using branching or conditional statements",
                                        "severity": 2
                                    },
                                    {
                                        "id": 42,
                                        "default": false,
                                        "keyword": "while",
                                        "message": "avoid using branching or conditional statements",
                                        "severity": 2
                                    },
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": false
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  float lineWidth = 0.2;\n  vec3  lineColor = vec3(1.0, 0.3, 0.3);\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  float lineWidth = 0.2;\n  vec3  lineColor = vec3(1.0, 0.3, 0.3);\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 39,
                        "slug": "texture",
                        "moduleId": 2,
                        "name": "Texture",
                        "order": 27,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": 0,
                        "premium": false,
                        "child": {
                            "task": {
                                "id": 39,
                                "slug": "texture",
                                "moduleId": 2,
                                "name": "Texture",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\nuniform sampler2D iChannel0;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  vec2 ratio = vec2(iResolution.x / iResolution.y, 1.0);  \n\n  gl_FragColor = texture(iChannel0, fract(uv * ratio));\n}",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\nuniform sampler2D iChannel0;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1,\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "On the CPU side, we can tell the GPU which texture we want to execute our shader program with. To access the texture that is attached to a shader program, you need declare a `uniform` of `sampler2D` type:\n\n```\nuniform sampler2D <Name>\n```\n\nTo sample the color of the texture, use the built-in `texture` function that takes a `sampler2D` as its first argument and the corresponding texture coordinates as its second argument:\n\n```\nvec4 color = texture(<Name>, texCoord);\n```\n\n**Texture coordinates** range from `(0, 0)` for the lower left corner of the texture image to `(1, 1)` for the upper right corner of the texture image.\n\n<br>\n\n![Image 1 - Texture Coordinates](/files/texture-coordinates-tex-coords.png)\n\n\n### Task\nWrite a shader program that displays a texture on the screen. The texture is attached to the shader program through `iChannel0`. The texture may have a different aspect ratio than the scene, so if the coordinates go beyond `(0, 1)`, repeat the contents of the texture.",
                                "hints": [],
                                "restrictions": [],
                                "order": 27,
                                "cost": 5,
                                "threshold": 95,
                                "likes": 6,
                                "dislikes": 1,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [
                                    {
                                        "index": 0
                                    }
                                ],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": false
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\nuniform sampler2D iChannel0;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\nuniform sampler2D iChannel0;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 163,
                        "slug": "texture-mirror",
                        "moduleId": 2,
                        "name": "Texture Mirror",
                        "order": 28,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": 0,
                        "premium": false,
                        "child": {
                            "task": {
                                "id": 163,
                                "slug": "texture-mirror",
                                "moduleId": 2,
                                "name": "Texture Mirror",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\nuniform sampler2D iChannel0;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy * 4.0;\n  uv *= vec2(iResolution.x / iResolution.y, 1.0);  \n\n  float tx = fract(uv.x);\n  float ty = fract(uv.y);\n\n  tx = mix(tx, 1.0 - tx, step(1.0, mod(uv.x, 2.0)));\n  ty = mix(ty, 1.0 - ty, step(1.0, mod(uv.y, 2.0)));\n  \n  gl_FragColor = texture(iChannel0, vec2(tx, ty));\n}",
                                "postProcessShader": "",
                                "properties": "",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\nuniform sampler2D iChannel0;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy * 4.0;\n  uv *= vec2(iResolution.x / iResolution.y, 1.0);  \n  \n  gl_FragColor = texture(iChannel0, uv);\n}",
                                "defaultPostProcessShader": "",
                                "defaultProperties": "",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1,\"model\":null,\"meshes\":[{\"name\":\"main\",\"materialId\":0}],\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"materials\":[],\"actions\":[],\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250,\"customDepthBufferTexture\":false,\"glslVersion\":1}",
                                "description": "We know that an image will appear on the surface where `(u, v)` are in the `[0, 1]` range. But\nwhat happens outside of this range? **Texture Wrapping** functions determine the behavior.\n\n<br>\n\nIn the previous task, we implemented the **repeat** wrapping - the image repeats itself across the surface; algorithmically, the integer part of the texture coordinates is dropped. This function is useful for having an image of a material repeatedly cover a surface.\n\n<br>\n\n**Mirrored Repeat** - the image repeats itself across the surface, but is mirrored (flipped) on every other repetition. For example, the image appears normally going from 0 to 1, then is reversed between 1 and 2, then is normal between 2 and 3, then is reversed, and so on.\n\n### Task\nWrite a shader program that displays a texture on the screen. The texture is attached to the shader program through `iChannel0`. Ensure that texture coordinates are correctly handled when they extend beyond the `(0, 1)` range. Consider using *mirrored repeat* texture wrapping behavior.",
                                "hints": [],
                                "restrictions": [],
                                "order": 28,
                                "cost": 5,
                                "threshold": 98,
                                "likes": 5,
                                "dislikes": 4,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [
                                    {
                                        "index": 0
                                    }
                                ],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": false
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\nuniform sampler2D iChannel0;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy * 4.0;\n  uv *= vec2(iResolution.x / iResolution.y, 1.0);  \n  \n  gl_FragColor = texture(iChannel0, uv);\n}",
                            "postProcessShader": "",
                            "properties": "",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\nuniform sampler2D iChannel0;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy * 4.0;\n  uv *= vec2(iResolution.x / iResolution.y, 1.0);  \n  \n  gl_FragColor = texture(iChannel0, uv);\n}",
                            "defaultPostProcessShader": "",
                            "defaultProperties": "",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 55,
                        "slug": "time",
                        "moduleId": 2,
                        "name": "Time",
                        "order": 29,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": 0,
                        "premium": false,
                        "child": {
                            "task": {
                                "id": 55,
                                "slug": "time",
                                "moduleId": 2,
                                "name": "Time",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\nuniform sampler2D iChannel0;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  float t = sin(iTime * 2.0) * 0.5 + 0.5;\n  float delta = 0.375 * t * step(0.3, uv.y);\n  uv.y = clamp(uv.y + delta, 0.0, 1.0);\n  \n  vec4 color = texture(iChannel0, uv);\n  \n  gl_FragColor = color;\n}",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\nuniform sampler2D iChannel0;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1,\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "The `iTime` uniform in the fragment shader provides the current time in seconds since the start of the application, which can be used to control the timing and speed of animations. By adjusting the time multiplier, the speed of the animation can be increased or decreased to achieve the desired effect.\n\n<br>\n\nHere are some examples of how it can be used:\n\n1. **Color animation.** By using the `iTime` uniform to control the color of an object, you can create a pulsating or fading effect. For example, you could use `iTime` to smoothly transition between two colors over a set period of time.\n\n\n2. **Texture animation.** You can use `iTime` to animate the texture coordinates of a texture, creating a scrolling or waving effect. This can be useful for creating water or fire effects.\n\n3. **Distortion effects.** By using `iTime` to control the distortion of an image or texture, you can create a wavy or rippling effect. This can be useful for creating heat distortion or underwater effects.\n\nOverall, the `iTime` uniform in a fragment shader provides a powerful tool for creating dynamic and visually appealing animations and effects.\n\n### Task\nAnimate the attached character's mouth to smoothly open and close using the `iTime` uniform in the shader. The upper jaw should start opening at a Y coordinate of `0.3` in normalized device coordinates and reach its maximum opening at `0.675`. Remember to adjust the time multiplier to `2` to control the speed of the animation.\n\n<br>\n\n**Note:** consider using the `sin` or `cos` function over `iTime` to loop the animation.",
                                "hints": [],
                                "restrictions": [],
                                "order": 29,
                                "cost": 5,
                                "threshold": 95,
                                "likes": 10,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [
                                    {
                                        "index": 0
                                    }
                                ],
                                "animated": true,
                                "animationSteps": 5,
                                "animationStepTime": 1000,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": false
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\nuniform sampler2D iChannel0;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\nuniform sampler2D iChannel0;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 156,
                        "slug": "sprite-animation",
                        "moduleId": 2,
                        "name": "Sprite Animation",
                        "order": 30,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": 0,
                        "premium": false,
                        "child": {
                            "task": {
                                "id": 156,
                                "slug": "sprite-animation",
                                "moduleId": 2,
                                "name": "Sprite Animation",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\nuniform sampler2D iChannel0;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  float frame = mod(floor(iTime / 0.1), 8.0);\n  float x = mod(frame, 2.0);\n  float y = mod(floor(frame / 2.0), 4.0);\n  \n  vec4 color = texture(iChannel0, (uv + vec2(x, y)) * vec2(0.5, 0.25));\n  \n  gl_FragColor = color;\n}\n",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1,\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "**Sprite animation** is a technique used in computer graphics and game development to create the illusion of movement by rapidly displaying a sequence of images or frames. Each image, known as a sprite, represents a different state or pose of an object or character. By displaying these sprites in quick succession, the object appears to be animated.\n\n<br>\n\n### Implementing Sprite Animation\n\n<br>\n\nTo implement sprite animation using a single texture, a sprite sheet is typically used (Image 1). A sprite sheet is a single image file that contains multiple frames of animation arranged in a grid-like pattern. Each frame corresponds to a different sprite, and by selecting the appropriate portion of the texture for each frame, the animation can be played back.\n\n<br>\n\n![Image 1 - Sprite Sheet](/files/sprite-animation.png)\n\n### Task\nYou are provided with a texture containing a sprite sheet with `2` columns and `4` rows of images. Write a GLSL program that implements animation using the sprite sheet based on time with a frame rate of `10` frames per second.\n\n<br>\n\nThe `iTime` uniform provides the current time in seconds.\n\n",
                                "hints": [],
                                "restrictions": [],
                                "order": 30,
                                "cost": 5,
                                "threshold": 98,
                                "likes": 8,
                                "dislikes": 1,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [
                                    {
                                        "index": 0
                                    }
                                ],
                                "animated": true,
                                "animationSteps": 11,
                                "animationStepTime": 80,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": false
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 157,
                        "slug": "radial-shutter-animation",
                        "moduleId": 2,
                        "name": "Radial Shutter Animation",
                        "order": 31,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": 0,
                        "premium": false,
                        "child": {
                            "task": {
                                "id": 157,
                                "slug": "radial-shutter-animation",
                                "moduleId": 2,
                                "name": "Radial Shutter Animation",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nuniform sampler2D iChannel0;\nuniform sampler2D iChannel1;\n\nconst float PI = 3.141592653589;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  vec2 ratio = vec2(iResolution.x / iResolution.y, 1.0);  \n\n  float radius = length(ratio * 0.5);\n  radius *= sin(iTime + PI / 2.0) * 0.5 + 0.5;\n\n  float circle = distance(uv * ratio, vec2(0.5, 0.5) * ratio) - radius;\n  float t = 1.0 - step(0.0, circle);\n\n  vec4 tex0 = texture2D(iChannel0, uv);\n  vec4 tex1 = texture2D(iChannel1, uv);\n\n  float idx = mod(floor((iTime + PI) / (PI * 2.0)), 2.0);\n  vec4 color = mix(tex0, tex1, idx);\n\n  gl_FragColor = vec4(color.rgb * t, 1.0);\n}\n",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nconst float PI = 3.141592653589;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"object\":{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1},\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "To fit a rectangle into a circle, the diagonal of the rectangle must be equal to the diameter of the circle (two radii).\n\n<br>\n\n![](/files/radial-shutter-animation.png)\n\n<br>\n\nIf you have the dimensions of the rectangle's sides **w** and **h**, the radius of the circle **R** can be found by the Pythagorean theorem.\n\n### Task\nYou are provided with two texture slides. Write a GLSL program that switches textures using a radial shutter animation. Use sine or cosine to loop the animation, the total switching time is 2PI seconds.\n\n<br>\n\nRadial shutter should work with any aspect ratio.\n\n<br>\n\nThe `iTime` uniform provides the current time in seconds.",
                                "hints": [],
                                "restrictions": [],
                                "order": 31,
                                "cost": 5,
                                "threshold": 99,
                                "likes": 1,
                                "dislikes": 3,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [
                                    {
                                        "index": 0
                                    },
                                    {
                                        "index": 1
                                    }
                                ],
                                "animated": true,
                                "animationSteps": 10,
                                "animationStepTime": 628,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": false
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nconst float PI = 3.141592653589;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nconst float PI = 3.141592653589;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 40,
                        "slug": "dfdx-dfdy",
                        "moduleId": 2,
                        "name": "dFdx / dFdy",
                        "order": 32,
                        "cost": 10,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": 0,
                        "premium": false,
                        "child": {
                            "task": {
                                "id": 40,
                                "slug": "dfdx-dfdy",
                                "moduleId": 2,
                                "name": "dFdx / dFdy",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\nuniform sampler2D iChannel0;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  vec4 texel = texture(iChannel0, uv);\n  float luminance = dot(texel.rgb, vec3(0.2126, 0.7152, 0.0722));\n\n  float dx = dFdx(luminance);\n  float dy = dFdy(luminance);\n  float t  = abs(dx) + abs(dy);\n\n  texel = mix(texel, vec4(1.0, 0.0, 0.0, 1.0), t > 0.0 ? 1.0 : 0.0);\n  \n  gl_FragColor = texel;\n}",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\nuniform sampler2D iChannel0;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1,\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "When a fragment program is run, the fragments are arranged into quads - 2x2 squares of 4 pixels that always run together in a thread group (Image - 1). Each thread in the group knows its own pixel coordinate, and can easily find the coordinate of the adjacent pixel in the quad.\n\n<br>\n\n![Image 1 - Quads](/files/df-quads.png)\n\n<br>\n\n### Derivative Functions\n\n#### dFdx Instruction\n\nWhen the GPU executes `dFdx` instruction, it peeks the value of adjacent pixel along the x-axis and does a subtract with the value from the current pixel.\n\n```\nfloat ddxValue = dFdx(variable);\n```\n\n#### dFdy Instruction\n\nWhen the GPU executes `dFdy` instruction, it peeks the value of adjacent pixel along the y-axis and does a subtract with the value from the current pixel.\n\n```\nfloat ddyValue = dFdy(variable);\n```\n\n### Examples\n```\ndFdx(gl_FragCoord.x) // will be 1\ndFdx(gl_FragCoord.y) // will be 0\n\ndFdy(gl_FragCoord.y) // will be 1\ndFdy(gl_FragCoord.x) // will be 0\n```\n\n### Task\nCreate a shader that generates a red outline around the tree in a given picture with a transparent background. To achieve this, you will need to use the `dFdx` and `dFdy` functions, as well as calculate the *luminance* of the image.\n\n<br>\n\nTo calculate the *luminance*, use the following formula:\n```\nL = R * 0.2126 + G * 0.7152 + B * 0.0722;\n```",
                                "hints": [],
                                "restrictions": [],
                                "order": 32,
                                "cost": 10,
                                "threshold": 99,
                                "likes": 10,
                                "dislikes": 3,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [
                                    {
                                        "index": 0
                                    }
                                ],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": false
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\nuniform sampler2D iChannel0;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\nuniform sampler2D iChannel0;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 124,
                        "slug": "cross",
                        "moduleId": 2,
                        "name": "Cross",
                        "order": 33,
                        "cost": 10,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": 0,
                        "premium": false,
                        "child": {
                            "task": {
                                "id": 124,
                                "slug": "cross",
                                "moduleId": 2,
                                "name": "Cross",
                                "vertexShader": "uniform float iTime;\n\nvarying vec3 vPos;\n\nvoid setPosition3D(mat3 transform) {\n  vec3 pos = transform * position.xyz;\n  vPos = pos;\n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n\nvoid main() {\n  float angleX = 0.1;\n  float angleY = -iTime;\n  float angleZ = iTime * 0.5;\n  \n  mat3 rotateX = transpose(mat3(\n    vec3(1, 0, 0),\n    vec3(0, cos(angleX), -sin(angleX)),\n    vec3(0, sin(angleX), cos(angleX))\n  ));\n\n  mat3 rotateY = transpose(mat3(\n    vec3(cos(angleY), 0, sin(angleY)),\n    vec3(0, 1, 0),\n    vec3(-sin(angleY), 0, cos(angleY))\n  ));\n\n  mat3 rotateZ = transpose(mat3(\n    vec3(cos(angleZ), -sin(angleZ), 0),\n    vec3(sin(angleZ), cos(angleZ), 0),\n    vec3(0, 0, 1)\n  ));\n\n  setPosition3D(rotateZ * rotateY * rotateX);\n}\n",
                                "fragmentShader": "varying vec3 vPos;\n\nconst vec3 lightPos = vec3(0.0, 1.0, 3.0);\n\nvoid main() {\n  vec3 dx = dFdx(vPos);\n  vec3 dy = dFdy(vPos);\n  vec3 normal = normalize(cross(dx, dy));\n\n  vec3 lightDir = normalize(lightPos - vPos);\n  float t = dot(normal, lightDir);\n  \n  gl_FragColor = vec4(vec3(0.0, 0.55, 0.55) * t, 1.0);\n}\n",
                                "defaultVertexShader": "uniform float iTime;\n\nvarying vec3 vPos;\n\nvoid setPosition3D(mat3 transform) {\n  vec3 pos = transform * position.xyz;\n  vPos = pos;\n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n\nvoid main() {\n  float angleX = 0.1;\n  float angleY = -iTime;\n  float angleZ = iTime * 0.5;\n  \n  mat3 rotateX = transpose(mat3(\n    vec3(1, 0, 0),\n    vec3(0, cos(angleX), -sin(angleX)),\n    vec3(0, sin(angleX), cos(angleX))\n  ));\n\n  mat3 rotateY = transpose(mat3(\n    vec3(cos(angleY), 0, sin(angleY)),\n    vec3(0, 1, 0),\n    vec3(-sin(angleY), 0, cos(angleY))\n  ));\n\n  mat3 rotateZ = transpose(mat3(\n    vec3(cos(angleZ), -sin(angleZ), 0),\n    vec3(sin(angleZ), cos(angleZ), 0),\n    vec3(0, 0, 1)\n  ));\n\n  setPosition3D(rotateZ * rotateY * rotateX);\n}\n",
                                "defaultFragmentShader": "varying vec3 vPos;\n\nconst vec3 lightPos = vec3(0.0, 1.0, 3.0);\n\nvoid main() {\n  gl_FragColor = vec4(vec3(0.0, 0.55, 0.55), 1.0);\n}\n",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":\"0\",\"y\":\"0\",\"z\":\"2.5\"},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":\"45\",\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":\"2\",\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"backgroundRGBA\":\"EEEEEE\",\"background\":15658734}",
                                "description": "The cross product is a mathematical operation that takes two vectors as input and produces a new vector that is perpendicular to the plane formed by the original two vectors. \n\n<br>\n\n### Calculating the Cross Product in 3D Space\n\n<br>\n\nIn 3D space, if you have two vectors `A = (ax, ay, az)` and `B = (bx, by, bz)`, the cross product `AxB` is calculated as:\n\n```\n        | i,   j,   k  |\nA x B = | ax,  ay,  az |\n        | bz,  by,  bz |\n\nA x B = i(ay*bz - az*by) - j(az*bx - ax*bz) + k(ax*by - ay*bx)\n```\n\nThe resulting vector is orthogonal to both `A` and `B`. \n\n<br>\n\n### Determining the Direction\n\n<br>\n\nThe direction of the resulting vector can be determined using the right-hand rule: if you put the index of your right hand on `A` and the middle finger on `B` , then the thumb points in the direction of `AxB`.\n\n<br>\n\n![Image 1 - Cross Product](/files/cross.png)\n\n<br>\n\n### Task\nImplement a shading effect on the cube object based on the cosine of the angle between the normal vector **N** of each object fragment and the direction vector **L** from the fragment to the light source, which is located at coordinates `(0.0, 1.0, 3.0)`.\n\n<br>\n\n![](/files/diffuse-lighting.png)\n\n<br>\n\nTo calculate the fragment normal **N**, use the `dFdx` and `dFdy` functions that you learned in the previous task, along with the new `cross` function.\n\n<br>\n\n**Note:** The fragment position is stored in the `vPos` variable.",
                                "hints": [],
                                "restrictions": [],
                                "order": 33,
                                "cost": 10,
                                "threshold": 98,
                                "likes": 8,
                                "dislikes": 2,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": true,
                                "animationSteps": 6,
                                "animationStepTime": 1000,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": false
                            },
                            "vertexShader": "uniform float iTime;\n\nvarying vec3 vPos;\n\nvoid setPosition3D(mat3 transform) {\n  vec3 pos = transform * position.xyz;\n  vPos = pos;\n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n\nvoid main() {\n  float angleX = 0.1;\n  float angleY = -iTime;\n  float angleZ = iTime * 0.5;\n  \n  mat3 rotateX = transpose(mat3(\n    vec3(1, 0, 0),\n    vec3(0, cos(angleX), -sin(angleX)),\n    vec3(0, sin(angleX), cos(angleX))\n  ));\n\n  mat3 rotateY = transpose(mat3(\n    vec3(cos(angleY), 0, sin(angleY)),\n    vec3(0, 1, 0),\n    vec3(-sin(angleY), 0, cos(angleY))\n  ));\n\n  mat3 rotateZ = transpose(mat3(\n    vec3(cos(angleZ), -sin(angleZ), 0),\n    vec3(sin(angleZ), cos(angleZ), 0),\n    vec3(0, 0, 1)\n  ));\n\n  setPosition3D(rotateZ * rotateY * rotateX);\n}\n",
                            "fragmentShader": "varying vec3 vPos;\n\nconst vec3 lightPos = vec3(0.0, 1.0, 3.0);\n\nvoid main() {\n  gl_FragColor = vec4(vec3(0.0, 0.55, 0.55), 1.0);\n}\n",
                            "defaultVertexShader": "uniform float iTime;\n\nvarying vec3 vPos;\n\nvoid setPosition3D(mat3 transform) {\n  vec3 pos = transform * position.xyz;\n  vPos = pos;\n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n\nvoid main() {\n  float angleX = 0.1;\n  float angleY = -iTime;\n  float angleZ = iTime * 0.5;\n  \n  mat3 rotateX = transpose(mat3(\n    vec3(1, 0, 0),\n    vec3(0, cos(angleX), -sin(angleX)),\n    vec3(0, sin(angleX), cos(angleX))\n  ));\n\n  mat3 rotateY = transpose(mat3(\n    vec3(cos(angleY), 0, sin(angleY)),\n    vec3(0, 1, 0),\n    vec3(-sin(angleY), 0, cos(angleY))\n  ));\n\n  mat3 rotateZ = transpose(mat3(\n    vec3(cos(angleZ), -sin(angleZ), 0),\n    vec3(sin(angleZ), cos(angleZ), 0),\n    vec3(0, 0, 1)\n  ));\n\n  setPosition3D(rotateZ * rotateY * rotateX);\n}\n",
                            "defaultFragmentShader": "varying vec3 vPos;\n\nconst vec3 lightPos = vec3(0.0, 1.0, 3.0);\n\nvoid main() {\n  gl_FragColor = vec4(vec3(0.0, 0.55, 0.55), 1.0);\n}\n",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    }
                ],
                "cover": true,
                "pageHeaderImage": true,
                "fullDesc": "This module is designed for beginner developers who want to learn the basics of fragment shaders and basic built-in GLSL functions. During the course, you will learn how fragment shaders work and how to use basic GLSL functions to create visual effects. Each topic is accompanied by theoretical material and a practical task that can be completed directly on the website.",
                "skillsDesc": "what a fragment shader is, how they work, and why they are needed.<br>basic GLSL functions in practice and how they can be used to create visual effects.<br>how to create animated effects using time.<br>the basics of working with textures.",
                "importanceDesc": "Fragment shaders and GLSL functions are fundamental for creating graphical effects in computer games, animation, and other visual applications. Understanding these technologies allows developers to create diverse visual effects, optimize the performance of graphical applications, and expand their skills in computer graphics.",
                "certifiable": true,
                "images": [
                    "img-1.png",
                    "img-3.png",
                    "img-4.png",
                    "img-5.png",
                    "img-6.png",
                    "img-7.png"
                ]
            }
        },
        {
            "id": 7,
            "slug": "image-manipulation-with-shaders",
            "name": "Image Manipulation with Shaders",
            "description": "Learn various techniques for manipulating 2D images, treated as textures, using the capabilities provided by fragment shaders.",
            "tasks": 12,
            "acceptedTasks": 0,
            "isOpen": false,
            "order": 1,
            "locked": false,
            "cover": true,
            "child": {
                "id": 7,
                "slug": "image-manipulation-with-shaders",
                "name": "Image Manipulation with Shaders",
                "description": "Learn various techniques for manipulating 2D images, treated as textures, using the capabilities provided by fragment shaders.",
                "order": 1,
                "createdBy": {
                    "id": 3,
                    "name": "Alexander"
                },
                "locked": false,
                "tasks": [
                    {
                        "id": 47,
                        "slug": "tint",
                        "moduleId": 7,
                        "name": "Tint",
                        "order": 0,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": 0,
                        "premium": false,
                        "child": {
                            "task": {
                                "id": 47,
                                "slug": "tint",
                                "moduleId": 7,
                                "name": "Tint",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\nuniform sampler2D iChannel0;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  vec3 tintColor = vec3(1.0, 1.0, 0.0);\n  vec3 texColor = texture(iChannel0, uv).rgb;\n\n  gl_FragColor = vec4(texColor * tintColor, 1.0);\n}",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\nuniform sampler2D iChannel0;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1,\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "To apply a **tint** to an image, we can use color multiplication. This involves multiplying each texel (pixel color) of the image by the tint color vector:\n\n```\nresult = fragColor * tintColor;\n```\n\nTint can be used to change the appearance of an object dynamically, such as changing the color of a character’s outfit or the hue of a scene based on time of day.\n\n### Task\nCreate a shader program that will tint the original image with a shade of yellow.\n\n<br>\n\nHere you can recall how to access the texture that is attached to a shader program: [texture](https://shader-learning.com/module-training/2/task/39)",
                                "hints": [],
                                "restrictions": [],
                                "order": 0,
                                "cost": 5,
                                "threshold": 95,
                                "likes": 2,
                                "dislikes": 4,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [
                                    {
                                        "index": 0
                                    }
                                ],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": false
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\nuniform sampler2D iChannel0;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\nuniform sampler2D iChannel0;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 175,
                        "slug": "color-negative",
                        "moduleId": 7,
                        "name": "Color Negative",
                        "order": 1,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": true,
                        "premiumLock": 0,
                        "premium": false,
                        "child": {
                            "task": {
                                "id": 175,
                                "slug": "color-negative",
                                "moduleId": 7,
                                "name": "Color Negative",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\nuniform sampler2D iChannel0;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  vec3 texColor = texture(iChannel0, uv).rgb;\n  vec3 negative = vec3(1.0) - texColor;\n\n  gl_FragColor = vec4(negative, 1.0);\n}",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\nuniform sampler2D iChannel0;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1,\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "**Color Negative** is an effect that inverts the colors of an image, producing a «negative»‎ version of the original. This effect is commonly used in photography and image processing to create visually striking results. In shader programming, the negative of an image is computed by subtracting the\ncolor of each pixel from white:\n\n```\nnegative = vec3(1.0, 1.0, 1.0) - fragColor;\n```\n\nColour negatives can be used to create unique and artistic images. For example, to convey memories, dreams, or other unusual states.\n\n### Task\nCreate a shader program that inverts the colors of the original image.\n\n<br>\n\nHere you can recall how to access the texture that is attached to a shader program: [texture](https://shader-learning.com/module-training/2/task/39)",
                                "hints": [],
                                "restrictions": [],
                                "order": 1,
                                "cost": 5,
                                "threshold": 95,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [
                                    {
                                        "index": 0
                                    }
                                ],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": false
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\nuniform sampler2D iChannel0;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\nuniform sampler2D iChannel0;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 48,
                        "slug": "brightness",
                        "moduleId": 7,
                        "name": "Brightness",
                        "order": 2,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": true,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 48,
                                "slug": "brightness",
                                "moduleId": 7,
                                "name": "Brightness",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\nuniform sampler2D iChannel0;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  vec3 texColor = texture(iChannel0, uv).rgb;\n  texColor.rgb = mix(vec3(0.0), texColor.rgb, 4.0);\n\n  gl_FragColor = vec4(texColor, 1.0);\n}",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\nuniform sampler2D iChannel0;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  vec3 texColor = texture(iChannel0, uv).rgb;\n\n  gl_FragColor = vec4(texColor, 1.0);\n}\n",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1,\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "**Brightness** indicates the degree of lightness or darkness of a color, in relation to its closeness to white. Lower values result in darker colors, while higher values result in lighter ones. The minimum and maximum values of 0% and 100%, respectively, correspond to black and white:\n\n```\nbrightness = distance(color, vec3(0.0));\n```\n\nBy selectively increasing the brightness of dark areas or decreasing the brightness of overlighted areas, you can reveal hidden details and improve the visibility of the image areas.\n\n### Task\nCreate a shader programme that increases the brightness of an image by `4` times.\n\n<br>\n\nNote that after increasing the brightness, the dark parts of the image become more clearly visible. For example, previously the mountains, fence and plants behind the road were not visible.\n",
                                "hints": [],
                                "restrictions": [],
                                "order": 2,
                                "cost": 5,
                                "threshold": 95,
                                "likes": 1,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [
                                    {
                                        "index": 0
                                    }
                                ],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\nuniform sampler2D iChannel0;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  vec3 texColor = texture(iChannel0, uv).rgb;\n\n  gl_FragColor = vec4(texColor, 1.0);\n}\n",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\nuniform sampler2D iChannel0;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  vec3 texColor = texture(iChannel0, uv).rgb;\n\n  gl_FragColor = vec4(texColor, 1.0);\n}\n",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 49,
                        "slug": "relative-luminance",
                        "moduleId": 7,
                        "name": "Relative Luminance",
                        "order": 3,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": true,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 49,
                                "slug": "relative-luminance",
                                "moduleId": 7,
                                "name": "Relative Luminance",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\nuniform sampler2D iChannel0;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  vec3 color = texture(iChannel0, uv).rgb;\n  float luminance = dot(color, vec3(0.2126, 0.7152, 0.0722));\n\n  gl_FragColor = vec4(vec3(luminance), 1.0);\n}",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1,\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "**Relative luminance** is a measure of the amount of light, taking into account the spectral weighting for human vision. Its values range from `0.0` to `1.0`. To calculate relative luminance, use the following formula based on the linear RGB components of each pixel:\n\n```\nL = R * 0.2126 + G * 0.7152 + B * 0.0722;\n```\n\nGreen light is the major component of luminance, responsible for the majority of light perceived by humans, while blue light is the smallest component. Note that the sum of these coefficients is `1.0000`, so the equation gives a value between `0.0` and `1.0`.\n\n<br>\n\nLuminance plays an important role in various image manipulation techniques, including grayscale conversion. To convert an image to grayscale, you replace each pixel's color with its luminance value.\n\n### Task\nWrite a shader program that converts an image to grayscale using relative luminance.",
                                "hints": [],
                                "restrictions": [],
                                "order": 3,
                                "cost": 5,
                                "threshold": 95,
                                "likes": 1,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [
                                    {
                                        "index": 0
                                    }
                                ],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 120,
                        "slug": "tone",
                        "moduleId": 7,
                        "name": "Tone",
                        "order": 4,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": true,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 120,
                                "slug": "tone",
                                "moduleId": 7,
                                "name": "Tone",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\nuniform sampler2D iChannel0;\n\nconst vec3 refColor = vec3(1.0, 0.84, 0.0) * 1.5;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  vec4 texel = texture(iChannel0, uv);\n  float luminance = dot(texel.rgb, vec3(0.2126, 0.7152, 0.0722));\n\n  gl_FragColor = vec4(refColor * luminance, texel.a);\n}",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\n\nconst vec3 refColor = vec3(1.0, 0.84, 0.0) * 1.5;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1,\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "The color tone of an image refers to the overall color cast or hue that is present in the image. \n\n<br>\n\nOne way to change the color tone of an image is by using color luminance:\n1. calculate the luminance value for each pixel in the image.\n2. multiply the reference tone color by luminance value to apply the effect.\n\n<br>\n\nAdditionally, by altering the brightness or intensity of colors, we can create a wide range of effects, from warm and inviting to cool and moody. \n\n<br>\n\nIn games, you can use this technique to visually alter the material of an object shown in a texture. For instance, imagine a single greyscale texture representing a medal. By adjusting the tonality, you can make it look like copper, silver, or gold. This allows for dynamic material changes without needing multiple textures.\n \n### Task\nCreate a shader program that changes the color tone of the image to gold.",
                                "hints": [],
                                "restrictions": [],
                                "order": 4,
                                "cost": 5,
                                "threshold": 95,
                                "likes": 4,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [
                                    {
                                        "index": 0
                                    }
                                ],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\n\nconst vec3 refColor = vec3(1.0, 0.84, 0.0) * 1.5;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\n\nconst vec3 refColor = vec3(1.0, 0.84, 0.0) * 1.5;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 50,
                        "slug": "saturation",
                        "moduleId": 7,
                        "name": "Saturation",
                        "order": 5,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": true,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 50,
                                "slug": "saturation",
                                "moduleId": 7,
                                "name": "Saturation",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\nuniform sampler2D iChannel0;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  vec3 color = texture(iChannel0, uv).rgb;\n  float luminance = dot(color, vec3(0.2126, 0.7152, 0.0722));\n  color = mix(vec3(luminance), color, 5.0);\n\n  gl_FragColor = vec4(color, 1.0);\n}",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1,\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "Color saturation is the intensity of a color, measured as a percentage from 0% to 100%. It specifies how far a color is from a gray of the same luminance. As the saturation increases, the colors appear more pure and vivid, while decreasing saturation makes colors appear more pale.\n\n<br>\n\n![Image 1 - Saturation](/files/saturation.png)\n\n<br>\n\nTo decrease the image saturation, move each pixel's color towards the relative luminance value. To increase the image saturation, move each pixel's color in the opposite direction of the relative luminance value.\n\n<br>\n\n![Image 2 - Saturation Direction](/files/saturation-direction.png)\n\n<br>\n\n### Task\nCreate a shader program that increases the saturation of an image by `5` times.",
                                "hints": [],
                                "restrictions": [],
                                "order": 5,
                                "cost": 5,
                                "threshold": 95,
                                "likes": 2,
                                "dislikes": 1,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [
                                    {
                                        "index": 0
                                    }
                                ],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 51,
                        "slug": "contrast",
                        "moduleId": 7,
                        "name": "Contrast",
                        "order": 6,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": true,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 51,
                                "slug": "contrast",
                                "moduleId": 7,
                                "name": "Contrast",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\nuniform sampler2D iChannel0;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  vec3 midPoint = vec3(0.5);\n  vec3 color = texture(iChannel0, uv).rgb;\n  float contrast = 2.0;\n  color = (color - midPoint) * contrast + midPoint;\n  color = clamp(color, 0.0, 1.0);\n\n  gl_FragColor = vec4(color, 1.0);\n}\n",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1,\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "**Contrast** is the measure of the difference between the darkest and lightest parts of an image. It is achieved by pushing the pixel colors away from the midpoint, making the dark parts darker and the bright parts lighter:\n\n```\ncolor = (color - midpoint) * contrast + midpoint\n```\n\n### Task\nCreate a shader program that increases the contrast of the image by `2` times.\n\n```\nmidPoint = (0.5, 0.5, 0.5);\n```",
                                "hints": [],
                                "restrictions": [],
                                "order": 6,
                                "cost": 5,
                                "threshold": 95,
                                "likes": 3,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [
                                    {
                                        "index": 0
                                    }
                                ],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 52,
                        "slug": "color-distance",
                        "moduleId": 7,
                        "name": "Color Distance",
                        "order": 7,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": true,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 52,
                                "slug": "color-distance",
                                "moduleId": 7,
                                "name": "Color Distance",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\nuniform sampler2D iChannel0;\n\nconst vec3 refColor = vec3(1.0, 0.0, 0.0);\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  vec3 texColor = texture(iChannel0, uv).rgb;\n  float weight = distance(refColor, texColor);\n  float luminance = dot(texColor, vec3(0.2126, 0.7152, 0.0722));\n  vec3 result = mix(texColor, vec3(luminance), weight);\n\n  gl_FragColor = vec4(result, 1.0);\n}",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\n\nconst vec3 refColor = vec3(1.0, 0.0, 0.0);\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1,\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "**Color distance** in rendering refers to the measure of difference between two colors. It quantifies how similar or different two colors are, often using mathematical formulas like the Euclidean distance in RGB space:\n\n```\ndist = |color0 - color1| \n```\n\nor in GLSL:\n\n```\ndist = distance(color0, color1) \n```\n\n**Uses and Purposes:**\n\n<br>\n\n• *Color Correction and Grading*. Adjusting colors to achieve a desired look or to match a reference color.\n<br>\n• *Image Segmentation*. Separating different objects or regions in an image based on color similarity.\n<br>\n• *Visual Effects*. Creating effects like selective desaturation, where colors distant from a reference color are desaturated to highlight specific elements.\n\n### Task\nFor each image pixel, compute the Euclidean distance between its color and the `refColor` in RGB space. Decrease the saturation of the pixel color proportionally to the distance value.",
                                "hints": [],
                                "restrictions": [],
                                "order": 7,
                                "cost": 5,
                                "threshold": 95,
                                "likes": 3,
                                "dislikes": 4,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [
                                    {
                                        "index": 0
                                    }
                                ],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\n\nconst vec3 refColor = vec3(1.0, 0.0, 0.0);\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\n\nconst vec3 refColor = vec3(1.0, 0.0, 0.0);\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 53,
                        "slug": "color-direction",
                        "moduleId": 7,
                        "name": "Color Direction",
                        "order": 8,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": true,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 53,
                                "slug": "color-direction",
                                "moduleId": 7,
                                "name": "Color Direction",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\nuniform sampler2D iChannel0;\n\nconst vec3 refColor = vec3(1.0, 0.0, 0.0);\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  vec3 texColor = texture(iChannel0, uv).rgb;\n  float weight = dot(normalize(refColor), normalize(texColor));\n  float luminance = dot(texColor, vec3(0.2126, 0.7152, 0.0722));\n  vec3 result = mix(vec3(luminance), texColor, weight * 2.0);\n\n  gl_FragColor = vec4(result, 1.0);\n}",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\nuniform sampler2D iChannel0;\n\nconst vec3 refColor = vec3(1.0, 0.0, 0.0);\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  vec3 texColor = texture(iChannel0, uv).rgb;\n  float weight = distance(refColor, texColor) / sqrt(3.0);\n  float luminance = dot(texColor, vec3(0.2126, 0.7152, 0.0722));\n  vec3 result = mix(texColor, vec3(luminance), weight * 2.0);\n\n  gl_FragColor = vec4(result, 1.0);\n}",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1,\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "We can think of color values as direction vectors rather than just points in space. By calculating the angle between the target color and the color vector, we can assess the deviation from the desired hue:\n\n\n```\ndeviation = dot(normalize(color0), normalize(color1));\n```\n\nSince the color components are always positive, the deviation value will range from `0.0` to `1.0`.\n\n<br>\n\nUnlike the color distance method, this approach keeps colors that share the same direction, even if their brightness levels differ.\n\n### Task\nYou have a program that calculates how much the color of a texture pixel deviates from a reference value using a distance measurement. Your task is to modify this program to utilize a color direction approach instead of distance.\n\n<br>\n\n**Note:** Compare how the weight coefficient changes for the distance approach and the direction approach when two colors are similar and when they differ.",
                                "hints": [],
                                "restrictions": [],
                                "order": 8,
                                "cost": 5,
                                "threshold": 95,
                                "likes": 2,
                                "dislikes": 2,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [
                                    {
                                        "index": 0
                                    }
                                ],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\nuniform sampler2D iChannel0;\n\nconst vec3 refColor = vec3(1.0, 0.0, 0.0);\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  vec3 texColor = texture(iChannel0, uv).rgb;\n  float weight = distance(refColor, texColor) / sqrt(3.0);\n  float luminance = dot(texColor, vec3(0.2126, 0.7152, 0.0722));\n  vec3 result = mix(texColor, vec3(luminance), weight * 2.0);\n\n  gl_FragColor = vec4(result, 1.0);\n}",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\nuniform sampler2D iChannel0;\n\nconst vec3 refColor = vec3(1.0, 0.0, 0.0);\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  vec3 texColor = texture(iChannel0, uv).rgb;\n  float weight = distance(refColor, texColor) / sqrt(3.0);\n  float luminance = dot(texColor, vec3(0.2126, 0.7152, 0.0722));\n  vec3 result = mix(texColor, vec3(luminance), weight * 2.0);\n\n  gl_FragColor = vec4(result, 1.0);\n}",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 54,
                        "slug": "pixelation",
                        "moduleId": 7,
                        "name": "Pixelation",
                        "order": 9,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": true,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 54,
                                "slug": "pixelation",
                                "moduleId": 7,
                                "name": "Pixelation",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\nuniform sampler2D iChannel0;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  vec2 resolution = iResolution / vec2(10.0);\n  uv = floor(uv * resolution) / resolution;\n\n  gl_FragColor = vec4(texture(iChannel0, uv).rgb, 1.0);\n}",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1,\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "Assume that the screen size always matches the texture size. Thus, each screen pixel corresponds to one texture pixel:\n\n<br>\n\n![Texture - Screen](/files/pixelation-eq-resolution.png)\n\n<br>\n\nTo make the texture appear more pixelated on the screen, its resolution should be lower than the screen resolution. This way, one texture pixel will correspond to multiple screen pixels:\n\n<br>\n\n![Texture - Screen](/files/pixelation-low-resolution.png)\n\n<br>\n\nWe can simulate pixelation by dividing the screen into blocks of size **N**x**N** pixels and assigning each block a single pixel from the texture. For simplicity, we will take the color of the first pixel from each block in the texture and apply it to the entire block on the screen:\n\n<br>\n\n![Texture - Screen](/files/pixelation-convolution.png)\n\n### Task\nDivide the screen into a grid of `10` by `10` pixels. Assign each area with the texel that corresponds to the pixel with the smallest `uv` coordinates within that area.",
                                "hints": [],
                                "restrictions": [],
                                "order": 9,
                                "cost": 5,
                                "threshold": 95,
                                "likes": 1,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [
                                    {
                                        "index": 0
                                    }
                                ],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 176,
                        "slug": "edge-detection",
                        "moduleId": 7,
                        "name": "Edge Detection",
                        "order": 12,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": true,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 176,
                                "slug": "edge-detection",
                                "moduleId": 7,
                                "name": "Edge Detection",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\nuniform sampler2D iChannel0;\nuniform vec2 iChannelSize0;\n\nvoid main() {\n  vec2 texCoord = gl_FragCoord.xy / iResolution.xy;\n  vec2 texelSize = 1.0 / iChannelSize0;\n\n  float x = texelSize.x;\n  float y = texelSize.y;\n\n  vec3 w = vec3(0.2125, 0.7154, 0.0721);\n\n  vec3 t00 = texture(iChannel0, vec2(texCoord.x - x, texCoord.y - y)).rgb;\n  vec3 t01 = texture(iChannel0, vec2(texCoord.x - x, texCoord.y)).rgb;\n  vec3 t02 = texture(iChannel0, vec2(texCoord.x - x, texCoord.y + y)).rgb;\n\n  vec3 t10 = texture(iChannel0, vec2(texCoord.x, texCoord.y - y)).rgb;\n  vec3 t11 = texture(iChannel0, vec2(texCoord.x, texCoord.y)).rgb;\n  vec3 t12 = texture(iChannel0, vec2(texCoord.x, texCoord.y + y)).rgb;\n\n  vec3 t20 = texture(iChannel0, vec2(texCoord.x + x, texCoord.y - y)).rgb;\n  vec3 t21 = texture(iChannel0, vec2(texCoord.x + x, texCoord.y)).rgb;\n  vec3 t22 = texture(iChannel0, vec2(texCoord.x + x, texCoord.y + y)).rgb;\n\n  float v = dot(t20, w) + 2.0 * dot(t21, w) + dot(t22, w) - dot(t00, w) - 2.0 * dot(t01, w) - dot(t02, w);\n\n  float h = dot(t02, w) + 2.0 * dot(t12, w) + dot(t22, w) - dot(t00, w) - 2.0 * dot(t10, w) - dot(t20, w);\n\n  float mag = length(vec2(v, h));\n\n  gl_FragColor = vec4(vec3(mag), 1.0);\n}",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\nuniform sampler2D iChannel0;\nuniform vec2 iChannelSize0;\n\nvoid main() {\n  vec2 texCoord = gl_FragCoord.xy / iResolution.xy;\n  vec2 texelSize = 1.0 / iChannelSize0;\n\n  vec3 w = vec3(0.2125, 0.7154, 0.0721);\n\n  gl_FragColor = texture(iChannel0, vec2(texCoord));\n}",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1,\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"backgroundRGBA\":\"FFFFFF\",\"background\":16777215}",
                                "description": "Edge detection is a technique used in image processing to identify points in an image where the brightness changes sharply. These points typically correspond to the boundaries of objects within the image. The **Sobel filter** is a popular edge detection method that uses convolution kernels to approximate the gradient of the image intensity.\n\n<br>\n\n### Gradient\n\n<br>\n\nThe gradient of image intensity refers to how quickly the brightness of the image changes from one pixel to the next.\n\n<br>\n\n### Convolution Kernel\n\n<br>\n\nA convolution kernel is a small matrix of numbers. Think of it as a tiny window that you slide over an image to look at small parts of it at a time.\n\n<br>\n\n![](/files/edge-detection-convolution-kernel.png)\n\n<br>\n\nFor each position, you multiply the numbers in the kernel by the corresponding values in the image, then add up all those products. This gives you a new value for the pixel, which can be used to create effects like blurring, sharpening, or detecting edges.\n\n<br>\n\n### Sobel filter\n\n<br>\n\nThe Sobel filter uses two kernels (horizontal **Gx**, vertical **Gy**):\n\n```\n     |-1  0  1|\nGx = |-2  0  2|\n     |-1  0  1|\n\n     |-1 -2 -1|\nGy = | 0  0  0|\n     | 1  2  1|\n```\n\nThe horizontal filter **Gx** calculates the gradient in the x-direction, and the vertical filter **Gy** calculates the gradient in the y-direction. The magnitude **M** of the gradient at each pixel is then calculated using the formula:\n\n```\nM = sqrt(Gx * Gx + Gy * Gy)\n```\n\nThis gives the strength of the edge at each pixel.\n\n### Task\nConvert the image to grayscale by calculating the relative luminance. Then apply the Sobel filter by convolving the grayscale image with the horizontal and vertical kernels. Output the magnitude of the gradient of the image intensity.",
                                "hints": [],
                                "restrictions": [],
                                "order": 12,
                                "cost": 5,
                                "threshold": 95,
                                "likes": 2,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [
                                    {
                                        "index": 0
                                    }
                                ],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\nuniform sampler2D iChannel0;\nuniform vec2 iChannelSize0;\n\nvoid main() {\n  vec2 texCoord = gl_FragCoord.xy / iResolution.xy;\n  vec2 texelSize = 1.0 / iChannelSize0;\n\n  vec3 w = vec3(0.2125, 0.7154, 0.0721);\n\n  gl_FragColor = texture(iChannel0, vec2(texCoord));\n}",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\nuniform sampler2D iChannel0;\nuniform vec2 iChannelSize0;\n\nvoid main() {\n  vec2 texCoord = gl_FragCoord.xy / iResolution.xy;\n  vec2 texelSize = 1.0 / iChannelSize0;\n\n  vec3 w = vec3(0.2125, 0.7154, 0.0721);\n\n  gl_FragColor = texture(iChannel0, vec2(texCoord));\n}",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 177,
                        "slug": "toon",
                        "moduleId": 7,
                        "name": "Toon",
                        "order": 13,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": true,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 177,
                                "slug": "toon",
                                "moduleId": 7,
                                "name": "Toon",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\nuniform sampler2D iChannel0;\nuniform vec2 iChannelSize0;\n\nfloat radius = 2.0;\n\nvoid main() {\n  vec2 texCoord = gl_FragCoord.xy / iResolution.xy;\n  vec2 texelSize = 1.0 / iChannelSize0 * radius;\n\n  vec3 w = vec3( 0.2125, 0.7154, 0.0721 );\n\n  float x = texelSize.x;\n  float y = texelSize.y;\n\n  vec3 t00 = texture(iChannel0, vec2(texCoord.x - x, texCoord.y - y)).rgb;\n  vec3 t01 = texture(iChannel0, vec2(texCoord.x - x, texCoord.y)).rgb;\n  vec3 t02 = texture(iChannel0, vec2(texCoord.x - x, texCoord.y + y)).rgb;\n\n  vec3 t10 = texture(iChannel0, vec2(texCoord.x, texCoord.y - y)).rgb;\n  vec3 t11 = texture(iChannel0, vec2(texCoord.x, texCoord.y)).rgb;\n  vec3 t12 = texture(iChannel0, vec2(texCoord.x, texCoord.y + y)).rgb;\n\n  vec3 t20 = texture(iChannel0, vec2(texCoord.x + x, texCoord.y - y)).rgb;\n  vec3 t21 = texture(iChannel0, vec2(texCoord.x + x, texCoord.y)).rgb;\n  vec3 t22 = texture(iChannel0, vec2(texCoord.x + x, texCoord.y + y)).rgb;\n\n  float v = dot(t20, w) + 2.0 * dot(t21, w) + dot(t22, w) - dot(t00, w) - 2.0 * dot(t01, w) - dot(t02, w);\n\n  float h = dot(t02, w) + 2.0 * dot(t12, w) + dot(t22, w) - dot(t00, w) - 2.0 * dot(t10, w) - dot(t20, w);\n\n  float mag = length(vec2(v, h));\n\n  if (mag > 0.5) {\n    gl_FragColor = vec4(vec3(0.0), 1.0);\n  } else {\n    float q = 5.0;\n    gl_FragColor = vec4(floor(t11 * q + 0.5) / q, 1.0);\n  }\n}",
                                "postProcessShader": "",
                                "properties": "",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\nuniform sampler2D iChannel0;\nuniform vec2 iChannelSize0;\n\nfloat radius = 2.0;\n\nvoid main() {\n  vec2 texCoord = gl_FragCoord.xy / iResolution.xy;\n  vec2 texelSize = 1.0 / iChannelSize0 * radius;\n\n  vec3 w = vec3(0.2125, 0.7154, 0.0721);\n\n  gl_FragColor = texture(iChannel0, vec2(texCoord));\n}",
                                "defaultPostProcessShader": "",
                                "defaultProperties": "",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1,\"model\":null,\"meshes\":[{\"name\":\"main\",\"materialId\":0}],\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"materials\":[],\"actions\":[],\"backgroundRGBA\":\"FFFFFF\",\"background\":16777215,\"customDepthBufferTexture\":false,\"glslVersion\":1}",
                                "description": "A **toon shader** is a non-photorealistic rendering technique designed to make graphics appear flat and cartoon-like. This effect is achieved by using fewer shading colors instead of smooth gradients, giving the image a stylized, hand-drawn look similar to comic books or traditional 2D animation.\n\n<br>\n\n### Toon shader steps:\n\n1. calculate the [luminance](https://shader-learning.com/module-training/7/task/49) of each pixel.\n2. apply the [Sobel edge-detection filter](https://shader-learning.com/module-training/7/task/176) and get a magnitude.\n3. if magnitude > **threshold**, color the pixel black\n4. else, quantize the pixel's color.\n5. output the colored pixel.\n\n### Color Quantization\n\n<br>\n\nColor quantization is a process used in image processing to reduce the number of distinct colors in an image. Usually, 32 bits are allocated for the color of an RGBA pixel, meaning each color channel is given 8 bits or 256 values. To reduce the number of values in each channel to **Q** values, you need to:\n\n1. Normalize the channel values to the interval [0.0, 1.0]. Usually, in shader programs, all colors are already normalized, so this step can be skipped.\n2. Multiply each channel value by **Q**, round to the nearest integer, and divide back by **Q**.\n\n\n### Task\nImplement the toon shader. Use `0.5` as a threshold value when rendering edges. Reduce the number of values in each color channel to `5`.\n\n<br>\n\nYou can play with the radius value to see how it affects the result. Set the value back to `2.0` when you submit the task",
                                "hints": [],
                                "restrictions": [],
                                "order": 13,
                                "cost": 5,
                                "threshold": 95,
                                "likes": 1,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [
                                    {
                                        "index": 0
                                    }
                                ],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\nuniform sampler2D iChannel0;\nuniform vec2 iChannelSize0;\n\nfloat radius = 2.0;\n\nvoid main() {\n  vec2 texCoord = gl_FragCoord.xy / iResolution.xy;\n  vec2 texelSize = 1.0 / iChannelSize0 * radius;\n\n  vec3 w = vec3(0.2125, 0.7154, 0.0721);\n\n  gl_FragColor = texture(iChannel0, vec2(texCoord));\n}",
                            "postProcessShader": "",
                            "properties": "",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\nuniform sampler2D iChannel0;\nuniform vec2 iChannelSize0;\n\nfloat radius = 2.0;\n\nvoid main() {\n  vec2 texCoord = gl_FragCoord.xy / iResolution.xy;\n  vec2 texelSize = 1.0 / iChannelSize0 * radius;\n\n  vec3 w = vec3(0.2125, 0.7154, 0.0721);\n\n  gl_FragColor = texture(iChannel0, vec2(texCoord));\n}",
                            "defaultPostProcessShader": "",
                            "defaultProperties": "",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    }
                ],
                "cover": true,
                "pageHeaderImage": true,
                "fullDesc": "This module is designed for developers who want to master various techniques for transforming 2D textures using fragment shaders. You will learn how to apply these techniques to create visual effects and process images for data collection. Each topic includes theoretical material and a practical task that can be completed directly on the website.",
                "skillsDesc": "understand how fragment shaders can be used to transform 2D textures.<br>various texture transformation and processing techniques.<br>apply transformations to improve image quality and prepare it for analysis.",
                "importanceDesc": "Transforming textures with fragment shaders is essential not only for creating visual effects in games and animations but also for solving tasks in machine learning and computer vision. These transformations can be used to enhance image quality, create artistic effects, improve visual perception, and prepare images for object recognition and analysis. This knowledge will help you expand your skills in computer graphics and image processing.",
                "certifiable": false,
                "images": [
                    "img-1.png",
                    "img-2.png",
                    "img-3.png",
                    "img-4.png"
                ]
            }
        },
        {
            "id": 9,
            "slug": "vertex-transformations",
            "name": "Vertex Transformations",
            "description": "Gain a comprehensive understanding of vertex shaders and their role in the graphics pipeline.",
            "tasks": 23,
            "acceptedTasks": 0,
            "isOpen": false,
            "order": 2,
            "locked": false,
            "cover": true,
            "child": {
                "id": 9,
                "slug": "vertex-transformations",
                "name": "Vertex Transformations",
                "description": "Gain a comprehensive understanding of vertex shaders and their role in the graphics pipeline.",
                "order": 2,
                "createdBy": {
                    "id": 3,
                    "name": "Alexander"
                },
                "locked": false,
                "tasks": [
                    {
                        "id": 158,
                        "slug": "vertex-shader-vertex",
                        "moduleId": 9,
                        "name": "Vertex Shader - Vertex",
                        "order": 0,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": 0,
                        "premium": false,
                        "child": {
                            "task": {
                                "id": 158,
                                "slug": "vertex-shader-vertex",
                                "moduleId": 9,
                                "name": "Vertex Shader - Vertex",
                                "vertexShader": "attribute int index;\n\nconst float dx[3] = float[](-0.5,  0.5, 0.0);\nconst float dy[3] = float[](-0.5, -0.5, 0.5);\n\nvoid main() {\n  gl_Position = vec4(dx[index], dy[index], 0.0, 1.0);\n}\n",
                                "fragmentShader": "void main() {\n  gl_FragColor = vec4(0.0, 0.55, 0.55, 1.0);\n}",
                                "defaultVertexShader": "attribute int index;\n\nvoid main() {\n  gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                                "defaultFragmentShader": "void main() {\n  gl_FragColor = vec4(0.0, 0.55, 0.55, 1.0);\n}",
                                "vertexCodeEditable": true,
                                "fragmentCodeEditable": false,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":\"-1\"},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":\"7\",\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"backgroundRGBA\":\"EEEEEE\",\"background\":15658734}",
                                "description": "**Vertex** is a point in 3D space that defines the corners of geometric shapes and is used to construct the mesh of a 3D model. The mesh itself is typically made up of triangles, which are the simplest polygonal shapes that can define a surface in 3D space.\n\n<br>\n\n![](/files/vertex-triangles.png)\n\n<br>\n\nWhen rendering an object, the GPU starts with an array of vertices. These vertices are then processed by the **vertex shader**, which is one of the first stages in the graphics pipeline.\n\n<br>\n\n![](/files/vertex-shader-shallow-pipeline.png)\n\n<br>\n\n**Vertex shader** is responsible for transforming the vertex position. The resulting position value must be set to the predefined `gl_Position` variable which is a `vec4`. The final position must be normalized to **NDC**(Normalized Device Coordinates) where **x**, **y** and **z** coordinates are between `-1.0` and `1.0`. Any coordinates that go beyond this limit will be discarded and not displayed on the screen.\n\n### Task\n\nGiven a triangle object defined by 3 vertices. All it's vertices are located at the origin `(0, 0, 0)`.\n\n![](/files/vertex-shader-triangle.png)\n\nWrite a vertex shader that uses the vertex index to appropriately move each vertex by `0.5` on the X and Y axes to produce a triangle on the screen.",
                                "hints": [],
                                "restrictions": [],
                                "order": 0,
                                "cost": 5,
                                "threshold": 99,
                                "likes": 2,
                                "dislikes": 1,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": false
                            },
                            "vertexShader": "attribute int index;\n\nvoid main() {\n  gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "fragmentShader": "void main() {\n  gl_FragColor = vec4(0.0, 0.55, 0.55, 1.0);\n}",
                            "defaultVertexShader": "attribute int index;\n\nvoid main() {\n  gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "defaultFragmentShader": "void main() {\n  gl_FragColor = vec4(0.0, 0.55, 0.55, 1.0);\n}",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 159,
                        "slug": "face-culling",
                        "moduleId": 9,
                        "name": "Face Culling",
                        "order": 1,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 159,
                                "slug": "face-culling",
                                "moduleId": 9,
                                "name": "Face Culling",
                                "vertexShader": "attribute int index;\n\nconst float dx[3] = float[](0.0, +0.5, -0.5);\nconst float dy[3] = float[](0.5, -0.5, -0.5);\n\nvoid main() {\n  gl_Position = vec4(dx[2 - index], dy[2 - index], 0.0, 1.0);\n}\n",
                                "fragmentShader": "void main() {\n  gl_FragColor = vec4(0.0, 0.55, 0.55, 1.0);\n}",
                                "defaultVertexShader": "attribute int index;\n\nconst float dx[3] = float[](0.0, +0.5, -0.5);\nconst float dy[3] = float[](0.5, -0.5, -0.5);\n\nvoid main() {\n  gl_Position = vec4(dx[index], dy[index], 0.0, 1.0);\n}\n",
                                "defaultFragmentShader": "void main() {\n  gl_FragColor = vec4(0.0, 0.55, 0.55, 1.0);\n}",
                                "vertexCodeEditable": true,
                                "fragmentCodeEditable": false,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":\"0\",\"y\":\"0\",\"z\":\"0\"},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"object\":{\"position\":{\"x\":0,\"y\":0,\"z\":\"-1\"},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":\"7\"},\"backgroundRGBA\":\"EEEEEE\",\"background\":15658734}",
                                "description": "**Face culling** is an optimisation technique in computer graphics that discards polygons that face away from the camera. \n\n<br>\n\n![](/files/face-culling-cube.png)\n\n<br>\n\nWhen defining triangles, we set the vertices in a certain order, which can be either **clockwise** or **counter-clockwise**. By default, triangles defined with counter-clockwise vertices are assumed to be **front-facing**. That is, when you visualise a triangle, it should look as if it is pointing directly at you.\n\n<br>\n\n![](/files/face-culling-clockwise.png)\n\n<br>\n\nIf face culling is activated, it will be performed right after the *vertex shader*.\n\n<br>\n\n![](/files/face-culling-pipeline.png)\n\n<br> \n\n### Task\n*Face culling* is configured so that triangles defined with *counterclockwise* vertices are face triangles. Change the vertex arrangement so that the triangle is displayed on the screen.",
                                "hints": [],
                                "restrictions": [],
                                "order": 1,
                                "cost": 5,
                                "threshold": 99,
                                "likes": 2,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "attribute int index;\n\nconst float dx[3] = float[](0.0, +0.5, -0.5);\nconst float dy[3] = float[](0.5, -0.5, -0.5);\n\nvoid main() {\n  gl_Position = vec4(dx[index], dy[index], 0.0, 1.0);\n}\n",
                            "fragmentShader": "void main() {\n  gl_FragColor = vec4(0.0, 0.55, 0.55, 1.0);\n}",
                            "defaultVertexShader": "attribute int index;\n\nconst float dx[3] = float[](0.0, +0.5, -0.5);\nconst float dy[3] = float[](0.5, -0.5, -0.5);\n\nvoid main() {\n  gl_Position = vec4(dx[index], dy[index], 0.0, 1.0);\n}\n",
                            "defaultFragmentShader": "void main() {\n  gl_FragColor = vec4(0.0, 0.55, 0.55, 1.0);\n}",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 160,
                        "slug": "triangles-composition",
                        "moduleId": 9,
                        "name": "Triangles Composition",
                        "order": 2,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 160,
                                "slug": "triangles-composition",
                                "moduleId": 9,
                                "name": "Triangles Composition",
                                "vertexShader": "attribute int index;\n\nconst float dx[6] = float[](-0.5,  0.5, 0.5, /**/ -0.5, 0.5, -0.5);\nconst float dy[6] = float[](-0.5, -0.5, 0.5, /**/ -0.5, 0.5,  0.5);\n\nvoid main() {\n  vec2 pos = position.xy + vec2(dx[index], dy[index]);  \n  \n  gl_Position = vec4(pos, 0.0, 1.0);\n}\n",
                                "fragmentShader": "void main() {\n  gl_FragColor = vec4(0.0, 0.55, 0.55, 1.0);\n}",
                                "defaultVertexShader": "attribute int index;\n\nvoid main() {\n  gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                                "defaultFragmentShader": "void main() {\n  gl_FragColor = vec4(0.0, 0.55, 0.55, 1.0);\n}",
                                "vertexCodeEditable": true,
                                "fragmentCodeEditable": false,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":\"0\",\"y\":\"0\",\"z\":\"0\"},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"object\":{\"position\":{\"x\":0,\"y\":0,\"z\":\"-1\"},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":\"8\"},\"backgroundRGBA\":\"EEEEEE\",\"background\":15658734}",
                                "description": "In 3D graphics, objects are frequently composed of triangles. \n\n<br>\n\n![](/files/triangles-composition-duck.png)\n\n<br>\n\nThis design choice is driven by several key factors:\n\n<br>\n\n**Stability**. A triangle always lies in a single plane and cannot be «deformed», unlike polygons with more vertices that can be non-coplanar. This inherent stability ensures that the basic shape of the triangles remains consistent during transformations and rendering.\n\n<br>\n\n**Efficiency**. Triangles are easily processed and rendered by graphics processors. Their simplicity allows for quick calculations and less computational load, making them ideal for real-time rendering in video games and simulations.\n\n<br>\n\n**Versatility**. Any geometric shape can be approximated with triangles. This flexibility enables the creation of complex structures and detailed models with relative ease. By breaking down surfaces into triangular facets, designers can achieve a high level of detail and realism.\n\n<br>\n\nThese unique properties make triangles indispensable in the field of computer graphics, providing a balance between performance and visual fidelity.\n\n### Task\nGiven a set of six vertices, where the first three vertices (0, 1, 2) form the first triangle and the second set of three vertices (3, 4, 5) form the second triangle. All vertices are located at the origin.\n\n<br>\n\nWrite a vertex shader that utilizes the vertex index to appropriately translate each vertex so that the two triangles form a square on the screen. The center of the square should be at the origin, with width and height equal to 1. \n\n<br> \n\nBecause of the aspect ratio, visually the parameters of the square may be distorted (ignore this).",
                                "hints": [],
                                "restrictions": [],
                                "order": 2,
                                "cost": 5,
                                "threshold": 99,
                                "likes": 2,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "attribute int index;\n\nvoid main() {\n  gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "fragmentShader": "void main() {\n  gl_FragColor = vec4(0.0, 0.55, 0.55, 1.0);\n}",
                            "defaultVertexShader": "attribute int index;\n\nvoid main() {\n  gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "defaultFragmentShader": "void main() {\n  gl_FragColor = vec4(0.0, 0.55, 0.55, 1.0);\n}",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 161,
                        "slug": "index-buffer",
                        "moduleId": 9,
                        "name": "Index Buffer",
                        "order": 3,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 161,
                                "slug": "index-buffer",
                                "moduleId": 9,
                                "name": "Index Buffer",
                                "vertexShader": "attribute int index;\n\nconst float dx[4] = float[](-0.5,  0.5, 0.5, -0.5);\nconst float dy[4] = float[](-0.5, -0.5, 0.5,  0.5);\n\nvoid main() {\n  vec2 pos = vec2(dx[index], dy[index]);\n  gl_Position = vec4(pos, 0.0, 1.0);\n}\n",
                                "fragmentShader": "void main() {\n  gl_FragColor = vec4(0.0, 0.55, 0.55, 1.0);\n}",
                                "defaultVertexShader": "attribute int index;\n\nvoid main() {\n  gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                                "defaultFragmentShader": "void main() {\n  gl_FragColor = vec4(0.0, 0.55, 0.55, 1.0);\n}",
                                "vertexCodeEditable": true,
                                "fragmentCodeEditable": false,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":\"0\",\"y\":\"0\",\"z\":\"0\"},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"object\":{\"position\":{\"x\":0,\"y\":0,\"z\":\"-1\"},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":\"9\"},\"backgroundRGBA\":\"EEEEEE\",\"background\":15658734}",
                                "description": "In our previous lesson, we learned how to draw a square using 2 triangles and 6 vertices.\n\n<br>\n\n![](/files/index-buffer-six-vertices.png)\n\n<br>\n\nHowever, you might have noticed that we specified the bottom-left and top-right vertices twice. This isn't the most efficient use of resources since a rectangle can be described with just 4 vertices instead of 6.\n\n<br>\n\n![](/files/index-buffer-four-vertices.png)\n\n<br>\n\nThe optimal solution to this problem is to store only unique vertices and then separately define the order in which we want the rendering to occur. This is where **index buffers** come into play. They allow us to reuse vertices that appear in multiple triangles, reducing the total number of vertices needed to render a 3D object.\n\n<br>\n\n**How it works:**\n\n1. **Vertex Storage**. The vertices of an object are stored in a vertex buffer.\n\n![](/files/index-buffer-vertex-buffer.png)\n\n2. **Indexing**. Each vertex is assigned a unique index.\n\n![](/files/index-buffer-vertex-buffer-indexed.png)\n\n3. **Index Buffer**. The vertex indices that form triangles are written into an index buffer in a specific order.\n\n![](/files/index-buffer-index-buffer.png)\n\n4. **Rendering**. The GPU uses the indices from the index buffer to access the vertices in the vertex buffer and draw the triangles.\n\n<br>\n\nIndex buffers enable the GPU to reuse already processed vertices to form multiple triangles, which reduces shader calls and increases rendering efficiency. For example, when you render a square defined by **four vertices** and **six indices** (which usually means two triangles), the vertex shader will be called once for each unique vertex. Since there are four unique vertices, the vertex shader will be invoked **4 times**.\n\n### Task\n\nGiven a set of four vertices. All vertices are located at the origin.\n\n<br>\n\nIndex Buffer: [0, 1, 2, 2, 3, 0].\n\n<br>\n\nWrite a vertex shader that utilizes the vertex index to appropriately translate each vertex to produce a square on the screen. The centre of the square should be at the origin, with width and height equal to 1.\n\n<br>\n\nBecause of the aspect ratio, visually the parameters of the square may be distorted (ignore this).",
                                "hints": [],
                                "restrictions": [],
                                "order": 3,
                                "cost": 5,
                                "threshold": 99,
                                "likes": 1,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "attribute int index;\n\nvoid main() {\n  gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "fragmentShader": "void main() {\n  gl_FragColor = vec4(0.0, 0.55, 0.55, 1.0);\n}",
                            "defaultVertexShader": "attribute int index;\n\nvoid main() {\n  gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "defaultFragmentShader": "void main() {\n  gl_FragColor = vec4(0.0, 0.55, 0.55, 1.0);\n}",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 162,
                        "slug": "perspective-division",
                        "moduleId": 9,
                        "name": "Perspective division",
                        "order": 4,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 162,
                                "slug": "perspective-division",
                                "moduleId": 9,
                                "name": "Perspective division",
                                "vertexShader": "uniform float iTime;\n\nattribute int index;\n\nconst float dx[4] = float[](-0.5,  0.5, 0.5, -0.5);\nconst float dy[4] = float[](-0.5, -0.5, 0.5,  0.5);\n\nvoid main() {\n  vec2 pos = vec2(dx[index], dy[index]);\n\n  float t = -cos(iTime) * 0.25 + 1.25;\n  float dw[4] = float[](1.0 / t, 1.0 / t, t, t);\n  \n  gl_Position = vec4(pos, 0.0, dw[index]);\n}\n",
                                "fragmentShader": "void main() {\n  gl_FragColor = vec4(0.0, 0.55, 0.55, 1.0);\n}",
                                "defaultVertexShader": "uniform float iTime;\n\nattribute int index;\n\nconst float dx[4] = float[](-0.5,  0.5, 0.5, -0.5);\nconst float dy[4] = float[](-0.5, -0.5, 0.5,  0.5);\n\nvoid main() {\n  vec2 pos = vec2(dx[index], dy[index]);\n  \n  gl_Position = vec4(pos, 0.0, 1.0);\n}\n",
                                "defaultFragmentShader": "void main() {\n  gl_FragColor = vec4(0.0, 0.55, 0.55, 1.0);\n}",
                                "vertexCodeEditable": true,
                                "fragmentCodeEditable": false,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":\"0\",\"y\":\"0\",\"z\":\"0\"},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"object\":{\"position\":{\"x\":0,\"y\":0,\"z\":\"-1\"},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":\"9\"},\"backgroundRGBA\":\"EEEEEE\",\"background\":15658734}",
                                "description": "**Perspective division** is the process of converting 4D coordinates into 3D normalised device coordinates. The conversion is done by dividing the *x*, *y* and *z* coordinates by the *w* coordinate:\n\n```\n      |x / w|\nout = |y / w|\n      |z / w|\n```\n\nAs a result, we can observe the effect of perspective if the value of *w* varies with distance.\n\n<br>\n\n![](/files/perspective-division-distance.png)\n\n<br>\n\n**Perspective division** is performed automatically after *face culling* and passing the vertices to the next rendering stage.\n\n<br>\n\n![](/files/perspective-division-pipeline.png)\n\n### Task\nWrite a vertex shader that utilizes the vertex index to change the perspective division parameter in time. The parameter `w` for the top vertices should change from `1.0` to `1.5`, for the bottom vertices from `1.0` to `(1.0 / 1.5)`. For animation use cosine or sine.",
                                "hints": [],
                                "restrictions": [],
                                "order": 4,
                                "cost": 5,
                                "threshold": 99,
                                "likes": 1,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": true,
                                "animationSteps": 12,
                                "animationStepTime": 500,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "uniform float iTime;\n\nattribute int index;\n\nconst float dx[4] = float[](-0.5,  0.5, 0.5, -0.5);\nconst float dy[4] = float[](-0.5, -0.5, 0.5,  0.5);\n\nvoid main() {\n  vec2 pos = vec2(dx[index], dy[index]);\n  \n  gl_Position = vec4(pos, 0.0, 1.0);\n}\n",
                            "fragmentShader": "void main() {\n  gl_FragColor = vec4(0.0, 0.55, 0.55, 1.0);\n}",
                            "defaultVertexShader": "uniform float iTime;\n\nattribute int index;\n\nconst float dx[4] = float[](-0.5,  0.5, 0.5, -0.5);\nconst float dy[4] = float[](-0.5, -0.5, 0.5,  0.5);\n\nvoid main() {\n  vec2 pos = vec2(dx[index], dy[index]);\n  \n  gl_Position = vec4(pos, 0.0, 1.0);\n}\n",
                            "defaultFragmentShader": "void main() {\n  gl_FragColor = vec4(0.0, 0.55, 0.55, 1.0);\n}",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 125,
                        "slug": "rasterizer",
                        "moduleId": 9,
                        "name": "Rasterizer",
                        "order": 5,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 125,
                                "slug": "rasterizer",
                                "moduleId": 9,
                                "name": "Rasterizer",
                                "vertexShader": "uniform float iTime;\n\nvoid main() {\n  vec3 delta = vec3(0.5 * sin(iTime), 0.0, 0.0);\n  \n  gl_Position =  vec4(position + delta, 1.0);\n}",
                                "fragmentShader": "uniform float iTime;\n\nvoid main() {\n  float t = sin(iTime) * 0.5 + 0.5;\n  vec3 fromColor = vec3(1.0, 0.0, 0.0);\n  vec3 toColor = vec3(0.0, 0.0, 1.0);\n  \n  gl_FragColor = vec4(mix(fromColor, toColor, t), 1.0);\n}",
                                "defaultVertexShader": "uniform float iTime;\n\nvoid main() {\n  vec3 delta = vec3(0.5 * sin(iTime), 0.0, 0.0);\n  \n  gl_Position =  vec4(position + delta, 1.0);\n}",
                                "defaultFragmentShader": "uniform float iTime;\n\nvoid main() {\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                                "vertexCodeEditable": true,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":\"0\",\"y\":\"0\",\"z\":\"0\"},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":\"75\",\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"object\":{\"position\":{\"x\":0,\"y\":0,\"z\":\"0\"},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":\"0\"},\"backgroundRGBA\":\"EEEEEE\",\"background\":15658734}",
                                "description": "If the coordinates of primitives, after passing through the *vertex shader*, *face culling*, and *perspective division*, fall within the clip space range [-1.0, 1.0], they are sent to the **rasterizer**.\n\n<br>\n\n![Image 1 - Pipeline](/files/rasterizer-pipeline.png)\n\n<br>\n\nThe **rasterizer** then generates fragments (pixels) for each primitive that intersects with a screen pixel.\n\n<br>\n\n![Image 2 - Rasterization](/files/rasterizer.png)\n\n<br>\n\nEach fragment is then processed by the **fragment shader**, which determines its final color. The output of the fragment shader is then sent to the frame buffer for display on the screen.\n\n### Task\nCreate a shader program that smoothly changes the color of the triangle over time using sine function, so that when the triangle is on the left side of the screen it is red, and when it is on the right it is blue.",
                                "hints": [],
                                "restrictions": [],
                                "order": 5,
                                "cost": 5,
                                "threshold": 95,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": true,
                                "animationSteps": 6,
                                "animationStepTime": 1000,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "uniform float iTime;\n\nvoid main() {\n  vec3 delta = vec3(0.5 * sin(iTime), 0.0, 0.0);\n  \n  gl_Position =  vec4(position + delta, 1.0);\n}",
                            "fragmentShader": "uniform float iTime;\n\nvoid main() {\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "defaultVertexShader": "uniform float iTime;\n\nvoid main() {\n  vec3 delta = vec3(0.5 * sin(iTime), 0.0, 0.0);\n  \n  gl_Position =  vec4(position + delta, 1.0);\n}",
                            "defaultFragmentShader": "uniform float iTime;\n\nvoid main() {\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 126,
                        "slug": "varying",
                        "moduleId": 9,
                        "name": "Varying",
                        "order": 6,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 126,
                                "slug": "varying",
                                "moduleId": 9,
                                "name": "Varying",
                                "vertexShader": "uniform float iTime;\n\nvarying vec3 fragPos;\n\nvoid main() {\n  fragPos = position + vec3(0.5 * sin(iTime), 0.5 * cos(iTime), 0.0);\n  gl_Position = vec4(fragPos, 1.0);\n}",
                                "fragmentShader": "varying vec3 fragPos;\n\nvoid main() {\n  gl_FragColor = vec4(fragPos * 0.5 + 0.5, 1.0);\n}",
                                "defaultVertexShader": "uniform float iTime;\n\nvoid main() {\n  vec3 fragPos = position + vec3(0.5 * sin(iTime), 0.5 * cos(iTime), 0.0);\n  gl_Position = vec4(fragPos, 1.0);\n}\n",
                                "defaultFragmentShader": "void main() {\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                                "vertexCodeEditable": true,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":\"0\",\"y\":\"0\",\"z\":\"1\"},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":\"75\",\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":\"0\",\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"backgroundRGBA\":\"EEEEEE\",\"background\":15658734}",
                                "description": "In OpenGL, **varyings** are variables that are used to pass data from the *vertex shader* to the *fragment shader*. These variables can store information such as color, texture coordinates, normals, and other attributes that are specific to each vertex of a mesh.\n\n<br>\n\nWhen a mesh is rendered, the vertex shader processes each vertex and outputs its varying data. For example, in image 1, each vertex has its own color value (black, green and red).\n\n<br>\n\n![Image 1 - Vertices Color Data](/files/varying-interpolation.png)\n\n<br>\n\nIf we output the color using varying, then it will be **interpolated** across the surface of the mesh to determine the values for each fragment (or pixel) that is shaded by the fragment shader.\n\n<br>\n\n![Image 2 - Color Interpolation](/files/varying-geometry.png)\n\n<br>\n\nThe type of interpolation used for varyings in OpenGL can be specified using qualifiers in the shader code. The default interpolation mode is `smooth`, which blends the values of adjacent vertices smoothly across the surface of the mesh. Other interpolation modes include `flat`, which uses the value of the nearest vertex for all fragments in a primitive.\n\n<br>\n\n### How to Use Varyings\n\n<br>\n\nVaryings are declared in the vertex shader using the `varying` keyword followed by the data type and variable name:\n\n```\nsmooth varying vec3 fragColor;\n\nvoid main() {\n   fragColor = vertexColor;\n   ...\n}\n```\n\nit declares a varying variable named `fragColor` of type `vec3` that will be passed from the vertex shader to the fragment shader.\n\n<br>\n\nTo use a varying in the fragment shader, it must also be declared with the same data type and variable name:\n\n```\nsmooth varying vec3 fragColor;\n\nvoid main() {\n   gl_FragColor = fragColor;\n}\n```\n\nAs a result, the color will be smoothly interpolated across the entire surface of the triangle.\n\n### Task\nWrite a shader program that uses the position of a fragment on the screen as the color of the triangle fragment. Since screen coordinates in [-1, 1] range, you need to map these values to the [0, 1] range before outputting the color.",
                                "hints": [],
                                "restrictions": [],
                                "order": 6,
                                "cost": 5,
                                "threshold": 95,
                                "likes": 2,
                                "dislikes": 1,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": true,
                                "animationSteps": 6,
                                "animationStepTime": 1000,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "uniform float iTime;\n\nvoid main() {\n  vec3 fragPos = position + vec3(0.5 * sin(iTime), 0.5 * cos(iTime), 0.0);\n  gl_Position = vec4(fragPos, 1.0);\n}\n",
                            "fragmentShader": "void main() {\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "defaultVertexShader": "uniform float iTime;\n\nvoid main() {\n  vec3 fragPos = position + vec3(0.5 * sin(iTime), 0.5 * cos(iTime), 0.0);\n  gl_Position = vec4(fragPos, 1.0);\n}\n",
                            "defaultFragmentShader": "void main() {\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 148,
                        "slug": "vertex-attributes",
                        "moduleId": 9,
                        "name": "Vertex Attributes",
                        "order": 8,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 148,
                                "slug": "vertex-attributes",
                                "moduleId": 9,
                                "name": "Vertex Attributes",
                                "vertexShader": "// Already availabe:\n// attribute vec3 position;\n// attribute vec3 uv;\n\nattribute int  index;\nattribute vec3 nextPosition;\n\nconst float widthHalf = 0.3;\n\nvoid main() {\n  vec2 ratio = vec2(projectionMatrix[0][0] / projectionMatrix[1][1], 1.0);\n  \n  vec3 dir = normalize(nextPosition - position);\n  vec2 n = vec2(-dir.y, dir.x);\n  if (index % 2 == 1) {\n    n *= -1.0;  \n  }\n  \n  gl_Position = vec4(position.xy * ratio + n * widthHalf * ratio, 0.0, 1.0);\n}\n",
                                "fragmentShader": "\nuniform vec2 iResolution;\nuniform float iTime;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.55, 0.55, 1.0);\n}\n",
                                "defaultVertexShader": "// Already availabe:\n// attribute vec3 position;\n// attribute vec3 uv;\n\nconst float widthHalf = 0.3;\n\nvoid main() {\n  vec2 ratio = vec2(projectionMatrix[0][0] / projectionMatrix[1][1], 1.0);\n  \n  gl_Position = vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "\nuniform vec2 iResolution;\nuniform float iTime;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.55, 0.55, 1.0);\n}\n",
                                "vertexCodeEditable": true,
                                "fragmentCodeEditable": false,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":\"0\",\"y\":\"0\",\"z\":\"0\"},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"object\":{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":\"4\"},\"backgroundRGBA\":\"EEEEEE\",\"background\":15658734}",
                                "description": "The vertex array containing an object's geometry is made up of one or more vertex attributes. At a minimum, there is one attribute that holds the position of each vertex, typically as a 3D vector of object-space x, y, and z coordinates. Most of the time, the vertex array contains several more attributes holding additional per-vertex information such as per-vertex color, normal vector, and 2D texture coordinates.\n\n<br>\n\n![Image 1 - Vertex Attributes](/files/vertex-attributes.png)\n\n<br>\n\nVertex attributes can hold various types of data, including scalar values (`float`, `int`), vectors (`vec2`, `vec3`, `vec4`), matrices (`mat2`, `mat3`, `mat4`), and custom data types.\n\n<br>\n\nTo access vertex attributes in a shader program, you need to define input variables in the vertex shader that correspond to the vertex attributes. This is typically done using the ‘attribute’ keyword in the vertex shader. For example:\n\n```\nattribute vec3 position; // Vertex attribute for position\n\nvoid main() {\n    gl_Position = vec4(position, 1.0); // Set the position of the vertex\n}\n```\n\n\nIn the above code snippet, `position` is a vertex attribute that holds a 3D vector representing the position of the vertex.\n\n### Task\nGiven a quad object defined by 4 vertices. A quad has length and direction, but no width: \n\n<br>\n\n![Image 1 - Collapsed Quad](/files/vertex-attributes-task-given.png) \n\n<br>\n\nYou need to add width to the quad by moving the vertices apart, taking into account the direction of the quad.\n\n<br>\n\n![Image 2 - Vertex Attributes](/files/vertex-attributes-task-expected.png)\n\n<br>\n\nVertices 0 and 1 have information about the initial position of vertices 2 and 3 (`nextPosition`), and vice versa. Also, each vertex is given a serial number (`index`) of integer type. Here the structure of the attributes:\n\n<br>\n\n![Image 3 - Vertex Attributes](/files/vertex-attributes-task-attributes.png)\n\n<br>\n\nYou also need to consider the aspect ratio.\n\n<br>\n\n**Note**: All values such as vertex position and calculations are performed in NDC",
                                "hints": [],
                                "restrictions": [],
                                "order": 8,
                                "cost": 5,
                                "threshold": 99,
                                "likes": 2,
                                "dislikes": 3,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "// Already availabe:\n// attribute vec3 position;\n// attribute vec3 uv;\n\nconst float widthHalf = 0.3;\n\nvoid main() {\n  vec2 ratio = vec2(projectionMatrix[0][0] / projectionMatrix[1][1], 1.0);\n  \n  gl_Position = vec4(position, 1.0);\n}\n",
                            "fragmentShader": "\nuniform vec2 iResolution;\nuniform float iTime;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.55, 0.55, 1.0);\n}\n",
                            "defaultVertexShader": "// Already availabe:\n// attribute vec3 position;\n// attribute vec3 uv;\n\nconst float widthHalf = 0.3;\n\nvoid main() {\n  vec2 ratio = vec2(projectionMatrix[0][0] / projectionMatrix[1][1], 1.0);\n  \n  gl_Position = vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "\nuniform vec2 iResolution;\nuniform float iTime;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.55, 0.55, 1.0);\n}\n",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 151,
                        "slug": "vertex-attributes-circle",
                        "moduleId": 9,
                        "name": "Vertex Attributes - Circle",
                        "order": 9,
                        "cost": 10,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 151,
                                "slug": "vertex-attributes-circle",
                                "moduleId": 9,
                                "name": "Vertex Attributes - Circle",
                                "vertexShader": "// Already availabe:\n// attribute vec3 position;\n// attribute vec3 uv;\n\nattribute vec3 nextPosition;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  vec2 ratio = vec2(projectionMatrix[0][0] / projectionMatrix[1][1], 1.0);\n\n  vec2 dir = nextPosition.xy - position.xy;\n  vec2 tang = normalize(dir);\n  vec2 norm = vec2(-tang.y, tang.x);\n  norm *= sign((uv.x - 0.5) * (uv.y - 0.5));\n\n  vec2 dudv = (dir * 0.5 + norm * 0.25);\n  \n  gl_Position = vec4(position.xy * ratio + dudv * ratio, 0.0, 1.0);\n}\n\n",
                                "fragmentShader": "varying vec2 vUv;\n\nvoid main() {\n  gl_FragColor = vec4(vUv, 0.0, 1.0);\n}\n",
                                "defaultVertexShader": "// Already availabe:\n// attribute vec3 position;\n// attribute vec2 uv;\n\nattribute vec3 nextPosition;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  vec2 ratio = vec2(projectionMatrix[0][0] / projectionMatrix[1][1], 1.0);\n\n  vec2 dudv = vUv * 2.0 - 1.0;\n  dudv *= 0.1;\n  \n  gl_Position = vec4(position.xy * ratio + dudv * ratio, 0.0, 1.0);\n}\n",
                                "defaultFragmentShader": "varying vec2 vUv;\n\nvoid main() {\n  gl_FragColor = vec4(vUv, 0.0, 1.0);\n}\n",
                                "vertexCodeEditable": true,
                                "fragmentCodeEditable": false,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":\"0\",\"y\":\"0\",\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":\"75\",\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"object\":{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":\"6\"},\"backgroundRGBA\":\"EEEEEE\",\"background\":15658734}",
                                "description": "### Task\nGiven N quads located on a circle. Vertices 0 and 1 of each quad store the position of the next point on the circle in the `nextPosition` variable, vertices 2 and 3 store the position of the previous point on the circle. It is necessary to calculate the displacement vector for each vertex of the quads to connect all quads to form the circle. The width of the circle is equal to 0.5.\n\n<br>\n\n![](/files/vertex-attributes-circle.png)\n\n<br>",
                                "hints": [],
                                "restrictions": [],
                                "order": 9,
                                "cost": 10,
                                "threshold": 99,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "// Already availabe:\n// attribute vec3 position;\n// attribute vec2 uv;\n\nattribute vec3 nextPosition;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  vec2 ratio = vec2(projectionMatrix[0][0] / projectionMatrix[1][1], 1.0);\n\n  vec2 dudv = vUv * 2.0 - 1.0;\n  dudv *= 0.1;\n  \n  gl_Position = vec4(position.xy * ratio + dudv * ratio, 0.0, 1.0);\n}\n",
                            "fragmentShader": "varying vec2 vUv;\n\nvoid main() {\n  gl_FragColor = vec4(vUv, 0.0, 1.0);\n}\n",
                            "defaultVertexShader": "// Already availabe:\n// attribute vec3 position;\n// attribute vec2 uv;\n\nattribute vec3 nextPosition;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  vec2 ratio = vec2(projectionMatrix[0][0] / projectionMatrix[1][1], 1.0);\n\n  vec2 dudv = vUv * 2.0 - 1.0;\n  dudv *= 0.1;\n  \n  gl_Position = vec4(position.xy * ratio + dudv * ratio, 0.0, 1.0);\n}\n",
                            "defaultFragmentShader": "varying vec2 vUv;\n\nvoid main() {\n  gl_FragColor = vec4(vUv, 0.0, 1.0);\n}\n",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 149,
                        "slug": "texture-coordinates",
                        "moduleId": 9,
                        "name": "Texture coordinates",
                        "order": 10,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 149,
                                "slug": "texture-coordinates",
                                "moduleId": 9,
                                "name": "Texture coordinates",
                                "vertexShader": "// Already available:\n// attribute vec3 position;\n// attribute vec2 uv;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vec3 ratio = vec3(projectionMatrix[0][0] / projectionMatrix[1][1], 1.0, 1.0);\n  vUv = uv;\n  gl_Position = vec4(position * ratio, 1.0);\n}\n",
                                "fragmentShader": "uniform sampler2D iChannel0;\n\nvarying vec2 vUv;\n\nvoid main() {\n  gl_FragColor = texture2D(iChannel0, vUv);\n}\n",
                                "defaultVertexShader": "// Already available:\n// attribute vec3 position;\n// attribute vec2 uv;\n\nvoid main() {\n  vec3 ratio = vec3(projectionMatrix[0][0] / projectionMatrix[1][1], 1.0, 1.0);\n  gl_Position = vec4(position * ratio, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform sampler2D iChannel0;\n\nvoid main() {\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                                "vertexCodeEditable": true,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":\"0\",\"y\":\"0\",\"z\":\"1\"},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"object\":{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1},\"backgroundRGBA\":\"EEEEEE\",\"background\":15658734}",
                                "description": "Texture coordinates range from (0,0) for the lower left corner of the texture image to (1,1) for the upper right corner of the texture image.\n\n<br>\n\n![Image 1 - Texture Coordinates](/files/texture-coordinates-tex-coords.png)\n\n<br>\n\nIn order to map a texture to the triangle we need to tell each vertex of the triangle which part of the texture it corresponds to. Each vertex should thus have a texture coordinate associated with them that specifies what part of the texture image to sample from:\n\n<br>\n\n![Image 2 - Geometry](/files/texture-coordinates-geometry.png)\n\n<br>\n\nFragment interpolation then does the rest for the other fragments: \n\n<br>\n\n![Image 3 - Interpolation](/files/texture-coordinates-interpolation.png)\n\n<br>\n\nTo access the texture that is attached to a shader program, you need declare a `uniform` of `sampler2D` type:\n\n```\nuniform sampler2D <Name>\n```\n\nTo sample the color of the texture, use the built-in `texture` function that takes a `sampler2D` as its first argument and the corresponding texture coordinates as its second argument:\n\n```\nvec4 color = texture(<Name>, texCoord);\n```\n\n### Task\nGiven a quad object defined by 4 vertices, bind the texture from iChannel0 to the quad.\n\n<br>\n\nThe `uv` variable is a vertex attribute that contains texture coordinates of the vertex. It is available in the vertex shader as a global variable.",
                                "hints": [],
                                "restrictions": [],
                                "order": 10,
                                "cost": 5,
                                "threshold": 99,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [
                                    {
                                        "index": 0
                                    }
                                ],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "// Already available:\n// attribute vec3 position;\n// attribute vec2 uv;\n\nvoid main() {\n  vec3 ratio = vec3(projectionMatrix[0][0] / projectionMatrix[1][1], 1.0, 1.0);\n  gl_Position = vec4(position * ratio, 1.0);\n}\n",
                            "fragmentShader": "uniform sampler2D iChannel0;\n\nvoid main() {\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "defaultVertexShader": "// Already available:\n// attribute vec3 position;\n// attribute vec2 uv;\n\nvoid main() {\n  vec3 ratio = vec3(projectionMatrix[0][0] / projectionMatrix[1][1], 1.0, 1.0);\n  gl_Position = vec4(position * ratio, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform sampler2D iChannel0;\n\nvoid main() {\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 96,
                        "slug": "uniform-scale",
                        "moduleId": 9,
                        "name": "Uniform Scale",
                        "order": 11,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 96,
                                "slug": "uniform-scale",
                                "moduleId": 9,
                                "name": "Uniform Scale",
                                "vertexShader": "uniform float iTime;\n\nvoid main() {\n  float scale = sin(iTime + 3.14 / 2.0) * 0.5 + 0.5;\n  \n  gl_Position =  vec4(position * vec3(scale), 1.0);\n}",
                                "fragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.55, 0.55, 1.0);\n}",
                                "defaultVertexShader": "uniform float iTime;\n\nvoid main() {\n  gl_Position = vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.55, 0.55, 1.0);\n}\n",
                                "vertexCodeEditable": true,
                                "fragmentCodeEditable": false,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":\"0\",\"y\":\"0\",\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"object\":{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":\"0\"},\"backgroundRGBA\":\"EEEEEE\",\"background\":15658734}",
                                "description": "A scaling operation is called **uniform** if the scaling factor is the same for each axis. \n\n<br>\n\n![](/files/uniform-scale.png)\n\n<br>\n\nWhen we scale a vector uniformly, we increase its length while keeping its direction the same:\n\n```\nV' = V * Scale = (Vx * Scale, Vy * Scale, Vz * Scale);\n```\n\n\n### Task\nApply the uniform scale to the triangle's vertices in the vertex shader so that the size of the triangle decreases from the initial value to 0 and back. Use sine function for animation.",
                                "hints": [],
                                "restrictions": [],
                                "order": 11,
                                "cost": 5,
                                "threshold": 98,
                                "likes": 2,
                                "dislikes": 1,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": true,
                                "animationSteps": 10,
                                "animationStepTime": 500,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "uniform float iTime;\n\nvoid main() {\n  gl_Position = vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.55, 0.55, 1.0);\n}\n",
                            "defaultVertexShader": "uniform float iTime;\n\nvoid main() {\n  gl_Position = vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.55, 0.55, 1.0);\n}\n",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 98,
                        "slug": "non-uniform-scale",
                        "moduleId": 9,
                        "name": "Non-uniform Scale",
                        "order": 12,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 98,
                                "slug": "non-uniform-scale",
                                "moduleId": 9,
                                "name": "Non-uniform Scale",
                                "vertexShader": "uniform float iTime;\n\nvoid main() {\n  float scaleX = sin(iTime + 1.57) * 0.5 + 0.5;\n  \n  gl_Position =  vec4(position * vec3(scaleX, 1.0, 1.0), 1.0);\n}",
                                "fragmentShader": "void main() {\n  gl_FragColor = vec4(0.0, 0.55, 0.55, 1.0);\n}",
                                "defaultVertexShader": "uniform float iTime;\n\nvoid main() {\n  gl_Position = vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "void main() {\n  gl_FragColor = vec4(0.0, 0.55, 0.55, 1.0);\n}",
                                "vertexCodeEditable": true,
                                "fragmentCodeEditable": false,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":\"0\",\"y\":\"0\",\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":\"0\",\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"backgroundRGBA\":\"EEEEEE\",\"background\":15658734}",
                                "description": "The scaling operation is called **non-uniform** if the scaling factor is not the same for each axis.\n\n<br>\n\n![](/files/non-uniform-scale.png)\n\n<br>\n\nWhen a vector is scaled non-uniformly, its direction may change. This happens because different vector components are multiplied by different scaling factors:\n\n```\nV' = V * S = (Vx * Sx, Vy * Sy, Vz * Sz)\n\n```\n\n As a result, if one component of a vector increases more than another, the vector leans toward that component.\n\n<br>\n\n![](/files/non-uniform-scale-vector-direction.png)\n\n### Task\nApply the non-uniform scale to the triangle's vertices in the vertex shader so that the width of the triangle decreases from the initial value to 0 and back. Use `sin` or `cos` function for animation.",
                                "hints": [],
                                "restrictions": [],
                                "order": 12,
                                "cost": 5,
                                "threshold": 98,
                                "likes": 0,
                                "dislikes": 1,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "uniform float iTime;\n\nvoid main() {\n  gl_Position = vec4(position, 1.0);\n}\n",
                            "fragmentShader": "void main() {\n  gl_FragColor = vec4(0.0, 0.55, 0.55, 1.0);\n}",
                            "defaultVertexShader": "uniform float iTime;\n\nvoid main() {\n  gl_Position = vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "void main() {\n  gl_FragColor = vec4(0.0, 0.55, 0.55, 1.0);\n}",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 105,
                        "slug": "scale-matrix",
                        "moduleId": 9,
                        "name": "Scale Matrix",
                        "order": 13,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 105,
                                "slug": "scale-matrix",
                                "moduleId": 9,
                                "name": "Scale Matrix",
                                "vertexShader": "uniform float iTime;\n\nvarying vec3 vPos;\n\nvoid setPosition3D(mat3 transform) {\n  vec3 worldPos = transform * position;\n  vPos = worldPos;\n  gl_Position = projectionMatrix * viewMatrix * vec4(worldPos, 1.0);\n}\n\nvoid main() {\n  float delta = sin(iTime - 1.57) * 0.5 + 0.5;\n  \n  vec3 r1 = vec3(1.0 + delta * 2.0, 0.0, 0.0);\n  vec3 r2 = vec3(0.0, 1.0 - delta, 0.0);\n  vec3 r3 = vec3(0.0, 0.0, 1.0 + delta * 2.0);\n  \n  mat3 transform = transpose(mat3(r1, r2, r3));\n  setPosition3D(transform);\n}",
                                "fragmentShader": "varying vec3 vPos;\n\nconst vec3 lightPos = vec3(0.0, 2.0, 5.0);\n\nvoid main() {\n  vec3 dx = dFdx(vPos);\n  vec3 dy = dFdy(vPos);\n  vec3 normal = normalize(cross(dx, dy));\n\n  vec3 lightDir = normalize(lightPos - vPos);\n  float t = dot(normal, lightDir) * 0.75 + 0.25;\n  \n  gl_FragColor = vec4(vec3(0.0, 0.55, 0.55) * t, 1.0);\n}\n",
                                "defaultVertexShader": "uniform float iTime;\n\nvarying vec3 vPos;\n\nvoid setPosition3D(mat3 transform) {\n  vec3 worldPos = transform * position;\n  vPos = worldPos;\n  gl_Position = projectionMatrix * viewMatrix * vec4(worldPos, 1.0);\n}\n\nvoid main() {\n  vec3 r1 = vec3(1.0, 0.0, 0.0);\n  vec3 r2 = vec3(0.0, 1.0, 0.0);\n  vec3 r3 = vec3(0.0, 0.0, 1.0);\n\n  // We need to transpose the matrix because OpenGL's mat3 accepts column vectors\n  mat3 transform = transpose(mat3(r1, r2, r3));\n  setPosition3D(transform);\n}",
                                "defaultFragmentShader": "varying vec3 vPos;\n\nconst vec3 lightPos = vec3(0.0, 2.0, 5.0);\n\nvoid main() {\n  vec3 dx = dFdx(vPos);\n  vec3 dy = dFdy(vPos);\n  vec3 normal = normalize(cross(dx, dy));\n\n  vec3 lightDir = normalize(lightPos - vPos);\n  float t = dot(normal, lightDir) * 0.75 + 0.25;\n  \n  gl_FragColor = vec4(vec3(0.0, 0.55, 0.55) * t, 1.0);\n}\n",
                                "vertexCodeEditable": true,
                                "fragmentCodeEditable": false,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":\"1.5\",\"y\":\"1.25\",\"z\":\"2.5\"},\"rotation\":{\"x\":\"-0.4\",\"y\":\"0.5\",\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":\"45\",\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":\"0\",\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":\"2\",\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"backgroundRGBA\":\"EEEEEE\",\"background\":15658734}",
                                "description": "**Scale matrix** is a specific type of transformation matrix used to scale objects. The general form of a 3x3 scale matrix is:\n\n\n```\n|sx,  0,  0|\n| 0, sy,  0| \n| 0,  0, sz|\n```\n\nWhere:\n<br>\n• **sx** is the scaling factor along the x-axis.\n<br>\n• **sy** is the scaling factor along the y-axis.\n<br>\n• **sz** is the scaling factor along the z-axis.\n\n<br>\n\n### How It Works\n\n<br>\n\nWhen you multiply a 3D point **P** by this scale matrix **M**, the point is scaled by the factors **sx**, **sy** and **sz**:\n```\n             |sx,  0,  0| |Px|   |sx * Px|\nP' = M * P = | 0, sy,  0|*|Py| = |sy * Py|\n             | 0,  0, sz| |Pz|   |sz * Pz|\n```\n\n### Task\nCreate a scaling matrix that adjusts the cube's dimensions according to the following specifications:\n1. Increase the size of the cube along the *X* and *Z* axes from 1 to 3, and vice versa.\n2. Decrease the size of the cube along the *Y*-axis from 1 to 0, and vice versa.\n\n<br>\n\nThe adjustments on all axes should be made simultaneously and take 6.28 seconds, which is equivalent to one sine period. The resulting transformation matrix should then be passed to the `setPosition3D` function.",
                                "hints": [],
                                "restrictions": [],
                                "order": 13,
                                "cost": 5,
                                "threshold": 98,
                                "likes": 3,
                                "dislikes": 3,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": true,
                                "animationSteps": 6,
                                "animationStepTime": 1000,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "uniform float iTime;\n\nvarying vec3 vPos;\n\nvoid setPosition3D(mat3 transform) {\n  vec3 worldPos = transform * position;\n  vPos = worldPos;\n  gl_Position = projectionMatrix * viewMatrix * vec4(worldPos, 1.0);\n}\n\nvoid main() {\n  vec3 r1 = vec3(1.0, 0.0, 0.0);\n  vec3 r2 = vec3(0.0, 1.0, 0.0);\n  vec3 r3 = vec3(0.0, 0.0, 1.0);\n\n  // We need to transpose the matrix because OpenGL's mat3 accepts column vectors\n  mat3 transform = transpose(mat3(r1, r2, r3));\n  setPosition3D(transform);\n}",
                            "fragmentShader": "varying vec3 vPos;\n\nconst vec3 lightPos = vec3(0.0, 2.0, 5.0);\n\nvoid main() {\n  vec3 dx = dFdx(vPos);\n  vec3 dy = dFdy(vPos);\n  vec3 normal = normalize(cross(dx, dy));\n\n  vec3 lightDir = normalize(lightPos - vPos);\n  float t = dot(normal, lightDir) * 0.75 + 0.25;\n  \n  gl_FragColor = vec4(vec3(0.0, 0.55, 0.55) * t, 1.0);\n}\n",
                            "defaultVertexShader": "uniform float iTime;\n\nvarying vec3 vPos;\n\nvoid setPosition3D(mat3 transform) {\n  vec3 worldPos = transform * position;\n  vPos = worldPos;\n  gl_Position = projectionMatrix * viewMatrix * vec4(worldPos, 1.0);\n}\n\nvoid main() {\n  vec3 r1 = vec3(1.0, 0.0, 0.0);\n  vec3 r2 = vec3(0.0, 1.0, 0.0);\n  vec3 r3 = vec3(0.0, 0.0, 1.0);\n\n  // We need to transpose the matrix because OpenGL's mat3 accepts column vectors\n  mat3 transform = transpose(mat3(r1, r2, r3));\n  setPosition3D(transform);\n}",
                            "defaultFragmentShader": "varying vec3 vPos;\n\nconst vec3 lightPos = vec3(0.0, 2.0, 5.0);\n\nvoid main() {\n  vec3 dx = dFdx(vPos);\n  vec3 dy = dFdy(vPos);\n  vec3 normal = normalize(cross(dx, dy));\n\n  vec3 lightDir = normalize(lightPos - vPos);\n  float t = dot(normal, lightDir) * 0.75 + 0.25;\n  \n  gl_FragColor = vec4(vec3(0.0, 0.55, 0.55) * t, 1.0);\n}\n",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 99,
                        "slug": "90-degree-rotation",
                        "moduleId": 9,
                        "name": "90-Degree Rotation",
                        "order": 14,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 99,
                                "slug": "90-degree-rotation",
                                "moduleId": 9,
                                "name": "90-Degree Rotation",
                                "vertexShader": "void setPosition2D(vec2 pos) {\n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 0.0, 1.0);\n}\n\nvoid main() {\n  setPosition2D(vec2(-position.y, position.x));\n}",
                                "fragmentShader": "void main() {\n  gl_FragColor = vec4(0.0, 0.55, 0.55, 1.0);\n}",
                                "defaultVertexShader": "\nvoid setPosition2D(vec2 pos) {\n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 0.0, 1.0);\n}\n\nvoid main() {\n  setPosition2D(position.xy);\n}\n",
                                "defaultFragmentShader": "void main() {\n  gl_FragColor = vec4(0.0, 0.55, 0.55, 1.0);\n}\n",
                                "vertexCodeEditable": true,
                                "fragmentCodeEditable": false,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":\"0\",\"y\":\"0\",\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"object\":{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":\"0\"},\"backgroundRGBA\":\"EEEEEE\",\"background\":15658734}",
                                "description": "We can perform a 90-degree counterclockwise rotation of a 2D vector in the *x-y* plane by exchanging the *x* and *y* coordinates and negating the new *x* coordinate:\n\n<br>\n\n![90-Degree Rotation](/files/90-degree-rotation.png)\n\n<br>\n\n### Task\nPerform a 90-degree counterclockwise rotation of the triangle. Pass the transformed vertex's *x* and *y* coordinates to the `setPosition2D` function. For now, you can ignore it's content.",
                                "hints": [],
                                "restrictions": [],
                                "order": 14,
                                "cost": 5,
                                "threshold": 98,
                                "likes": 1,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "\nvoid setPosition2D(vec2 pos) {\n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 0.0, 1.0);\n}\n\nvoid main() {\n  setPosition2D(position.xy);\n}\n",
                            "fragmentShader": "void main() {\n  gl_FragColor = vec4(0.0, 0.55, 0.55, 1.0);\n}\n",
                            "defaultVertexShader": "\nvoid setPosition2D(vec2 pos) {\n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 0.0, 1.0);\n}\n\nvoid main() {\n  setPosition2D(position.xy);\n}\n",
                            "defaultFragmentShader": "void main() {\n  gl_FragColor = vec4(0.0, 0.55, 0.55, 1.0);\n}\n",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 97,
                        "slug": "rotation",
                        "moduleId": 9,
                        "name": "Rotation",
                        "order": 15,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 97,
                                "slug": "rotation",
                                "moduleId": 9,
                                "name": "Rotation",
                                "vertexShader": "uniform float iTime;\n\nvoid setPosition2D(vec2 pos) {\n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 0.0, 1.0);\n}\n\nvoid main() {\n  float angle = (sin(iTime) * 0.5 + 0.5) * 6.28;\n  \n  float x = position.x * cos(angle) - position.y * sin(angle);\n  float y = position.x * sin(angle) + position.y * cos(angle);\n  \n  setPosition2D(vec2(x, y));\n}",
                                "fragmentShader": "void main() {\n  gl_FragColor = vec4(0.0, 0.55, 0.55, 1.0);\n}",
                                "defaultVertexShader": "uniform float iTime;\n\nvoid setPosition2D(vec2 pos) {\n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 0.0, 1.0);\n}\n\nvoid main() {\n  setPosition2D(position.xy);\n}\n",
                                "defaultFragmentShader": "void main() {\n  gl_FragColor = vec4(0.0, 0.55, 0.55, 1.0);\n}",
                                "vertexCodeEditable": true,
                                "fragmentCodeEditable": false,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":\"0\",\"y\":\"0\",\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":\"75\",\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"object\":{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":\"0.0\",\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":\"1\"},\"backgroundRGBA\":\"EEEEEE\",\"background\":15658734}",
                                "description": "We can express 2D position **P** in the polar form:\n\n<br>\n\n![](/files/rotation-radial-coordinates.png)\n\n<br>\n\n```\nPx = r * cos(φ)\nPy = r * sin(φ)\n```\n\nTo rotate the coordinates, we need to add an offset angle to the current:\n\n<br>\n\n![](/files/rotation-offset-angle.png)\n\n<br>\n\n```\nP'x = r * cos(φ + Δ)\nP'y = r * sin(φ + Δ)\n```\n\n### Task\nPerform a 360-degree counterclockwise rotation of the rect. Use sin function for animation. Pass the transformed vertex's *x* and *y* coordinates to the `setPosition2D `function. For now, you can ignore it's content.",
                                "hints": [],
                                "restrictions": [],
                                "order": 15,
                                "cost": 5,
                                "threshold": 99,
                                "likes": 2,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": true,
                                "animationSteps": 6,
                                "animationStepTime": 1000,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "uniform float iTime;\n\nvoid setPosition2D(vec2 pos) {\n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 0.0, 1.0);\n}\n\nvoid main() {\n  setPosition2D(position.xy);\n}\n",
                            "fragmentShader": "void main() {\n  gl_FragColor = vec4(0.0, 0.55, 0.55, 1.0);\n}",
                            "defaultVertexShader": "uniform float iTime;\n\nvoid setPosition2D(vec2 pos) {\n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 0.0, 1.0);\n}\n\nvoid main() {\n  setPosition2D(position.xy);\n}\n",
                            "defaultFragmentShader": "void main() {\n  gl_FragColor = vec4(0.0, 0.55, 0.55, 1.0);\n}",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 101,
                        "slug": "rotation-about-a-point",
                        "moduleId": 9,
                        "name": "Rotation About a Point",
                        "order": 16,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 101,
                                "slug": "rotation-about-a-point",
                                "moduleId": 9,
                                "name": "Rotation About a Point",
                                "vertexShader": "uniform float iTime;\n\nvoid setPosition2D(vec2 pos) {\n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 0.0, 1.0);\n}\n\nvoid main() {\n  vec2 origin = position.xy + vec2(0.0, 2.0);\n  vec2 rotationCenter = vec2(0.0, 0.0);\n  \n  float angle = iTime;\n  \n  vec2 dir = origin - rotationCenter;\n  float dx = dir.x * cos(angle) - dir.y * sin(angle);\n  float dy = dir.x * sin(angle) + dir.y * cos(angle);\n\n  setPosition2D(rotationCenter + vec2(dx, dy));\n}",
                                "fragmentShader": "void main() {\n  gl_FragColor = vec4(0.0, 0.55, 0.55, 1.0);\n}",
                                "defaultVertexShader": "uniform float iTime;\n\nvoid setPosition2D(vec2 pos) {\n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 0.0, 1.0);\n}\n\nvoid main() {\n  setPosition2D(position.xy);\n}\n",
                                "defaultFragmentShader": "void main() {\n  gl_FragColor = vec4(0.0, 0.55, 0.55, 1.0);\n}",
                                "vertexCodeEditable": true,
                                "fragmentCodeEditable": false,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":\"0\",\"y\":\"0\",\"z\":\"4\"},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"object\":{\"position\":{\"x\":\"2\",\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1},\"backgroundRGBA\":\"EEEEEE\",\"background\":15658734}",
                                "description": "To perform a rotation of an object **P** around a specific origin **O**, we can calculate the displacement vector of the object from the origin and then apply the rotation transformation to this vector, as previously learned.\n\n<br>\n\n![Rotation About a Point](/files/rotation-about-point.png)\n\n<br>\n\n### Task\nPerform a 360-degree counterclockwise rotation of the rect around the point `(0.0, 0.0)` with a radius of `2.0`. Calculate the new *x* and *y* coordinates of the transformed vertex and pass them to the `setPosition2D` function. For now, you can ignore its content.",
                                "hints": [],
                                "restrictions": [],
                                "order": 16,
                                "cost": 5,
                                "threshold": 99,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": true,
                                "animationSteps": 6,
                                "animationStepTime": 1000,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "uniform float iTime;\n\nvoid setPosition2D(vec2 pos) {\n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 0.0, 1.0);\n}\n\nvoid main() {\n  setPosition2D(position.xy);\n}\n",
                            "fragmentShader": "void main() {\n  gl_FragColor = vec4(0.0, 0.55, 0.55, 1.0);\n}",
                            "defaultVertexShader": "uniform float iTime;\n\nvoid setPosition2D(vec2 pos) {\n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 0.0, 1.0);\n}\n\nvoid main() {\n  setPosition2D(position.xy);\n}\n",
                            "defaultFragmentShader": "void main() {\n  gl_FragColor = vec4(0.0, 0.55, 0.55, 1.0);\n}",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 100,
                        "slug": "rotation-about-an-arbitrary-axis",
                        "moduleId": 9,
                        "name": "Rotation About an Arbitrary Axis",
                        "order": 17,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 100,
                                "slug": "rotation-about-an-arbitrary-axis",
                                "moduleId": 9,
                                "name": "Rotation About an Arbitrary Axis",
                                "vertexShader": "uniform float iTime;\n\nvarying vec3 vPos;\n\nvoid setPosition3D(vec3 pos) {\n  vPos = pos;\n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n\nvoid main() {\n  float angle = iTime;\n  vec3 axis = normalize(vec3(1.0, 1.0, 0.0));\n  vec3 p0 = position.xyz + vec3(1.0, -1.0, 0.0);\n\n  vec3 projPosAxis = axis * dot(axis, p0);\n  vec3 perpPosAxis = p0 - projPosAxis;\n  vec3 perp = cross(axis, perpPosAxis);\n\n  vec3 p1 = perp * sin(angle) + perpPosAxis * cos(angle) + projPosAxis;\n  setPosition3D(p1);\n}",
                                "fragmentShader": "varying vec3 vPos;\n\nconst vec3 lightPos = vec3(0.0, 0.0, 5.0);\n\nvoid main() {\n  vec3 dx = dFdx(vPos);\n  vec3 dy = dFdy(vPos);\n  vec3 normal = normalize(cross(dx, dy));\n\n  vec3 lightDir = normalize(lightPos - vPos);\n  float t = dot(normal, lightDir) * 0.75 + 0.25;\n  \n  gl_FragColor = vec4(vec3(0.0, 0.55, 0.55) * t, 1.0);\n}",
                                "defaultVertexShader": "uniform float iTime;\n\nvarying vec3 vPos;\n\nvoid setPosition3D(vec3 pos) {\n  vPos = pos;\n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n\nvoid main() {\n  float angle = iTime;\n  vec3 axis = normalize(vec3(1.0, 1.0, 0.0));\n  vec3 p0 = position.xyz + vec3(1.0, -1.0, 0.0);\n\n  setPosition3D(p0);  \n}\n",
                                "defaultFragmentShader": "varying vec3 vPos;\n\nconst vec3 lightPos = vec3(0.0, 0.0, 5.0);\n\nvoid main() {\n  vec3 dx = dFdx(vPos);\n  vec3 dy = dFdy(vPos);\n  vec3 normal = normalize(cross(dx, dy));\n\n  vec3 lightDir = normalize(lightPos - vPos);\n  float t = dot(normal, lightDir) * 0.75 + 0.25;\n  \n  gl_FragColor = vec4(vec3(0.0, 0.55, 0.55) * t, 1.0);\n}",
                                "vertexCodeEditable": true,
                                "fragmentCodeEditable": false,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":\"0\",\"y\":\"0\",\"z\":\"5\"},\"rotation\":{\"x\":0,\"y\":\"0\",\"z\":\"0\"},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":45,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"object\":{\"position\":{\"x\":\"0\",\"y\":\"0\",\"z\":\"0\"},\"rotation\":{\"x\":\"0\",\"y\":\"0\",\"z\":\"0\"},\"scale\":{\"x\":\"1\",\"y\":1,\"z\":1},\"geometry\":\"2\"},\"backgroundRGBA\":\"EEEEEE\",\"background\":15658734}",
                                "description": "To rotate a vector **v** by an angle **θ** around an arbitrary unit vector **n**, we first decompose **v** into its parallel **v∥** and perpendicular **v⊥** components with respect to **n**:\n\n<br>\n\n![](/files/rotation-about-axis-decompose.png)\n\n```\nv∥ = (n ⋅ v) * n\nv⊥ = v - v∥\n```\n\nNext, we need to rotate the perpendicular component **v⊥** about **n** by the angle **θ** in the plane perpendicular to the axis. \n\n<br>\n\n![](/files/rotation-about-axis-perp-rotate.png)\n\n<br>\n\nTo do this, we first perform the cross product of **v⊥** and **n**:\n\n<br>\n\n![](/files/rotation-about-axis-perp-cross.png)\n\n<br>\n\nAs a result, we obtain two perpendicular vectors, which lie in the plane perpendicular to the rotation axis and declare a rectangular coordinate system:\n\n<br>\n\n![](/files/rotation-about-axis-perp-system.png)\n\n<br>\n\nNow we can express the rotated perpendicular component as a linear combination:\n```\nv'⊥ = v⊥ * cos(θ) + (n × v⊥) * sin(θ)\n```\n\nFinally, we add the parallel component **v∥** to the rotated perpendicular component **v'⊥** to get the final rotated vector:\n\n<br>\n\n![](/files/rotation-about-axis-final.png)\n\n<br>\n\n```\nv' = v∥ + v'⊥\n```\n\n### Task\nPerform a 360-degree counterclockwise rotation of the cube around the axis `(1.0, 1.0, 0.0)`. Calculate the new coordinates of the transformed vertex and pass them to the `setPosition3D` function. For now, you can ignore its content.",
                                "hints": [],
                                "restrictions": [],
                                "order": 17,
                                "cost": 5,
                                "threshold": 98,
                                "likes": 2,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": true,
                                "animationSteps": 6,
                                "animationStepTime": 1000,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "uniform float iTime;\n\nvarying vec3 vPos;\n\nvoid setPosition3D(vec3 pos) {\n  vPos = pos;\n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n\nvoid main() {\n  float angle = iTime;\n  vec3 axis = normalize(vec3(1.0, 1.0, 0.0));\n  vec3 p0 = position.xyz + vec3(1.0, -1.0, 0.0);\n\n  setPosition3D(p0);  \n}\n",
                            "fragmentShader": "varying vec3 vPos;\n\nconst vec3 lightPos = vec3(0.0, 0.0, 5.0);\n\nvoid main() {\n  vec3 dx = dFdx(vPos);\n  vec3 dy = dFdy(vPos);\n  vec3 normal = normalize(cross(dx, dy));\n\n  vec3 lightDir = normalize(lightPos - vPos);\n  float t = dot(normal, lightDir) * 0.75 + 0.25;\n  \n  gl_FragColor = vec4(vec3(0.0, 0.55, 0.55) * t, 1.0);\n}",
                            "defaultVertexShader": "uniform float iTime;\n\nvarying vec3 vPos;\n\nvoid setPosition3D(vec3 pos) {\n  vPos = pos;\n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n\nvoid main() {\n  float angle = iTime;\n  vec3 axis = normalize(vec3(1.0, 1.0, 0.0));\n  vec3 p0 = position.xyz + vec3(1.0, -1.0, 0.0);\n\n  setPosition3D(p0);  \n}\n",
                            "defaultFragmentShader": "varying vec3 vPos;\n\nconst vec3 lightPos = vec3(0.0, 0.0, 5.0);\n\nvoid main() {\n  vec3 dx = dFdx(vPos);\n  vec3 dy = dFdy(vPos);\n  vec3 normal = normalize(cross(dx, dy));\n\n  vec3 lightDir = normalize(lightPos - vPos);\n  float t = dot(normal, lightDir) * 0.75 + 0.25;\n  \n  gl_FragColor = vec4(vec3(0.0, 0.55, 0.55) * t, 1.0);\n}",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 122,
                        "slug": "rotation-matrix",
                        "moduleId": 9,
                        "name": "Rotation Matrix",
                        "order": 18,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 122,
                                "slug": "rotation-matrix",
                                "moduleId": 9,
                                "name": "Rotation Matrix",
                                "vertexShader": "uniform float iTime;\n\nvarying vec3 vPos;\n\nvoid setPosition3D(mat3 transform) {\n  vec3 pos = transform * position.xyz;\n  vPos = pos;\n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n\nvoid main() {\n  float progress = abs(cos(iTime * 0.5) * 0.5 - 0.5);\n  progress *= 3.0 * 3.14;\n  \n  float angleX = clamp(progress, 3.14 * 0.0, 3.14 * 1.0);\n  float angleY = clamp(progress, 3.14 * 1.0, 3.14 * 2.0);\n  float angleZ = clamp(progress, 3.14 * 2.0, 3.14 * 3.0);\n  \n  mat3 rotateX = transpose(mat3(\n    vec3(1, 0, 0),\n    vec3(0, cos(angleX), -sin(angleX)),\n    vec3(0, sin(angleX), cos(angleX))\n  ));\n\n  mat3 rotateY = transpose(mat3(\n    vec3(cos(angleY), 0, sin(angleY)),\n    vec3(0, 1, 0),\n    vec3(-sin(angleY), 0, cos(angleY))\n  ));\n\n  mat3 rotateZ = transpose(mat3(\n    vec3(cos(angleZ), -sin(angleZ), 0),\n    vec3(sin(angleZ), cos(angleZ), 0),\n    vec3(0, 0, 1)\n  ));\n\n  setPosition3D(rotateZ * rotateY * rotateX);\n}\n",
                                "fragmentShader": "varying vec3 vPos;\n\nconst vec3 lightPos = vec3(0.0, 0.0, 5.0);\n\nvoid main() {\n  vec3 dx = dFdx(vPos);\n  vec3 dy = dFdy(vPos);\n  vec3 normal = normalize(cross(dx, dy));\n\n  vec3 lightDir = normalize(lightPos - vPos);\n  float t = dot(normal, lightDir) * 0.75 + 0.25;\n  \n  gl_FragColor = vec4(vec3(0.0, 0.55, 0.55) * t, 1.0);\n}\n",
                                "defaultVertexShader": "uniform float iTime;\n\nvarying vec3 vPos;\n\nvoid setPosition3D(mat3 transform) {\n  vec3 pos = transform * position.xyz;\n  vPos = pos;\n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n\nvoid main() {\n  float progress = abs(cos(iTime * 0.5) * 0.5 - 0.5);\n\n  setPosition3D(mat3(1.0));\n}\n",
                                "defaultFragmentShader": "varying vec3 vPos;\n\nconst vec3 lightPos = vec3(0.0, 0.0, 5.0);\n\nvoid main() {\n  vec3 dx = dFdx(vPos);\n  vec3 dy = dFdy(vPos);\n  vec3 normal = normalize(cross(dx, dy));\n\n  vec3 lightDir = normalize(lightPos - vPos);\n  float t = dot(normal, lightDir) * 0.75 + 0.25;\n  \n  gl_FragColor = vec4(vec3(0.0, 0.55, 0.55) * t, 1.0);\n}\n",
                                "vertexCodeEditable": true,
                                "fragmentCodeEditable": false,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":\"0\",\"y\":\"0\",\"z\":\"2.5\"},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":\"45\",\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"object\":{\"position\":{\"x\":\"0\",\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":\"2\"},\"backgroundRGBA\":\"EEEEEE\",\"background\":15658734}",
                                "description": "A rotation matrix is a 3x3 matrix that describes the rotation of an object.\n\n<br>\n\nFor rotation around the x-axis: \n```\n| 1   0          0           | \n| 0   cos(theta) -sin(theta) |\n| 0   sin(theta) cos(theta)  |\n```\n\nFor rotation around the y-axis:\n```\n| cos(theta)   0   sin(theta) |\n| 0            1   0          |\n| -sin(theta)  0   cos(theta) |\n```\n\nFor rotation around the z-axis:\n```\n| cos(theta) -sin(theta) 0 |\n| sin(theta) cos(theta)  0 |\n| 0          0           1 |\n```\n\nMultiply the rotation matrix with the object's coordinates: Once you have created the rotation matrix, you need to multiply it with the object's coordinates to apply the rotation. This can be done using matrix multiplication.\n\n<br>\n\nNote that if you want to perform multiple rotations on an object (for example, rotating it first around the x-axis and then around the y-axis), you need to multiply the rotation matrices in the order in which you want to apply them.\n\n### Task\nSequentially rotate an object 180 degrees along the X, Y, and Z axes, follow these steps:\n1. Divide the `progress` into three equal parts.\n2. In the first part, rotate the object 180 degrees along the X axis.\n3. In the second part, rotate the object 180 degrees along the Y axis.\n4. In the third part, rotate the object 180 degrees along the Z axis.",
                                "hints": [],
                                "restrictions": [],
                                "order": 18,
                                "cost": 5,
                                "threshold": 98,
                                "likes": 2,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": true,
                                "animationSteps": 12,
                                "animationStepTime": 1000,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "uniform float iTime;\n\nvarying vec3 vPos;\n\nvoid setPosition3D(mat3 transform) {\n  vec3 pos = transform * position.xyz;\n  vPos = pos;\n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n\nvoid main() {\n  float progress = abs(cos(iTime * 0.5) * 0.5 - 0.5);\n\n  setPosition3D(mat3(1.0));\n}\n",
                            "fragmentShader": "varying vec3 vPos;\n\nconst vec3 lightPos = vec3(0.0, 0.0, 5.0);\n\nvoid main() {\n  vec3 dx = dFdx(vPos);\n  vec3 dy = dFdy(vPos);\n  vec3 normal = normalize(cross(dx, dy));\n\n  vec3 lightDir = normalize(lightPos - vPos);\n  float t = dot(normal, lightDir) * 0.75 + 0.25;\n  \n  gl_FragColor = vec4(vec3(0.0, 0.55, 0.55) * t, 1.0);\n}\n",
                            "defaultVertexShader": "uniform float iTime;\n\nvarying vec3 vPos;\n\nvoid setPosition3D(mat3 transform) {\n  vec3 pos = transform * position.xyz;\n  vPos = pos;\n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n\nvoid main() {\n  float progress = abs(cos(iTime * 0.5) * 0.5 - 0.5);\n\n  setPosition3D(mat3(1.0));\n}\n",
                            "defaultFragmentShader": "varying vec3 vPos;\n\nconst vec3 lightPos = vec3(0.0, 0.0, 5.0);\n\nvoid main() {\n  vec3 dx = dFdx(vPos);\n  vec3 dy = dFdy(vPos);\n  vec3 normal = normalize(cross(dx, dy));\n\n  vec3 lightDir = normalize(lightPos - vPos);\n  float t = dot(normal, lightDir) * 0.75 + 0.25;\n  \n  gl_FragColor = vec4(vec3(0.0, 0.55, 0.55) * t, 1.0);\n}\n",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 123,
                        "slug": "homogeneous-coordinates",
                        "moduleId": 9,
                        "name": "Homogeneous Coordinates",
                        "order": 19,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 123,
                                "slug": "homogeneous-coordinates",
                                "moduleId": 9,
                                "name": "Homogeneous Coordinates",
                                "vertexShader": "uniform float iTime;\n\nvarying vec3 vPos;\n\nvoid setPosition3D(mat4 transform) {\n  vec4 pos = transform * vec4(position, 1.0);\n  vPos = pos.xyz;\n  gl_Position = projectionMatrix * viewMatrix * pos;\n}\n\nvoid main() {\n  mat4 transform = transpose(mat4(\n    vec4(cos(iTime), 0, sin(iTime), cos(iTime)),\n    vec4(0, 1, 0, sin(iTime)),\n    vec4(-sin(iTime), 0, cos(iTime), 0),\n    vec4(0, 0, 0, 1)\n  ));\n\n  setPosition3D(transform);\n}",
                                "fragmentShader": "varying vec3 vPos;\n\nconst vec3 lightPos = vec3(0.0, 0.0, 5.0);\n\nvoid main() {\n  vec3 dx = dFdx(vPos);\n  vec3 dy = dFdy(vPos);\n  vec3 normal = normalize(cross(dx, dy));\n\n  vec3 lightDir = normalize(lightPos - vPos);\n  float t = dot(normal, lightDir) * 0.75 + 0.25;\n  \n  gl_FragColor = vec4(vec3(0.0, 0.55, 0.55) * t, 1.0);\n}\n",
                                "defaultVertexShader": "uniform float iTime;\n\nvarying vec3 vPos;\n\nvoid setPosition3D(mat4 transform) {\n  vec4 pos = transform * vec4(position, 1.0);\n  vPos = pos.xyz;\n  gl_Position = projectionMatrix * viewMatrix * pos;\n}\n\nvoid main() {\n  mat4 transform = transpose(mat4(\n    vec4(1, 0, 0, 0),\n    vec4(0, 1, 0, 0),\n    vec4(0, 0, 1, 0),\n    vec4(0, 0, 0, 1)\n  ));\n\n  setPosition3D(transform);\n}\n",
                                "defaultFragmentShader": "varying vec3 vPos;\n\nconst vec3 lightPos = vec3(0.0, 0.0, 5.0);\n\nvoid main() {\n  vec3 dx = dFdx(vPos);\n  vec3 dy = dFdy(vPos);\n  vec3 normal = normalize(cross(dx, dy));\n\n  vec3 lightDir = normalize(lightPos - vPos);\n  float t = dot(normal, lightDir) * 0.75 + 0.25;\n  \n  gl_FragColor = vec4(vec3(0.0, 0.55, 0.55) * t, 1.0);\n}\n",
                                "vertexCodeEditable": true,
                                "fragmentCodeEditable": false,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":\"0\",\"y\":\"0\",\"z\":\"5\"},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":\"45\",\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"object\":{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":\"2\"},\"backgroundRGBA\":\"EEEEEE\",\"background\":15658734}",
                                "description": "To transform a point **P** from one coordinate system to another, we typically use the equation:\n\n```\nP' = MP + T (1)\n```\n\nHere, **M** is a 3x3 matrix that can scale and rotate the object. **T** is a 3D translation vector.\n\n<br>\n\nTo represent these transformations using a single mathematical entity, we can extend our vectors to four-dimensional homogeneous coordinates and use 4×4 matrices to transform them. We extend a 3D point **P** to four dimensions by setting its fourth coordinate, which we call the \"**w**\" coordinate, equal to 1. We then construct a 4×4 transformation matrix **F** that corresponds to the 3×3 matrix **M** and the 3D translation **T** as follows:\n\n```\nF = | M, T |\n    | 0, 1 |\n```\n\nMultiplying the matrix **F** by the vector *<Px, Py, Pz, 1>* transforms the **x**, **y**, and **z** coordinates of the vector in exactly the same way as Equation (1) and leaves a 1 in the **w** coordinate:\n\n```\n| m00, m01, m02, t0 |   |Px|\n| m10, m11, m12, t1 |   |Py|\n| m20, m21, m22, t2 | * |Pz|\n|   0,   0,   0,  1 |   |1 |\n\n=\n\n| m00 * Px + m01 * Py + m02 * Pz + t0 * 1 |\n| m10 * Px + m11 * Py + m12 * Pz + t1 * 1 |\n| m20 * Px + m21 * Py + m22 * Pz + t2 * 1 |\n|   0 * Px +   0 * Py +   0 * Pz +  1 * 1 |\n\n```\n\n### Task\nDefine a matrix that rotates an object about the y-axis counterclockwise in the local object space:\n\n<br>\n\n![](/files/homogeneous-coordinates-task-y.png)\n\n<br>\n\nand moves the object in a counterclockwise circular path in the X-Y plane:\n\n<br>\n\n![](/files/homogeneous-coordinates-task-z.png)\n\n<br>\n\nThe resulting transformation matrix should be passed to the `setPosition2D` function.",
                                "hints": [],
                                "restrictions": [],
                                "order": 19,
                                "cost": 5,
                                "threshold": 98,
                                "likes": 1,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": true,
                                "animationSteps": 6,
                                "animationStepTime": 1000,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "uniform float iTime;\n\nvarying vec3 vPos;\n\nvoid setPosition3D(mat4 transform) {\n  vec4 pos = transform * vec4(position, 1.0);\n  vPos = pos.xyz;\n  gl_Position = projectionMatrix * viewMatrix * pos;\n}\n\nvoid main() {\n  mat4 transform = transpose(mat4(\n    vec4(1, 0, 0, 0),\n    vec4(0, 1, 0, 0),\n    vec4(0, 0, 1, 0),\n    vec4(0, 0, 0, 1)\n  ));\n\n  setPosition3D(transform);\n}\n",
                            "fragmentShader": "varying vec3 vPos;\n\nconst vec3 lightPos = vec3(0.0, 0.0, 5.0);\n\nvoid main() {\n  vec3 dx = dFdx(vPos);\n  vec3 dy = dFdy(vPos);\n  vec3 normal = normalize(cross(dx, dy));\n\n  vec3 lightDir = normalize(lightPos - vPos);\n  float t = dot(normal, lightDir) * 0.75 + 0.25;\n  \n  gl_FragColor = vec4(vec3(0.0, 0.55, 0.55) * t, 1.0);\n}\n",
                            "defaultVertexShader": "uniform float iTime;\n\nvarying vec3 vPos;\n\nvoid setPosition3D(mat4 transform) {\n  vec4 pos = transform * vec4(position, 1.0);\n  vPos = pos.xyz;\n  gl_Position = projectionMatrix * viewMatrix * pos;\n}\n\nvoid main() {\n  mat4 transform = transpose(mat4(\n    vec4(1, 0, 0, 0),\n    vec4(0, 1, 0, 0),\n    vec4(0, 0, 1, 0),\n    vec4(0, 0, 0, 1)\n  ));\n\n  setPosition3D(transform);\n}\n",
                            "defaultFragmentShader": "varying vec3 vPos;\n\nconst vec3 lightPos = vec3(0.0, 0.0, 5.0);\n\nvoid main() {\n  vec3 dx = dFdx(vPos);\n  vec3 dy = dFdy(vPos);\n  vec3 normal = normalize(cross(dx, dy));\n\n  vec3 lightDir = normalize(lightPos - vPos);\n  float t = dot(normal, lightDir) * 0.75 + 0.25;\n  \n  gl_FragColor = vec4(vec3(0.0, 0.55, 0.55) * t, 1.0);\n}\n",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 103,
                        "slug": "normal-transform",
                        "moduleId": 9,
                        "name": "Normal Transform",
                        "order": 20,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 103,
                                "slug": "normal-transform",
                                "moduleId": 9,
                                "name": "Normal Transform",
                                "vertexShader": "uniform float iTime;\n\nvarying vec3 vNormal;\nvarying vec3 vPos;\n\nvec3 getNormal() {\n  return  normal; // vertex attribute\n}\n\nvoid main() {\n  float angle = iTime;\n  \n  vec4 r1 = vec4(cos(angle), -sin(angle), 0.0, 0.0);\n  vec4 r2 = vec4(sin(angle), cos(angle), 0.0, 0.0);\n  vec4 r3 = vec4(0.0, 0.0, 1.0, 0.0);\n  vec4 r4 = vec4(0.0, 0.0, 0.0, 1.0);\n  mat4 transform = transpose(mat4(r1, r2, r3, r4));\n  \n  vNormal = normalize(mat3(modelMatrix * transform) * getNormal());\n\n  mat4 mvp = projectionMatrix * viewMatrix * modelMatrix;\n  gl_Position = mvp * transform * vec4(position, 1.0);\n}",
                                "fragmentShader": "varying vec3 vNormal;\n\nvoid main() {\n  vec3 fragNormal = normalize(vNormal); \n  gl_FragColor = vec4(fragNormal, 1.0);\n}",
                                "defaultVertexShader": "uniform float iTime;\n\nvec3 getNormal() {\n  return  normal; // vertex attribute\n}\n\nvoid main() {\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "\nvoid main() {\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                                "vertexCodeEditable": true,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":\"0\",\"y\":\"0\",\"z\":\"2\"},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"object\":{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":\"0.5\",\"y\":\"0.5\",\"z\":0},\"scale\":{\"x\":\"1\",\"y\":1,\"z\":1},\"geometry\":\"2\"},\"backgroundRGBA\":\"EEEEEE\",\"background\":15658734}",
                                "description": "In addition to its position in space, a vertex belonging to a polygonal model usually carries additional information about how it fits into the surrounding surface. In particular, a vertex may have a *normal* vector associated with it. And when we transform a model, we need to transform not only the vertex positions, but these vectors as well.\n\n<br>\n\nLet **F** is a 4×4 matrix with which we transform a vertex position:\n\n```\nF = | M, T |\n    | 0, 1 |\n```\n\nHere, **M** is a 3x3 matrix that can scale and rotate the position. **T** is a 3D translation vector.\n\n<br>\n\nWe can use the matrix **F** to correctly transform the normal vector. But we must consider that the normal vectors are only direction vectors and do not represent a specific position in space. This means that translations should not have any effect on it.\n\n<br>\n\nTo skip the translation when transforming the normal vector we can:\n1. limit the matrix **F** to the matrix **M**;\n2. extend normal vector to four dimensions by setting its fourth coordinate to 0.\n\nMultiplying the matrix **F** by the vector *<Nx, Ny, Nz, 0>* scales and rotates the **x**, **y**, and **z** coordinates with no translation and leaves a 0 in the **w** coordinate:\n\n```\n| m00, m01, m02, t0 |   |Nx|\n| m10, m11, m12, t1 |   |Ny|\n| m20, m21, m22, t2 | * |Nz|\n|   0,   0,   0,  1 |   |0 |\n\n=\n\n| m00 * Nx + m01 * Ny + m02 * Nz + t0 * 0 |\n| m10 * Nx + m11 * Ny + m12 * Nz + t1 * 0 |\n| m20 * Nx + m21 * Ny + m22 * Nz + t2 * 0 |\n|   0 * Nx +   0 * Ny +   0 * Nz +  0 * 0 |\n```\n\n### Task\nDefine a matrix that rotates an object about the z-axis counterclockwise in the local object space using time as the angle:\n\n<br>\n\n![](/files/normal-transform-task-z.png)\n\n<br>\n\nThen apply the transformation (including `modelMatrix`) to the normal vector as well:\n\n<br>\n\n![](/files/normal-transform-task-normal.png)\n\n<br>\n\nUsing the `varying`, pass the normal value to the fragment shader and use it as the fragment color.\n\n<br>\n\nThe `normal` variable, like the `position`, is a vertex attribute, but contains information about the surface normal. It is available in the vertex shader as a global variable.",
                                "hints": [],
                                "restrictions": [],
                                "order": 20,
                                "cost": 5,
                                "threshold": 98,
                                "likes": 1,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": true,
                                "animationSteps": 6,
                                "animationStepTime": 1000,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "uniform float iTime;\n\nvec3 getNormal() {\n  return  normal; // vertex attribute\n}\n\nvoid main() {\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "\nvoid main() {\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "defaultVertexShader": "uniform float iTime;\n\nvec3 getNormal() {\n  return  normal; // vertex attribute\n}\n\nvoid main() {\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "\nvoid main() {\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 104,
                        "slug": "normal-in-non-uniform-scale",
                        "moduleId": 9,
                        "name": "Normal in Non-uniform Scale",
                        "order": 21,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 104,
                                "slug": "normal-in-non-uniform-scale",
                                "moduleId": 9,
                                "name": "Normal in Non-uniform Scale",
                                "vertexShader": "uniform float iTime;\n\nvarying vec3 vNormal;\n\nvec3 getNormal() {\n  return  normal; // vertex attribute\n}\n\nmat4 getModel() {\n  vec4 r1 = vec4(cos(iTime) + 2.0, 0.0, 0.0, 0.0);\n  vec4 r2 = vec4(0.0, 1.0, 0.0, 0.0);\n  vec4 r3 = vec4(0.0, 0.0, 1.0, 0.0);\n  vec4 r4 = vec4(0.0, 0.0, 0.0, 1.0);\n  mat4 transform = transpose(mat4(r1, r2, r3, r4));\n  \n  return modelMatrix * transform;\n}\n\nvoid main() {\n  mat4 model = getModel();\n  \n  vNormal = normalize(mat3(transpose(inverse(model))) * getNormal());\n  \n  gl_Position = projectionMatrix * viewMatrix * model * vec4(position, 1.0);\n}",
                                "fragmentShader": "varying vec3 vNormal;\n\nvoid main() {\n  vec3 fragNormal = normalize(vNormal);\n  gl_FragColor = vec4(fragNormal, 1.0);\n}",
                                "defaultVertexShader": "uniform float iTime;\n\nvarying vec3 vNormal;\n\nvec3 getNormal() {\n  return  normal; // vertex attribute\n}\n\nmat4 getModel() {\n  vec4 r1 = vec4(cos(iTime) + 2.0, 0.0, 0.0, 0.0);\n  vec4 r2 = vec4(0.0, 1.0, 0.0, 0.0);\n  vec4 r3 = vec4(0.0, 0.0, 1.0, 0.0);\n  vec4 r4 = vec4(0.0, 0.0, 0.0, 1.0);\n  mat4 transform = transpose(mat4(r1, r2, r3, r4));\n  \n  return modelMatrix * transform;\n}\n\nvoid main() {\n  mat4 model = getModel();\n  \n  vNormal = normalize(mat3(model) * getNormal());\n  \n  gl_Position = projectionMatrix * viewMatrix * model * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "varying vec3 vNormal;\n\nvoid main() {\n  vec3 fragNormal = normalize(vNormal);\n  \n  gl_FragColor = vec4(fragNormal, 1.0);\n}\n",
                                "vertexCodeEditable": true,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":\"0\",\"y\":\"0\",\"z\":\"1.25\"},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"object\":{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":\"0\",\"y\":\"0\",\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":\"3\"},\"backgroundRGBA\":\"EEEEEE\",\"background\":15658734}",
                                "description": "If **M** is a *3x3* matrix with which we transform a vertex position, then the same matrix **M** can be used to correctly transform the *normal* vector at that vertex.\n\n<br>\n\nHowever, if the **M** performs non-uniform scaling, it is not orthonormal anymore. And the transformed *normal* can often end up pointing in a direction that is not perpendicular to the transformed surface:\n\n<br>\n\n![](/files/normal-in-non-uniform-scale.png)\n\n<br>\n\nIn this case the *normal* vector must be transformed using the *inverse transpose* of the **M**:\n\n```\nn' = transpose(inverse(M)) * n\n```\n\nVectors that must be transformed in this way are called *covariant* vectors, and vectors that are transformed in the ordinary fashion using the matrix **M** (such as points) are called *contravariant* vectors.\n\n<br>\n\nIf the **M** is orthogonal, then:\n```\ninverse(M) == transpose(M)\n```\nAnd thus\n```\ntranspose(inverse(M)) == M\n```\n\nTherefore, the *inverse transpose* operation required to transform *normal* vectors can be avoided when **M** is known to be orthogonal.\n\n### Task\nConvert the normal vector correctly from model space to world using the `model` matrix.",
                                "hints": [],
                                "restrictions": [],
                                "order": 21,
                                "cost": 5,
                                "threshold": 98,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": true,
                                "animationSteps": 6,
                                "animationStepTime": 1000,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "uniform float iTime;\n\nvarying vec3 vNormal;\n\nvec3 getNormal() {\n  return  normal; // vertex attribute\n}\n\nmat4 getModel() {\n  vec4 r1 = vec4(cos(iTime) + 2.0, 0.0, 0.0, 0.0);\n  vec4 r2 = vec4(0.0, 1.0, 0.0, 0.0);\n  vec4 r3 = vec4(0.0, 0.0, 1.0, 0.0);\n  vec4 r4 = vec4(0.0, 0.0, 0.0, 1.0);\n  mat4 transform = transpose(mat4(r1, r2, r3, r4));\n  \n  return modelMatrix * transform;\n}\n\nvoid main() {\n  mat4 model = getModel();\n  \n  vNormal = normalize(mat3(model) * getNormal());\n  \n  gl_Position = projectionMatrix * viewMatrix * model * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "varying vec3 vNormal;\n\nvoid main() {\n  vec3 fragNormal = normalize(vNormal);\n  \n  gl_FragColor = vec4(fragNormal, 1.0);\n}\n",
                            "defaultVertexShader": "uniform float iTime;\n\nvarying vec3 vNormal;\n\nvec3 getNormal() {\n  return  normal; // vertex attribute\n}\n\nmat4 getModel() {\n  vec4 r1 = vec4(cos(iTime) + 2.0, 0.0, 0.0, 0.0);\n  vec4 r2 = vec4(0.0, 1.0, 0.0, 0.0);\n  vec4 r3 = vec4(0.0, 0.0, 1.0, 0.0);\n  vec4 r4 = vec4(0.0, 0.0, 0.0, 1.0);\n  mat4 transform = transpose(mat4(r1, r2, r3, r4));\n  \n  return modelMatrix * transform;\n}\n\nvoid main() {\n  mat4 model = getModel();\n  \n  vNormal = normalize(mat3(model) * getNormal());\n  \n  gl_Position = projectionMatrix * viewMatrix * model * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "varying vec3 vNormal;\n\nvoid main() {\n  vec3 fragNormal = normalize(vNormal);\n  \n  gl_FragColor = vec4(fragNormal, 1.0);\n}\n",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 150,
                        "slug": "clip-plane",
                        "moduleId": 9,
                        "name": "Clip Plane",
                        "order": 25,
                        "cost": 10,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 150,
                                "slug": "clip-plane",
                                "moduleId": 9,
                                "name": "Clip Plane",
                                "vertexShader": "uniform float iTime;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec4 vClipPlane;\n\nvoid main() {\n  vec4 worldPos = modelMatrix * vec4(position, 1.0);\n  \n  vPos = worldPos.xyz;\n  vNormal = normalize(mat3(transpose(inverse(modelMatrix))) * normal);\n\n  vClipPlane = vec4(normalize(modelMatrix[0].xyz * -1.0), (-cos(iTime) * 1.5));\n  \n  gl_Position = projectionMatrix * viewMatrix * worldPos;\n}\n",
                                "fragmentShader": "varying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec4 vClipPlane;\n\nconst vec4 color = vec4(0.38, 0.12, 0.93, 1.0);\n\nvec4 applyLight(vec4 color);\n\nvoid main() {\n  float clipDistance = dot(vec4(vPos, 1.0), vClipPlane);\n  float alpha = mix(0.2, 1.0, step(0.0, clipDistance));\n  \n  gl_FragColor = applyLight(vec4(color.rgb, alpha));\n}\n\n///////////////////////\n//////// UTILS ////////\n///////////////////////\n\nvec4 applyLight(vec4 color) {\n  vec3  lightPos = vec3(-0.75, 0.25, 3.0);\n  vec3  normal   = normalize(vNormal);\n  vec3  lightDir = normalize(lightPos - vPos);\n  float diffuse  = dot(normalize(vNormal), lightDir) * 0.5 + 0.5;\n\n  return vec4(color.rgb * diffuse, color.a);\n}",
                                "defaultVertexShader": "uniform float iTime;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\n\nvoid main() {\n  vec4 worldPos = modelMatrix * vec4(position, 1.0);\n  \n  vPos = worldPos.xyz;\n  vNormal = normalize(mat3(transpose(inverse(modelMatrix))) * normal);\n\n  float clipPlaneDistance = -cos(iTime) * 1.5;\n  vec4  clipPlane = vec4(0.0, 0.0, 0.0, clipPlaneDistance);\n  \n  gl_Position = projectionMatrix * viewMatrix * worldPos;\n}\n",
                                "defaultFragmentShader": "varying vec3 vPos;\nvarying vec3 vNormal;\n\nconst vec4 color = vec4(0.38, 0.12, 0.93, 1.0);\n\nvec4 applyLight(vec4 color);\n\nvoid main() {\n  gl_FragColor = applyLight(color);\n}\n\n///////////////////////\n//////// UTILS ////////\n///////////////////////\n\nvec4 applyLight(vec4 color) {\n  vec3  lightPos = vec3(-0.75, 0.25, 3.0);\n  vec3  normal   = normalize(vNormal);\n  vec3  lightDir = normalize(lightPos - vPos);\n  float diffuse  = dot(normalize(vNormal), lightDir) * 0.5 + 0.5;\n\n  return vec4(color.rgb * diffuse, color.a);\n}",
                                "vertexCodeEditable": true,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":0,\"y\":0,\"z\":2.8},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":\"45\",\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0.3,\"y\":0.05,\"z\":0},\"rotation\":{\"x\":\"0.5\",\"y\":0.75,\"z\":0},\"scale\":{\"x\":\"3\",\"y\":1,\"z\":1},\"geometry\":\"2\",\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"backgroundRGBA\":\"EEEEEE\",\"background\":15658734}",
                                "description": "In computer graphics, a clip plane is a mathematical construct that defines a boundary in 3D space beyond which geometry is not rendered. It is commonly used to control the visibility of objects by clipping away portions of the scene that fall outside the specified plane. Clip planes are essential for various rendering techniques, such as culling, slicing, and creating cross-section views of 3D objects.\n\n<br>\n\nMathematically, a clip plane is represented by a plane equation in the form:\n\n<br>\n\n*Ax + By + Cz + D* = 0, \n\n<br>\n\nwhere *A*, *B*, and *C* are the *x*, *y*, and *z* components of the normal vector **N**, and\n*D* = −**N** ⋅ **P** is the distance from the origin. The normal vector **N** determines the orientation of the plane, while the distance *D* controls its position in space.\n\n<br>\n\n![Image 1 - Plane](/files/clip-plane-1.png)\n\n<br>\n\nThe normal vector **N** is often normalized to unit length because in that case the equation\n\n<br>\n\n*d* = **N** ⋅ **Q** + *D*\n\n<br>\n\ngives the signed distance from the plane to an arbitrary point **Q**:\n\n<br>\n\n![Image 2 - Signed Distance](/files/normal-plane-point.png)\n\n1. If *d* = 0, then the point **Q** lies in the plane. \n2. If *d* > 0, then the point **Q** lies on the positive side of the plane since **Q** would be on the side in which the normal vector **N** points. \n3. if *d* < 0, then the point **Q** lies on the negative side of the plane.\n\nThe plane can also be defined by a point **P** and a normal vector **N**:\n\n<br>\n\n**N** ⋅ (**Q** − **P**) = 0,\n\n<br>\n\nwhere **Q** is the set of points on the plane.\n\n<br>\n\n![Image 3 - Plane is defined by the set of points](/files/clip-plane-0.png)\n\n### Task\nUse the inverted right (left) vector from the model matrix to establish the orientation of the clipping plane. The clipping distance is specified in the code and the value changes over time.\n\n<br>\n\nDetermine the position of 3D model fragments in relation to the clipping plane. If the fragment falls outside the plane, set its transparency to 20%.",
                                "hints": [],
                                "restrictions": [],
                                "order": 25,
                                "cost": 10,
                                "threshold": 99,
                                "likes": 2,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": true,
                                "animationSteps": 12,
                                "animationStepTime": 500,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "uniform float iTime;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\n\nvoid main() {\n  vec4 worldPos = modelMatrix * vec4(position, 1.0);\n  \n  vPos = worldPos.xyz;\n  vNormal = normalize(mat3(transpose(inverse(modelMatrix))) * normal);\n\n  float clipPlaneDistance = -cos(iTime) * 1.5;\n  vec4  clipPlane = vec4(0.0, 0.0, 0.0, clipPlaneDistance);\n  \n  gl_Position = projectionMatrix * viewMatrix * worldPos;\n}\n",
                            "fragmentShader": "varying vec3 vPos;\nvarying vec3 vNormal;\n\nconst vec4 color = vec4(0.38, 0.12, 0.93, 1.0);\n\nvec4 applyLight(vec4 color);\n\nvoid main() {\n  gl_FragColor = applyLight(color);\n}\n\n///////////////////////\n//////// UTILS ////////\n///////////////////////\n\nvec4 applyLight(vec4 color) {\n  vec3  lightPos = vec3(-0.75, 0.25, 3.0);\n  vec3  normal   = normalize(vNormal);\n  vec3  lightDir = normalize(lightPos - vPos);\n  float diffuse  = dot(normalize(vNormal), lightDir) * 0.5 + 0.5;\n\n  return vec4(color.rgb * diffuse, color.a);\n}",
                            "defaultVertexShader": "uniform float iTime;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\n\nvoid main() {\n  vec4 worldPos = modelMatrix * vec4(position, 1.0);\n  \n  vPos = worldPos.xyz;\n  vNormal = normalize(mat3(transpose(inverse(modelMatrix))) * normal);\n\n  float clipPlaneDistance = -cos(iTime) * 1.5;\n  vec4  clipPlane = vec4(0.0, 0.0, 0.0, clipPlaneDistance);\n  \n  gl_Position = projectionMatrix * viewMatrix * worldPos;\n}\n",
                            "defaultFragmentShader": "varying vec3 vPos;\nvarying vec3 vNormal;\n\nconst vec4 color = vec4(0.38, 0.12, 0.93, 1.0);\n\nvec4 applyLight(vec4 color);\n\nvoid main() {\n  gl_FragColor = applyLight(color);\n}\n\n///////////////////////\n//////// UTILS ////////\n///////////////////////\n\nvec4 applyLight(vec4 color) {\n  vec3  lightPos = vec3(-0.75, 0.25, 3.0);\n  vec3  normal   = normalize(vNormal);\n  vec3  lightDir = normalize(lightPos - vPos);\n  float diffuse  = dot(normalize(vNormal), lightDir) * 0.5 + 0.5;\n\n  return vec4(color.rgb * diffuse, color.a);\n}",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 152,
                        "slug": "clip-plane-dissolve",
                        "moduleId": 9,
                        "name": "Clip Plane - Dissolve",
                        "order": 26,
                        "cost": 20,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 152,
                                "slug": "clip-plane-dissolve",
                                "moduleId": 9,
                                "name": "Clip Plane - Dissolve",
                                "vertexShader": "uniform float iTime;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec4 vClipPlane;\n\nvoid main() {\n  vec4 worldPos = modelMatrix * vec4(position, 1.0);\n  \n  vPos = worldPos.xyz;\n  vNormal = normalize(mat3(transpose(inverse(modelMatrix))) * normal);\n\n  vClipPlane = vec4(normalize(modelMatrix[0].xyz * -1.0), (cos(iTime * 0.8) * 2.0));\n  \n  gl_Position = projectionMatrix * viewMatrix * worldPos;\n}\n",
                                "fragmentShader": "varying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec4 vClipPlane;\n\nconst vec4 color1 = vec4(0.38, 0.12, 0.93, 1.0);\nconst vec4 color2 = vec4(1.00, 0.90, 0.30, 1.0);\nconst vec4 color3 = vec4(1.00, 0.30, 0.30, 1.0);\n\nvec4 applyLight(vec4 color);\nfloat noise(vec2 st);\n\nvoid main() {\n  float noiseValue   = noise(vPos.xy * 5.0);\n  float clipDistance = dot(vec4(vPos, 1.0), vClipPlane) - noiseValue;\n\n  vec4 color = applyLight(color1);\n  if (clipDistance <= 0.2) {\n    color = mix(color2, color3, clipDistance / 0.2);\n  }\n  color.a = step(0.0, clipDistance);\n  \n  gl_FragColor = color;\n}\n\n///////////////////////\n//////// UTILS ////////\n///////////////////////\n\nvec4 applyLight(vec4 color) {\n  vec3  lightPos = vec3(-0.75, 0.25, 3.0);\n  vec3  normal   = normalize(vNormal);\n  vec3  lightDir = normalize(lightPos - vPos);\n  float diffuse  = dot(normalize(vNormal), lightDir) * 0.5 + 0.5;\n\n  return vec4(color.rgb * diffuse, color.a);\n}\n\nvec2 random2(vec2 st) {\n  float d1 = dot(st, vec2(12.3, 32.1));\n  float d2 = dot(st, vec2(45.6, 65.4));\n  \n  st = vec2(d1, d2);\n  return fract(sin(st) * 78.9) * 2.0 - 1.0;\n}\n\nfloat noise(vec2 st) {\n  vec2 i = floor(st);\n  vec2 f = fract(st);\n\n  vec2 u = smoothstep(0.0, 1.0, f);\n  \n  float d1 = dot(random2(i + vec2(0.0, 0.0)), f - vec2(0.0, 0.0));\n  float d2 = dot(random2(i + vec2(1.0, 0.0)), f - vec2(1.0, 0.0));\n  float d3 = dot(random2(i + vec2(0.0, 1.0)), f - vec2(0.0, 1.0));\n  float d4 = dot(random2(i + vec2(1.0, 1.0)), f - vec2(1.0, 1.0));\n  return mix(mix(d1, d2, u.x), mix(d3, d4, u.x), u.y);\n}\n",
                                "defaultVertexShader": "uniform float iTime;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\n\nvoid main() {\n  vec4 worldPos = modelMatrix * vec4(position, 1.0);\n  \n  vPos = worldPos.xyz;\n  vNormal = normalize(mat3(transpose(inverse(modelMatrix))) * normal);\n\n  float clipPlaneDistance = cos(iTime * 0.8) * 2.0;\n  vec4  clipPlane = vec4(0.0, 0.0, 0.0, clipPlaneDistance);\n  \n  gl_Position = projectionMatrix * viewMatrix * worldPos;\n}\n",
                                "defaultFragmentShader": "varying vec3 vPos;\nvarying vec3 vNormal;\n\nconst vec4 color1 = vec4(0.38, 0.12, 0.93, 1.0);\nconst vec4 color2 = vec4(1.00, 0.90, 0.30, 1.0);\nconst vec4 color3 = vec4(1.00, 0.30, 0.30, 1.0);\n\nvec4 applyLight(vec4 color);\nfloat noise(vec2 st);\n\nvoid main() {\n  float noiseValue = noise(vPos.xy * 5.0);\n\n  vec4 color = applyLight(color1);\n  \n  gl_FragColor = color;\n}\n\n///////////////////////\n//////// UTILS ////////\n///////////////////////\n\nvec4 applyLight(vec4 color) {\n  vec3  lightPos = vec3(-0.75, 0.25, 3.0);\n  vec3  normal   = normalize(vNormal);\n  vec3  lightDir = normalize(lightPos - vPos);\n  float diffuse  = dot(normalize(vNormal), lightDir) * 0.5 + 0.5;\n\n  return vec4(color.rgb * diffuse, color.a);\n}\n\nvec2 random2(vec2 st) {\n  float d1 = dot(st, vec2(12.3, 32.1));\n  float d2 = dot(st, vec2(45.6, 65.4));\n  \n  st = vec2(d1, d2);\n  return fract(sin(st) * 78.9) * 2.0 - 1.0;\n}\n\nfloat noise(vec2 st) {\n  vec2 i = floor(st);\n  vec2 f = fract(st);\n\n  vec2 u = smoothstep(0.0, 1.0, f);\n  \n  float d1 = dot(random2(i + vec2(0.0, 0.0)), f - vec2(0.0, 0.0));\n  float d2 = dot(random2(i + vec2(1.0, 0.0)), f - vec2(1.0, 0.0));\n  float d3 = dot(random2(i + vec2(0.0, 1.0)), f - vec2(0.0, 1.0));\n  float d4 = dot(random2(i + vec2(1.0, 1.0)), f - vec2(1.0, 1.0));\n  return mix(mix(d1, d2, u.x), mix(d3, d4, u.x), u.y);\n}\n",
                                "vertexCodeEditable": true,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":\"0\",\"y\":\"0\",\"z\":2.8},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":\"45\",\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0.3,\"y\":0.05,\"z\":0},\"rotation\":{\"x\":\"0.5\",\"y\":0.75,\"z\":0},\"scale\":{\"x\":\"3\",\"y\":1,\"z\":1},\"geometry\":\"2\",\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"backgroundRGBA\":\"EEEEEE\",\"background\":15658734}",
                                "description": "In computer graphics, a clip plane is a mathematical construct that defines a boundary in 3D space beyond which geometry is not rendered. It is commonly used to control the visibility of objects by clipping away portions of the scene that fall outside the specified plane. Clip planes are essential for various rendering techniques, such as culling, slicing, and creating cross-section views of 3D objects.\n\n<br>\n\nMathematically, a clip plane is represented by a plane equation in the form:\n\n<br>\n\n*Ax + By + Cz + D* = 0, \n\n<br>\n\nwhere *A*, *B*, and *C* are the *x*, *y*, and *z* components of the normal vector **N**, and\n*D* = −**N** ⋅ **P** is the distance from the origin. The normal vector **N** determines the orientation of the plane, while the distance *D* controls its position in space.\n\n<br>\n\n![Image 1 - Plane](/files/clip-plane-1.png)\n\n<br>\n\nThe normal vector **N** is often normalized to unit length because in that case the equation\n\n<br>\n\n*d* = **N** ⋅ **Q** + *D*\n\n<br>\n\ngives the signed distance from the plane to an arbitrary point **Q**:\n\n<br>\n\n![Image 2 - Signed Distance](/files/normal-plane-point.png)\n\n1. If *d* = 0, then the point **Q** lies in the plane. \n2. If *d* > 0, then the point **Q** lies on the positive side of the plane since **Q** would be on the side in which the normal vector **N** points. \n3. if *d* < 0, then the point **Q** lies on the negative side of the plane.\n\nThe plane can also be defined by a point **P** and a normal vector **N**:\n\n<br>\n\n**N** ⋅ (**Q** − **P**) = 0,\n\n<br>\n\nwhere **Q** is the set of points on the plane.\n\n<br>\n\n![Image 3 - Plane is defined by the set of points](/files/clip-plane-0.png)\n\n### Task\nUse the inverted right (left) vector from the model matrix to establish the orientation of the clipping plane. The clipping distance is specified in the code and the value changes over time.\n\nDetermine the position of 3D model fragments in relation to the clipping plane: \n\n1. If the fragment falls outside the plane, set its transparency to 0%.\n\n2. If the fragment is inside the clipping plane, and the distance of the fragment from the plane is in the interval [0.0; 0.2], fill in the fragments with a linear gradient using the `color2` and `color3` variables provided in the fragment code. Do not apply lighting to this segment.\n\n\n![Image 1 - Boundary Gradient](/files/clip-plane-dissolve-gradient.png)\n\n\n3. Distort the fragment's distance from the clipping plane using the noise value to bend clipping boundary. Play with the noise sign to reproduce the effect.",
                                "hints": [],
                                "restrictions": [],
                                "order": 26,
                                "cost": 20,
                                "threshold": 99,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": true,
                                "animationSteps": 10,
                                "animationStepTime": 500,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "uniform float iTime;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\n\nvoid main() {\n  vec4 worldPos = modelMatrix * vec4(position, 1.0);\n  \n  vPos = worldPos.xyz;\n  vNormal = normalize(mat3(transpose(inverse(modelMatrix))) * normal);\n\n  float clipPlaneDistance = cos(iTime * 0.8) * 2.0;\n  vec4  clipPlane = vec4(0.0, 0.0, 0.0, clipPlaneDistance);\n  \n  gl_Position = projectionMatrix * viewMatrix * worldPos;\n}\n",
                            "fragmentShader": "varying vec3 vPos;\nvarying vec3 vNormal;\n\nconst vec4 color1 = vec4(0.38, 0.12, 0.93, 1.0);\nconst vec4 color2 = vec4(1.00, 0.90, 0.30, 1.0);\nconst vec4 color3 = vec4(1.00, 0.30, 0.30, 1.0);\n\nvec4 applyLight(vec4 color);\nfloat noise(vec2 st);\n\nvoid main() {\n  float noiseValue = noise(vPos.xy * 5.0);\n\n  vec4 color = applyLight(color1);\n  \n  gl_FragColor = color;\n}\n\n///////////////////////\n//////// UTILS ////////\n///////////////////////\n\nvec4 applyLight(vec4 color) {\n  vec3  lightPos = vec3(-0.75, 0.25, 3.0);\n  vec3  normal   = normalize(vNormal);\n  vec3  lightDir = normalize(lightPos - vPos);\n  float diffuse  = dot(normalize(vNormal), lightDir) * 0.5 + 0.5;\n\n  return vec4(color.rgb * diffuse, color.a);\n}\n\nvec2 random2(vec2 st) {\n  float d1 = dot(st, vec2(12.3, 32.1));\n  float d2 = dot(st, vec2(45.6, 65.4));\n  \n  st = vec2(d1, d2);\n  return fract(sin(st) * 78.9) * 2.0 - 1.0;\n}\n\nfloat noise(vec2 st) {\n  vec2 i = floor(st);\n  vec2 f = fract(st);\n\n  vec2 u = smoothstep(0.0, 1.0, f);\n  \n  float d1 = dot(random2(i + vec2(0.0, 0.0)), f - vec2(0.0, 0.0));\n  float d2 = dot(random2(i + vec2(1.0, 0.0)), f - vec2(1.0, 0.0));\n  float d3 = dot(random2(i + vec2(0.0, 1.0)), f - vec2(0.0, 1.0));\n  float d4 = dot(random2(i + vec2(1.0, 1.0)), f - vec2(1.0, 1.0));\n  return mix(mix(d1, d2, u.x), mix(d3, d4, u.x), u.y);\n}\n",
                            "defaultVertexShader": "uniform float iTime;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\n\nvoid main() {\n  vec4 worldPos = modelMatrix * vec4(position, 1.0);\n  \n  vPos = worldPos.xyz;\n  vNormal = normalize(mat3(transpose(inverse(modelMatrix))) * normal);\n\n  float clipPlaneDistance = cos(iTime * 0.8) * 2.0;\n  vec4  clipPlane = vec4(0.0, 0.0, 0.0, clipPlaneDistance);\n  \n  gl_Position = projectionMatrix * viewMatrix * worldPos;\n}\n",
                            "defaultFragmentShader": "varying vec3 vPos;\nvarying vec3 vNormal;\n\nconst vec4 color1 = vec4(0.38, 0.12, 0.93, 1.0);\nconst vec4 color2 = vec4(1.00, 0.90, 0.30, 1.0);\nconst vec4 color3 = vec4(1.00, 0.30, 0.30, 1.0);\n\nvec4 applyLight(vec4 color);\nfloat noise(vec2 st);\n\nvoid main() {\n  float noiseValue = noise(vPos.xy * 5.0);\n\n  vec4 color = applyLight(color1);\n  \n  gl_FragColor = color;\n}\n\n///////////////////////\n//////// UTILS ////////\n///////////////////////\n\nvec4 applyLight(vec4 color) {\n  vec3  lightPos = vec3(-0.75, 0.25, 3.0);\n  vec3  normal   = normalize(vNormal);\n  vec3  lightDir = normalize(lightPos - vPos);\n  float diffuse  = dot(normalize(vNormal), lightDir) * 0.5 + 0.5;\n\n  return vec4(color.rgb * diffuse, color.a);\n}\n\nvec2 random2(vec2 st) {\n  float d1 = dot(st, vec2(12.3, 32.1));\n  float d2 = dot(st, vec2(45.6, 65.4));\n  \n  st = vec2(d1, d2);\n  return fract(sin(st) * 78.9) * 2.0 - 1.0;\n}\n\nfloat noise(vec2 st) {\n  vec2 i = floor(st);\n  vec2 f = fract(st);\n\n  vec2 u = smoothstep(0.0, 1.0, f);\n  \n  float d1 = dot(random2(i + vec2(0.0, 0.0)), f - vec2(0.0, 0.0));\n  float d2 = dot(random2(i + vec2(1.0, 0.0)), f - vec2(1.0, 0.0));\n  float d3 = dot(random2(i + vec2(0.0, 1.0)), f - vec2(0.0, 1.0));\n  float d4 = dot(random2(i + vec2(1.0, 1.0)), f - vec2(1.0, 1.0));\n  return mix(mix(d1, d2, u.x), mix(d3, d4, u.x), u.y);\n}\n",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    }
                ],
                "cover": true,
                "pageHeaderImage": true,
                "fullDesc": "This module is designed for developers who want to deepen their knowledge of vertex shaders and the graphics pipeline. You will learn how vertex shaders work, how geometry is processed, and what transformations are applied in space to render a complete scene with objects. Each topic includes theoretical material and a practical task that can be completed directly on the website.",
                "skillsDesc": "how vertex shaders work and their role in the graphics pipeline.<br>the main stages of the graphics pipeline and their interactions.<br>how complex objects are formed from polygons and how to use them to create detailed models.<br>how to work with geometry, including creating and manipulating vertices and primitives.<br>transformation techniques such as translation, scaling, and rotation.",
                "importanceDesc": "Understanding the workings of vertex shaders and the graphics pipeline is crucial for creating complex and realistic 3D scenes. This knowledge will help you effectively work with geometry, apply various transformations, and optimize the rendering process. It is essential for game development, animation, data visualization, and other graphical applications.",
                "certifiable": false,
                "images": [
                    "img-1.png",
                    "img-2.png",
                    "img-3.png",
                    "img-4.png",
                    "img-5.png"
                ]
            }
        },
        {
            "id": 6,
            "slug": "lighting-basics",
            "name": "Lighting Basics",
            "description": "Study fundamental lighting models used in computer graphics to simulate realistic lighting effects.",
            "tasks": 19,
            "acceptedTasks": 0,
            "isOpen": false,
            "order": 3,
            "locked": false,
            "cover": true,
            "child": {
                "id": 6,
                "slug": "lighting-basics",
                "name": "Lighting Basics",
                "description": "Study fundamental lighting models used in computer graphics to simulate realistic lighting effects.",
                "order": 3,
                "createdBy": {
                    "id": 3,
                    "name": "Alexander"
                },
                "locked": false,
                "tasks": [
                    {
                        "id": 58,
                        "slug": "colors",
                        "moduleId": 6,
                        "name": "Colors",
                        "order": 0,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": 0,
                        "premium": false,
                        "child": {
                            "task": {
                                "id": 58,
                                "slug": "colors",
                                "moduleId": 6,
                                "name": "Colors",
                                "vertexShader": "uniform float iTime;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nmat4 getModel() {\n  float angle = iTime;\n  \n  vec4 r1 = vec4(cos(angle), 0.0, sin(angle), 0.0);\n  vec4 r2 = vec4(0.0, 1.0, 0.0, 0.0);\n  vec4 r3 = vec4(-sin(angle), 0.0, cos(angle), 0.0);\n  vec4 r4 = vec4(0.0, 0.0, 0.0, 1.0);\n  mat4 transform = transpose(mat4(r1, r2, r3, r4));\n  \n  return modelMatrix * transform;\n}\n\nvoid main() {\n  mat4 model = getModel();\n  \n  vUv = uv;\n  vPos = vec3(model * vec4(position, 1.0));\n  \n  vNormal = normalize(mat3(transpose(inverse(model))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * model * vec4(position, 1.0);\n}",
                                "fragmentShader": "uniform sampler2D iChannel0;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vec3 lightColor = vec3(1.0, 1.0, 0.0);\n  vec3 objectColor = texture2D(iChannel0, vUv).rgb;\n\n  gl_FragColor = vec4(objectColor * lightColor, 1.0);\n}",
                                "defaultVertexShader": "uniform float iTime;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nmat4 getModel() {\n  float angle = iTime;\n  \n  vec4 r1 = vec4(cos(angle), 0.0, sin(angle), 0.0);\n  vec4 r2 = vec4(0.0, 1.0, 0.0, 0.0);\n  vec4 r3 = vec4(-sin(angle), 0.0, cos(angle), 0.0);\n  vec4 r4 = vec4(0.0, 0.0, 0.0, 1.0);\n  mat4 transform = transpose(mat4(r1, r2, r3, r4));\n  \n  return modelMatrix * transform;\n}\n\nvoid main() {\n  mat4 model = getModel();\n  \n  vUv = uv;\n  vPos = vec3(model * vec4(position, 1.0));\n  \n  vNormal = normalize(mat3(transpose(inverse(model))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * model * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform sampler2D iChannel0;\n\nvarying vec2 vUv;\n\nvoid main() {\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":\"0\",\"y\":\"0\",\"z\":\"2\"},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":\"45\",\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"object\":{\"position\":{\"x\":0,\"y\":\"-0.15\",\"z\":0},\"rotation\":{\"x\":\"-0.4\",\"y\":\"0\",\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":\"2\"},\"backgroundRGBA\":\"CCCCCC\",\"background\":13421772}",
                                "description": "The color of an object we see in real life is not the color it actually has, but is the color reflected from the object. The white sunlight is a collection of all the visible colors and the object absorbs a large portion of them. It reflects only those colors that represent the object's color, and we perceive their combination.\n\n<br>\n\n![](/files/colors-white-light.png)\n\n<br>\n\nIf we remove from the light the components that are reflected from the illuminated object, the color of the object perceived by the observer will change.\n\n<br>\n\n![](/files/colors-green-light.png)\n\n<br>\n\n<br>\nWe get the resulting color vector by doing a component-wise multiplication between the light and object color vectors:\n\n```\nReflectedColor = LightColor * ObjectColor\n```\n\n### Task\nGiven a cube, bind the texture from `iChannel0` to the object and calculate the color perceived by an observer. The light color is `(1.0, 1.0, 0.0)`.\n\n<br>\n\nHere you can learn how to bind a texture to an object: [texture coordinates](https://shader-learning.com/module-training/9/task/149)\n\n<br>",
                                "hints": [],
                                "restrictions": [],
                                "order": 0,
                                "cost": 5,
                                "threshold": 95,
                                "likes": 3,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [
                                    {
                                        "index": 0
                                    }
                                ],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": false
                            },
                            "vertexShader": "uniform float iTime;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nmat4 getModel() {\n  float angle = iTime;\n  \n  vec4 r1 = vec4(cos(angle), 0.0, sin(angle), 0.0);\n  vec4 r2 = vec4(0.0, 1.0, 0.0, 0.0);\n  vec4 r3 = vec4(-sin(angle), 0.0, cos(angle), 0.0);\n  vec4 r4 = vec4(0.0, 0.0, 0.0, 1.0);\n  mat4 transform = transpose(mat4(r1, r2, r3, r4));\n  \n  return modelMatrix * transform;\n}\n\nvoid main() {\n  mat4 model = getModel();\n  \n  vUv = uv;\n  vPos = vec3(model * vec4(position, 1.0));\n  \n  vNormal = normalize(mat3(transpose(inverse(model))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * model * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform sampler2D iChannel0;\n\nvarying vec2 vUv;\n\nvoid main() {\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "defaultVertexShader": "uniform float iTime;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nmat4 getModel() {\n  float angle = iTime;\n  \n  vec4 r1 = vec4(cos(angle), 0.0, sin(angle), 0.0);\n  vec4 r2 = vec4(0.0, 1.0, 0.0, 0.0);\n  vec4 r3 = vec4(-sin(angle), 0.0, cos(angle), 0.0);\n  vec4 r4 = vec4(0.0, 0.0, 0.0, 1.0);\n  mat4 transform = transpose(mat4(r1, r2, r3, r4));\n  \n  return modelMatrix * transform;\n}\n\nvoid main() {\n  mat4 model = getModel();\n  \n  vUv = uv;\n  vPos = vec3(model * vec4(position, 1.0));\n  \n  vNormal = normalize(mat3(transpose(inverse(model))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * model * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform sampler2D iChannel0;\n\nvarying vec2 vUv;\n\nvoid main() {\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 108,
                        "slug": "ambient-lighting",
                        "moduleId": 6,
                        "name": "Ambient Lighting",
                        "order": 1,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": true,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 108,
                                "slug": "ambient-lighting",
                                "moduleId": 6,
                                "name": "Ambient Lighting",
                                "vertexShader": "uniform float iTime;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nmat4 getModel() {\n  float angle = iTime;\n  \n  vec4 r1 = vec4(cos(angle), 0.0, sin(angle), 0.0);\n  vec4 r2 = vec4(0.0, 1.0, 0.0, 0.0);\n  vec4 r3 = vec4(-sin(angle), 0.0, cos(angle), 0.0);\n  vec4 r4 = vec4(0.0, 0.0, 0.0, 1.0);\n  mat4 transform = transpose(mat4(r1, r2, r3, r4));\n  \n  return modelMatrix * transform;\n}\n\nvoid main() {\n  mat4 model = getModel();\n  \n  vUv = uv;\n  vPos = vec3(model * vec4(position, 1.0));\n  \n  vNormal = normalize(mat3(transpose(inverse(model))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * model * vec4(position, 1.0);\n}",
                                "fragmentShader": "uniform sampler2D iChannel0;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vec3 objectColor = texture2D(iChannel0, vUv).rgb;\n  vec3 lightColor = vec3(1.0, 1.0, 0.0);\n  \n  float ambient = 0.5;\n  \n  gl_FragColor = vec4(ambient * objectColor * lightColor, 1.0);\n}",
                                "defaultVertexShader": "uniform float iTime;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nmat4 getModel() {\n  float angle = iTime;\n  \n  vec4 r1 = vec4(cos(angle), 0.0, sin(angle), 0.0);\n  vec4 r2 = vec4(0.0, 1.0, 0.0, 0.0);\n  vec4 r3 = vec4(-sin(angle), 0.0, cos(angle), 0.0);\n  vec4 r4 = vec4(0.0, 0.0, 0.0, 1.0);\n  mat4 transform = transpose(mat4(r1, r2, r3, r4));\n  \n  return modelMatrix * transform;\n}\n\nvoid main() {\n  mat4 model = getModel();\n  \n  vUv = uv;\n  vPos = vec3(model * vec4(position, 1.0));\n  \n  vNormal = normalize(mat3(transpose(inverse(model))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * model * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform sampler2D iChannel0;\n\nvarying vec2 vUv;\n\nvoid main() {\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":\"0\",\"y\":\"0\",\"z\":\"2\"},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":\"45\",\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":\"-0.15\",\"z\":0},\"rotation\":{\"x\":\"-0.4\",\"y\":\"0\",\"z\":\"0\"},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":\"2\",\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"backgroundRGBA\":\"CCCCCC\",\"background\":13421772}",
                                "description": "Ambient Light is simplistic model of global illumination. It gives the impression that there is always some **scattered light**, even if there is no direct light source.\n\n<br>\n\n![](/files/ambient-lighting.png)\n\n<br>\n\n*Scattered light is lighting that is obtained by reflection of light rays from different surfaces: ceiling, floor, walls. Such light evenly and equally illuminates all surfaces of the object, as a result of which there are no shadows, glare and reflexes on them.*\n\n<br>\n\nTo add ambient lighting to the scene, we calculate the product of the light, the object color and the ambient light factor. Usually the ambient light factor is a small value less than 1.0\n\n### Task\nGiven a cube. It is necessary to bind the texture from `iChannel0` to the object and apply ambient lighting. The light color is `(1.0, 1.0, 0.0)`, ambient factor is `0.5`.",
                                "hints": [],
                                "restrictions": [],
                                "order": 1,
                                "cost": 5,
                                "threshold": 95,
                                "likes": 1,
                                "dislikes": 1,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [
                                    {
                                        "index": 0
                                    }
                                ],
                                "animated": true,
                                "animationSteps": 6,
                                "animationStepTime": 1000,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "uniform float iTime;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nmat4 getModel() {\n  float angle = iTime;\n  \n  vec4 r1 = vec4(cos(angle), 0.0, sin(angle), 0.0);\n  vec4 r2 = vec4(0.0, 1.0, 0.0, 0.0);\n  vec4 r3 = vec4(-sin(angle), 0.0, cos(angle), 0.0);\n  vec4 r4 = vec4(0.0, 0.0, 0.0, 1.0);\n  mat4 transform = transpose(mat4(r1, r2, r3, r4));\n  \n  return modelMatrix * transform;\n}\n\nvoid main() {\n  mat4 model = getModel();\n  \n  vUv = uv;\n  vPos = vec3(model * vec4(position, 1.0));\n  \n  vNormal = normalize(mat3(transpose(inverse(model))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * model * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform sampler2D iChannel0;\n\nvarying vec2 vUv;\n\nvoid main() {\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "defaultVertexShader": "uniform float iTime;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nmat4 getModel() {\n  float angle = iTime;\n  \n  vec4 r1 = vec4(cos(angle), 0.0, sin(angle), 0.0);\n  vec4 r2 = vec4(0.0, 1.0, 0.0, 0.0);\n  vec4 r3 = vec4(-sin(angle), 0.0, cos(angle), 0.0);\n  vec4 r4 = vec4(0.0, 0.0, 0.0, 1.0);\n  mat4 transform = transpose(mat4(r1, r2, r3, r4));\n  \n  return modelMatrix * transform;\n}\n\nvoid main() {\n  mat4 model = getModel();\n  \n  vUv = uv;\n  vPos = vec3(model * vec4(position, 1.0));\n  \n  vNormal = normalize(mat3(transpose(inverse(model))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * model * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform sampler2D iChannel0;\n\nvarying vec2 vUv;\n\nvoid main() {\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 109,
                        "slug": "diffuse-lighting",
                        "moduleId": 6,
                        "name": "Diffuse Lighting",
                        "order": 3,
                        "cost": 10,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": true,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 109,
                                "slug": "diffuse-lighting",
                                "moduleId": 6,
                                "name": "Diffuse Lighting",
                                "vertexShader": "uniform float iTime;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nmat4 getModel() {\n  float angle = iTime;\n  \n  vec4 r1 = vec4(cos(angle), 0.0, sin(angle), 0.0);\n  vec4 r2 = vec4(0.0, 1.0, 0.0, 0.0);\n  vec4 r3 = vec4(-sin(angle), 0.0, cos(angle), 0.0);\n  vec4 r4 = vec4(0.0, 0.0, 0.0, 1.0);\n  mat4 transform = transpose(mat4(r1, r2, r3, r4));\n  \n  return modelMatrix * transform;\n}\n\nvoid main() {\n  mat4 model = getModel();\n  \n  vUv = uv;\n  vPos = vec3(model * vec4(position, 1.0));\n  \n  vNormal = normalize(mat3(transpose(inverse(model))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * model * vec4(position, 1.0);\n}",
                                "fragmentShader": "uniform sampler2D iChannel0;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvoid main() {\n  vec3 objectColor = texture2D(iChannel0, vUv).rgb;\n  vec3 fragNormal = normalize(vNormal);\n  vec3 fragPos = vPos;\n  \n  vec3 lightColor = vec3(1.0, 1.0, 0.75);\n  vec3 lightPos = vec3(-1.0, 2.0, 2.0);\n  vec3 lightDir = normalize(lightPos - fragPos);\n  \n  float ambient = 0.2;  \n  float diffuse = dot(fragNormal, lightDir);\n\n  vec3 result = lightColor * (ambient + diffuse) * objectColor;\n  \n  gl_FragColor = vec4(result, 1.0);\n}",
                                "defaultVertexShader": "uniform float iTime;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nmat4 getModel() {\n  float angle = iTime;\n  \n  vec4 r1 = vec4(cos(angle), 0.0, sin(angle), 0.0);\n  vec4 r2 = vec4(0.0, 1.0, 0.0, 0.0);\n  vec4 r3 = vec4(-sin(angle), 0.0, cos(angle), 0.0);\n  vec4 r4 = vec4(0.0, 0.0, 0.0, 1.0);\n  mat4 transform = transpose(mat4(r1, r2, r3, r4));\n  \n  return modelMatrix * transform;\n}\n\nvoid main() {\n  mat4 model = getModel();\n  \n  vUv = uv;\n  vPos = vec3(model * vec4(position, 1.0));\n  \n  vNormal = normalize(mat3(transpose(inverse(model))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * model * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform sampler2D iChannel0;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvoid main() {\n  vec3 objectColor = texture2D(iChannel0, vUv).rgb;\n  vec3 fragNormal = normalize(vNormal);\n  vec3 lightColor = vec3(1.0, 1.0, 0.75);\n  \n  float ambient = 0.2;\n  \n  vec3 result = lightColor * ambient * objectColor;\n  \n  gl_FragColor = vec4(result, 1.0);\n}\n",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":\"0\",\"y\":\"0\",\"z\":\"2\"},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":\"45\",\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":\"-0.15\",\"z\":0},\"rotation\":{\"x\":\"-0.4\",\"y\":\"0\",\"z\":0},\"scale\":{\"x\":\"1\",\"y\":1,\"z\":1},\"geometry\":\"2\",\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"backgroundRGBA\":\"CCCCCC\",\"background\":13421772}",
                                "description": "Diffuse lighting simulates the directional impact a light source has on an object. The diffuse illumination intensity increases when the direction of light rays tends to the plane normal.\n\n<br>\n\n![](/files/diffuse-lighting.png)\n\n<br>\n\nTo get diffuse light component we need calculate the angular distance between the light direction **L** and the plane normal **N**:\n\n```\ndiffuse = dot(N, L)\n```\n\n### Task\nWe're looking at the cube in the direction of `(0.0, 0.0, -1.0)`. The point light source is located at `(-1.0, 2.0, 2.0)` and it's color is `(1.0, 1.0, 0.75)`. Ambient factor is `0.2`. Try to add diffuse lighting to the object.\n\n<br>\n\nThe position of the cube fragment in the world space is available through the `vPos` varying. The `vNormal` varying holds the fragment's normal vector.",
                                "hints": [],
                                "restrictions": [],
                                "order": 3,
                                "cost": 10,
                                "threshold": 95,
                                "likes": 1,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [
                                    {
                                        "index": 0
                                    }
                                ],
                                "animated": true,
                                "animationSteps": 6,
                                "animationStepTime": 200,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "uniform float iTime;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nmat4 getModel() {\n  float angle = iTime;\n  \n  vec4 r1 = vec4(cos(angle), 0.0, sin(angle), 0.0);\n  vec4 r2 = vec4(0.0, 1.0, 0.0, 0.0);\n  vec4 r3 = vec4(-sin(angle), 0.0, cos(angle), 0.0);\n  vec4 r4 = vec4(0.0, 0.0, 0.0, 1.0);\n  mat4 transform = transpose(mat4(r1, r2, r3, r4));\n  \n  return modelMatrix * transform;\n}\n\nvoid main() {\n  mat4 model = getModel();\n  \n  vUv = uv;\n  vPos = vec3(model * vec4(position, 1.0));\n  \n  vNormal = normalize(mat3(transpose(inverse(model))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * model * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform sampler2D iChannel0;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvoid main() {\n  vec3 objectColor = texture2D(iChannel0, vUv).rgb;\n  vec3 fragNormal = normalize(vNormal);\n  vec3 lightColor = vec3(1.0, 1.0, 0.75);\n  \n  float ambient = 0.2;\n  \n  vec3 result = lightColor * ambient * objectColor;\n  \n  gl_FragColor = vec4(result, 1.0);\n}\n",
                            "defaultVertexShader": "uniform float iTime;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nmat4 getModel() {\n  float angle = iTime;\n  \n  vec4 r1 = vec4(cos(angle), 0.0, sin(angle), 0.0);\n  vec4 r2 = vec4(0.0, 1.0, 0.0, 0.0);\n  vec4 r3 = vec4(-sin(angle), 0.0, cos(angle), 0.0);\n  vec4 r4 = vec4(0.0, 0.0, 0.0, 1.0);\n  mat4 transform = transpose(mat4(r1, r2, r3, r4));\n  \n  return modelMatrix * transform;\n}\n\nvoid main() {\n  mat4 model = getModel();\n  \n  vUv = uv;\n  vPos = vec3(model * vec4(position, 1.0));\n  \n  vNormal = normalize(mat3(transpose(inverse(model))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * model * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform sampler2D iChannel0;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvoid main() {\n  vec3 objectColor = texture2D(iChannel0, vUv).rgb;\n  vec3 fragNormal = normalize(vNormal);\n  vec3 lightColor = vec3(1.0, 1.0, 0.75);\n  \n  float ambient = 0.2;\n  \n  vec3 result = lightColor * ambient * objectColor;\n  \n  gl_FragColor = vec4(result, 1.0);\n}\n",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 110,
                        "slug": "specular-lighting",
                        "moduleId": 6,
                        "name": "Specular Lighting",
                        "order": 5,
                        "cost": 10,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": true,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 110,
                                "slug": "specular-lighting",
                                "moduleId": 6,
                                "name": "Specular Lighting",
                                "vertexShader": "uniform float iTime;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nmat4 getModel() {\n  float angle = iTime;\n  \n  vec4 r1 = vec4(cos(angle), 0.0, sin(angle), 0.0);\n  vec4 r2 = vec4(0.0, 1.0, 0.0, 0.0);\n  vec4 r3 = vec4(-sin(angle), 0.0, cos(angle), 0.0);\n  vec4 r4 = vec4(0.0, 0.0, 0.0, 1.0);\n  mat4 transform = transpose(mat4(r1, r2, r3, r4));\n  \n  return modelMatrix * transform;\n}\n\nvoid main() {\n  mat4 model = getModel();\n  \n  vUv = uv;\n  vPos = vec3(model * vec4(position, 1.0));\n  \n  vNormal = normalize(mat3(transpose(inverse(model))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * model * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform sampler2D iChannel0;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvoid main() {\n  vec3 viewPos = vec3(0.0, 0.0, 2.5);\n  \n  vec3 objectColor = texture2D(iChannel0, vUv).rgb;\n  vec3 fragNormal = normalize(vNormal);\n  vec3 fragPos = vPos;\n  \n  vec3 lightColor = vec3(1.0, 1.0, 0.75);\n  vec3 lightPos = vec3(-1.0, 2.0, 2.0);\n  vec3 lightDir = normalize(lightPos - fragPos);\n  \n  float ambient = 0.2;\n  float diffuse = dot(fragNormal, lightDir);\n  \n  vec3 viewDir = normalize(viewPos - fragPos);\n  vec3 reflectDir = reflect(-lightDir, fragNormal);  \n  float specular = max(dot(viewDir, reflectDir), 0.0);\n  specular = pow(specular, 32.0);\n  \n  vec3 result = lightColor * (ambient + diffuse + specular) * objectColor;\n  \n  gl_FragColor = vec4(result, 1.0);\n}",
                                "defaultVertexShader": "uniform float iTime;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nmat4 getModel() {\n  float angle = iTime;\n  \n  vec4 r1 = vec4(cos(angle), 0.0, sin(angle), 0.0);\n  vec4 r2 = vec4(0.0, 1.0, 0.0, 0.0);\n  vec4 r3 = vec4(-sin(angle), 0.0, cos(angle), 0.0);\n  vec4 r4 = vec4(0.0, 0.0, 0.0, 1.0);\n  mat4 transform = transpose(mat4(r1, r2, r3, r4));\n  \n  return modelMatrix * transform;\n}\n\nvoid main() {\n  mat4 model = getModel();\n  \n  vUv = uv;\n  vPos = vec3(model * vec4(position, 1.0));\n  \n  vNormal = normalize(mat3(transpose(inverse(model))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * model * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform sampler2D iChannel0;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvoid main() {\n  vec3 objectColor = texture2D(iChannel0, vUv).rgb;\n  vec3 fragNormal = normalize(vNormal);\n  \n  vec3 lightColor = vec3(1.0, 1.0, 0.75);\n  vec3 lightPos = vec3(-1.0, 2.0, 2.0);\n  vec3 lightDir = normalize(lightPos - vPos);\n  \n  float ambient = 0.2;\n  float diffuse = dot(fragNormal, lightDir);\n  \n  vec3 result = lightColor * (ambient + diffuse) * objectColor;\n  \n  gl_FragColor = vec4(result, 1.0);\n}\n",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":\"0\",\"y\":\"0\",\"z\":\"2\"},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":\"45\",\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":\"-0.1\",\"z\":0},\"rotation\":{\"x\":\"-0.4\",\"y\":\"-0.6\",\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":\"2\",\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"backgroundRGBA\":\"CCCCCC\",\"background\":13421772}",
                                "description": "The specular lighting simulates the bright spot of a light that appears on shiny objects:\n\n<br>\n\n![](/files/specular-lighting-spot.png)\n\n<br>\n\nTo get specular light component we need to calculate a reflection vector **L'** by reflecting the light direction **L** around the object's normal vector **N**:\n\n<br>\n\n![](/files/specular-lighting-reflect.png)\n\n<br>\n\nThen we calculate the angular distance between the reflection vector **L'** and the view direction **V** (make sure it's not negative):\n\n<br>\n\n![](/files/specular-lighting-eye.png)\n\n<br>\n\n```\nspecular = dot(V, L`)\n```\n\nThe closer the angle between **L'** and **V**, the greater the impact of the specular light.\n\n### Task\nWe're looking at the cube in the direction of `(0.0, 0.0, -1.0)` from `(0.0, 0.0, 2.5)` view position. The point light source is located at `(-1.0, 2.0, 2.0)` and it's color is `(1.0, 1.0, 0.75)`. Ambient factor is `0.2`. Try to add specular lighting to the scene.\n\n<br>\n\nRaise the specular parameter you calculated to the power of `32` for a more visually pronounced effect.\n\n<br>\n\n**Hint**: GLSL has a built in function to calculate reflection: \n```\nreflectDir = reflect(dir, normal);\n```",
                                "hints": [],
                                "restrictions": [],
                                "order": 5,
                                "cost": 10,
                                "threshold": 95,
                                "likes": 2,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [
                                    {
                                        "index": 0
                                    }
                                ],
                                "animated": true,
                                "animationSteps": 6,
                                "animationStepTime": 100,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "uniform float iTime;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nmat4 getModel() {\n  float angle = iTime;\n  \n  vec4 r1 = vec4(cos(angle), 0.0, sin(angle), 0.0);\n  vec4 r2 = vec4(0.0, 1.0, 0.0, 0.0);\n  vec4 r3 = vec4(-sin(angle), 0.0, cos(angle), 0.0);\n  vec4 r4 = vec4(0.0, 0.0, 0.0, 1.0);\n  mat4 transform = transpose(mat4(r1, r2, r3, r4));\n  \n  return modelMatrix * transform;\n}\n\nvoid main() {\n  mat4 model = getModel();\n  \n  vUv = uv;\n  vPos = vec3(model * vec4(position, 1.0));\n  \n  vNormal = normalize(mat3(transpose(inverse(model))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * model * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform sampler2D iChannel0;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvoid main() {\n  vec3 objectColor = texture2D(iChannel0, vUv).rgb;\n  vec3 fragNormal = normalize(vNormal);\n  \n  vec3 lightColor = vec3(1.0, 1.0, 0.75);\n  vec3 lightPos = vec3(-1.0, 2.0, 2.0);\n  vec3 lightDir = normalize(lightPos - vPos);\n  \n  float ambient = 0.2;\n  float diffuse = dot(fragNormal, lightDir);\n  \n  vec3 result = lightColor * (ambient + diffuse) * objectColor;\n  \n  gl_FragColor = vec4(result, 1.0);\n}\n",
                            "defaultVertexShader": "uniform float iTime;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nmat4 getModel() {\n  float angle = iTime;\n  \n  vec4 r1 = vec4(cos(angle), 0.0, sin(angle), 0.0);\n  vec4 r2 = vec4(0.0, 1.0, 0.0, 0.0);\n  vec4 r3 = vec4(-sin(angle), 0.0, cos(angle), 0.0);\n  vec4 r4 = vec4(0.0, 0.0, 0.0, 1.0);\n  mat4 transform = transpose(mat4(r1, r2, r3, r4));\n  \n  return modelMatrix * transform;\n}\n\nvoid main() {\n  mat4 model = getModel();\n  \n  vUv = uv;\n  vPos = vec3(model * vec4(position, 1.0));\n  \n  vNormal = normalize(mat3(transpose(inverse(model))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * model * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform sampler2D iChannel0;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvoid main() {\n  vec3 objectColor = texture2D(iChannel0, vUv).rgb;\n  vec3 fragNormal = normalize(vNormal);\n  \n  vec3 lightColor = vec3(1.0, 1.0, 0.75);\n  vec3 lightPos = vec3(-1.0, 2.0, 2.0);\n  vec3 lightDir = normalize(lightPos - vPos);\n  \n  float ambient = 0.2;\n  float diffuse = dot(fragNormal, lightDir);\n  \n  vec3 result = lightColor * (ambient + diffuse) * objectColor;\n  \n  gl_FragColor = vec4(result, 1.0);\n}\n",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 65,
                        "slug": "light-attenuation",
                        "moduleId": 6,
                        "name": "Light Attenuation",
                        "order": 6,
                        "cost": 10,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": true,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 65,
                                "slug": "light-attenuation",
                                "moduleId": 6,
                                "name": "Light Attenuation",
                                "vertexShader": "uniform float iTime;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nmat4 getModel() {\n  float angle = iTime;\n  \n  mat4 rotate = transpose(mat4(\n    vec4(cos(angle), 0.0, sin(angle), 0.0),\n    vec4(0.0, 1.0, 0.0, 0.0),\n    vec4(-sin(angle), 0.0, cos(angle), 0.0),\n    vec4(0.0, 0.0, 0.0, 1.0)\n  ));\n\n  mat4 move = transpose(mat4(\n    vec4(1.0, 0.0, 0.0, 0.0),\n    vec4(0.0, 1.0, 0.0, 0.0),\n    vec4(0.0, 0.0, 1.0, (cos(iTime * 0.75) - 1.0) * 3.0),\n    vec4(0.0, 0.0, 0.0, 1.0)\n  ));\n  \n  return move * modelMatrix * rotate;\n}\n\nvoid main() {\n  mat4 model = getModel();\n  \n  vUv = uv;\n  vPos = vec3(model * vec4(position, 1.0));\n  \n  vNormal = normalize(mat3(transpose(inverse(model))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * model * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform sampler2D iChannel0;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvoid main() {\n  vec3 viewPos = vec3(0.0, 0.0, 2.5);\n  \n  vec3 objectColor = texture2D(iChannel0, vUv).rgb;\n  vec3 fragNormal = normalize(vNormal);\n  vec3 fragPos = vPos;\n  \n  vec3 lightColor = vec3(1.0, 1.0, 0.75) * 3.0;\n  vec3 lightPos = vec3(-1.0, 2.0, 2.0);\n  vec3 lightDir = normalize(lightPos - fragPos);\n  \n  float ambient = 0.2;\n  float diffuse = dot(fragNormal, lightDir);\n  \n  vec3 viewDir = normalize(viewPos - fragPos);\n  vec3 reflectDir = reflect(-lightDir, fragNormal);  \n  float specular = max(dot(viewDir, reflectDir), 0.0);\n  specular = pow(specular, 32.0);\n\n  float kc = 1.0;\n  float kl = 0.0;\n  float kq = 0.1;\n  float dist = distance(vPos, lightPos);\n  float attenuation = 1.0 / (kc + kl * dist + kq * (dist * dist));\n  \n  vec3 result = lightColor * (ambient + diffuse + specular) * objectColor;\n  result *= attenuation;\n  \n  gl_FragColor = vec4(result, 1.0);\n}",
                                "defaultVertexShader": "uniform float iTime;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nmat4 getModel() {\n  float angle = iTime;\n  \n  mat4 rotate = transpose(mat4(\n    vec4(cos(angle), 0.0, sin(angle), 0.0),\n    vec4(0.0, 1.0, 0.0, 0.0),\n    vec4(-sin(angle), 0.0, cos(angle), 0.0),\n    vec4(0.0, 0.0, 0.0, 1.0)\n  ));\n\n  mat4 move = transpose(mat4(\n    vec4(1.0, 0.0, 0.0, 0.0),\n    vec4(0.0, 1.0, 0.0, 0.0),\n    vec4(0.0, 0.0, 1.0, (cos(iTime * 0.75) - 1.0) * 3.0),\n    vec4(0.0, 0.0, 0.0, 1.0)\n  ));\n  \n  return move * modelMatrix * rotate;\n}\n\nvoid main() {\n  mat4 model = getModel();\n  \n  vUv = uv;\n  vPos = vec3(model * vec4(position, 1.0));\n  \n  vNormal = normalize(mat3(transpose(inverse(model))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * model * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform sampler2D iChannel0;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvoid main() {\n  vec3 viewPos = vec3(0.0, 0.0, 2.5);\n  \n  vec3 objectColor = texture2D(iChannel0, vUv).rgb;\n  vec3 fragNormal = normalize(vNormal);\n  vec3 fragPos = vPos;\n  \n  vec3 lightColor = vec3(1.0, 1.0, 0.75) * 3.0;\n  vec3 lightPos = vec3(-1.0, 2.0, 2.0);\n  vec3 lightDir = normalize(lightPos - fragPos);\n  \n  float ambient = 0.2;\n  float diffuse = dot(fragNormal, lightDir);\n  \n  vec3 viewDir = normalize(viewPos - fragPos);\n  vec3 reflectDir = reflect(-lightDir, fragNormal);  \n  float specular = max(dot(viewDir, reflectDir), 0.0);\n  specular = pow(specular, 32.0);\n  \n  vec3 result = lightColor * (ambient + diffuse + specular) * objectColor;\n  \n  gl_FragColor = vec4(result, 1.0);\n}",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":\"0\",\"y\":\"0\",\"z\":\"2\"},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":\"45\",\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":\"-0.1\",\"z\":0},\"rotation\":{\"x\":\"-0.4\",\"y\":\"-0.6\",\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":\"2\",\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"backgroundRGBA\":\"CCCCCC\",\"background\":13421772}",
                                "description": "**Attenuation** refers to the decrease in light intensity over the distance a light ray travels.\n\n<br>\n\n### Real-World Observation\n\n<br>\n\n• Light sources appear very bright when close by.\n\n<br>\n\n• The brightness decreases rapidly with distance.\n\n<br>\n\n• The remaining light intensity decreases more slowly as the distance increases.\n\n<br>\n\n### Formula \n\n<br>\n\nThe attenuation value based on a fragment’s distance to the light source is calculated using the formula:\n```\nAttenuation = 1.0 / (Kc + Kl * Distance + Kq * Distance * Distance)\n```\n\n### Components\n\n<br>\n\n**• Kc (Constant Term)** is typically set to 1.0 to ensure the denominator never gets smaller than 1, preventing an unrealistic boost in intensity at certain distances.\n\n<br>\n\n**• Kl (Linear Term)** is multiplied by the distance, reducing intensity linearly.\n\n<br>\n\n**• Kq (Quadratic Term)** is multiplied by the square of the distance, causing a quadratic decrease in intensity. This term is less significant at short distances but becomes more impactful as the distance increases.\n\n<br>\n\n### Considerations\n\n<br>\n\nThe values of **Kc**, **Kl**, and **Kq** depend on various factors such as the environment, the desired light coverage distance, and the type of light source.\n\n### Task\nApply attenuation with the following constants: \n```\nKc = 1.0;\nKl = 0.0;\nKq = 0.1;\n```",
                                "hints": [],
                                "restrictions": [],
                                "order": 6,
                                "cost": 10,
                                "threshold": 95,
                                "likes": 2,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [
                                    {
                                        "index": 0
                                    }
                                ],
                                "animated": true,
                                "animationSteps": 16,
                                "animationStepTime": 500,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "uniform float iTime;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nmat4 getModel() {\n  float angle = iTime;\n  \n  mat4 rotate = transpose(mat4(\n    vec4(cos(angle), 0.0, sin(angle), 0.0),\n    vec4(0.0, 1.0, 0.0, 0.0),\n    vec4(-sin(angle), 0.0, cos(angle), 0.0),\n    vec4(0.0, 0.0, 0.0, 1.0)\n  ));\n\n  mat4 move = transpose(mat4(\n    vec4(1.0, 0.0, 0.0, 0.0),\n    vec4(0.0, 1.0, 0.0, 0.0),\n    vec4(0.0, 0.0, 1.0, (cos(iTime * 0.75) - 1.0) * 3.0),\n    vec4(0.0, 0.0, 0.0, 1.0)\n  ));\n  \n  return move * modelMatrix * rotate;\n}\n\nvoid main() {\n  mat4 model = getModel();\n  \n  vUv = uv;\n  vPos = vec3(model * vec4(position, 1.0));\n  \n  vNormal = normalize(mat3(transpose(inverse(model))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * model * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform sampler2D iChannel0;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvoid main() {\n  vec3 viewPos = vec3(0.0, 0.0, 2.5);\n  \n  vec3 objectColor = texture2D(iChannel0, vUv).rgb;\n  vec3 fragNormal = normalize(vNormal);\n  vec3 fragPos = vPos;\n  \n  vec3 lightColor = vec3(1.0, 1.0, 0.75) * 3.0;\n  vec3 lightPos = vec3(-1.0, 2.0, 2.0);\n  vec3 lightDir = normalize(lightPos - fragPos);\n  \n  float ambient = 0.2;\n  float diffuse = dot(fragNormal, lightDir);\n  \n  vec3 viewDir = normalize(viewPos - fragPos);\n  vec3 reflectDir = reflect(-lightDir, fragNormal);  \n  float specular = max(dot(viewDir, reflectDir), 0.0);\n  specular = pow(specular, 32.0);\n  \n  vec3 result = lightColor * (ambient + diffuse + specular) * objectColor;\n  \n  gl_FragColor = vec4(result, 1.0);\n}",
                            "defaultVertexShader": "uniform float iTime;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nmat4 getModel() {\n  float angle = iTime;\n  \n  mat4 rotate = transpose(mat4(\n    vec4(cos(angle), 0.0, sin(angle), 0.0),\n    vec4(0.0, 1.0, 0.0, 0.0),\n    vec4(-sin(angle), 0.0, cos(angle), 0.0),\n    vec4(0.0, 0.0, 0.0, 1.0)\n  ));\n\n  mat4 move = transpose(mat4(\n    vec4(1.0, 0.0, 0.0, 0.0),\n    vec4(0.0, 1.0, 0.0, 0.0),\n    vec4(0.0, 0.0, 1.0, (cos(iTime * 0.75) - 1.0) * 3.0),\n    vec4(0.0, 0.0, 0.0, 1.0)\n  ));\n  \n  return move * modelMatrix * rotate;\n}\n\nvoid main() {\n  mat4 model = getModel();\n  \n  vUv = uv;\n  vPos = vec3(model * vec4(position, 1.0));\n  \n  vNormal = normalize(mat3(transpose(inverse(model))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * model * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform sampler2D iChannel0;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvoid main() {\n  vec3 viewPos = vec3(0.0, 0.0, 2.5);\n  \n  vec3 objectColor = texture2D(iChannel0, vUv).rgb;\n  vec3 fragNormal = normalize(vNormal);\n  vec3 fragPos = vPos;\n  \n  vec3 lightColor = vec3(1.0, 1.0, 0.75) * 3.0;\n  vec3 lightPos = vec3(-1.0, 2.0, 2.0);\n  vec3 lightDir = normalize(lightPos - fragPos);\n  \n  float ambient = 0.2;\n  float diffuse = dot(fragNormal, lightDir);\n  \n  vec3 viewDir = normalize(viewPos - fragPos);\n  vec3 reflectDir = reflect(-lightDir, fragNormal);  \n  float specular = max(dot(viewDir, reflectDir), 0.0);\n  specular = pow(specular, 32.0);\n  \n  vec3 result = lightColor * (ambient + diffuse + specular) * objectColor;\n  \n  gl_FragColor = vec4(result, 1.0);\n}",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 62,
                        "slug": "shininess",
                        "moduleId": 6,
                        "name": "Shininess",
                        "order": 8,
                        "cost": 10,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": true,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 62,
                                "slug": "shininess",
                                "moduleId": 6,
                                "name": "Shininess",
                                "vertexShader": "varying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  vPos = vec3(modelMatrix * vec4(position, 1.0));\n  vNormal = normalize(mat3(transpose(inverse(modelMatrix))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform float iTime;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nfloat getProgress() {\n  float m = mod(iTime * 0.5, 2.0);\n  float t = fract(m);\n  if (m > 1.0) {\n    t = 1.0 - t;\n  }\n  return pow(2.0, 10.0 * t - 10.0);\n}\n\nvoid main() {\n  vec3 viewPos = vec3(0.0, 0.0, 2.5);\n  \n  vec3 objectColor = vec3(0.75, 0.45, 0.45);\n  vec3 fragNormal = normalize(vNormal);\n  vec3 fragPos = vPos;\n  \n  vec3 lightColor = vec3(1.0, 1.0, 0.75);\n  vec3 lightPos = vec3(-2.0, 2.0, 2.0);\n  vec3 lightDir = normalize(lightPos - fragPos);\n  \n  float ambient = 0.2;\n  float diffuse = dot(fragNormal, lightDir);\n  \n  vec3 viewDir = normalize(viewPos - fragPos);\n  vec3 reflectDir = reflect(-lightDir, fragNormal);  \n  float specular = max(dot(viewDir, reflectDir), 0.0);\n  specular = pow(specular, mix(1.0, 256.0, getProgress()));\n  \n  vec3 result = lightColor * (ambient + diffuse + specular) * objectColor;\n  \n  gl_FragColor = vec4(result, 1.0);\n}",
                                "defaultVertexShader": "varying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  vPos = vec3(modelMatrix * vec4(position, 1.0));\n  vNormal = normalize(mat3(transpose(inverse(modelMatrix))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform float iTime;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nfloat getProgress() {\n  float m = mod(iTime * 0.5, 2.0);\n  float t = fract(m);\n  if (m > 1.0) {\n    t = 1.0 - t;\n  }\n  return pow(2.0, 10.0 * t - 10.0);\n}\n\nvoid main() {\n  vec3 viewPos = vec3(0.0, 0.0, 2.5);\n  \n  vec3 objectColor = vec3(0.75, 0.45, 0.45);\n  vec3 fragNormal = normalize(vNormal);\n  vec3 fragPos = vPos;\n  \n  vec3 lightColor = vec3(1.0, 1.0, 0.75);\n  vec3 lightPos = vec3(-2.0, 2.0, 2.0);\n  vec3 lightDir = normalize(lightPos - fragPos);\n  \n  float ambient = 0.2;\n  float diffuse = dot(fragNormal, lightDir);\n  \n  vec3 viewDir = normalize(viewPos - fragPos);\n  vec3 reflectDir = reflect(-lightDir, fragNormal);  \n  float specular = max(dot(viewDir, reflectDir), 0.0);\n  \n  vec3 result = lightColor * (ambient + diffuse + specular) * objectColor;\n  \n  gl_FragColor = vec4(result, 1.0);\n}",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":\"0\",\"y\":\"0\",\"z\":\"1.4\"},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":\"45\",\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":\"3\",\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"backgroundRGBA\":\"CCCCCC\",\"background\":13421772}",
                                "description": "The **shininess** value of an object determines how sharply it reflects light, affecting the size and intensity of the highlight.\n\n<br>\n\n### Key Points\n\n<br>\n\n• **Higher Shininess Value.** Results in a smaller, more intense highlight as the object reflects light more precisely rather than scattering it.\n\n<br>\n\n• **Lower Shininess Value.** Leads to a larger, more diffused highlight due to increased scattering of light.\n\n<br>\n\n### Implementation Steps\n\n<br>\n\n1\\. **Calculate Specular Component.** Compute the dot product between the view direction and the reflection direction. *Ensure the result is not negative*.\n\n<br>\n\n2\\. **Apply Shininess.** Raise the calculated specular component to the power of the shininess value to achieve the desired effect.\n\n### Task\nWe're looking at the sphere of color `(0.75, 0.45, 0.45)` in the direction of `(0.0, 0.0, -1.0)` from `(0.0, 0.0, 2.5)` view position. The point light source is located at `(-2.0, 2.0, 2.0)` and it's color is `(1.0, 1.0, 0.75)`. Ambient factor is `0.2`.\n\n<br>\n\nChange the shininess value from `1.0` to `256.0` using the value of the `getProgress` function as the mix parameter.",
                                "hints": [],
                                "restrictions": [],
                                "order": 8,
                                "cost": 10,
                                "threshold": 98,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": true,
                                "animationSteps": 10,
                                "animationStepTime": 300,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "varying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  vPos = vec3(modelMatrix * vec4(position, 1.0));\n  vNormal = normalize(mat3(transpose(inverse(modelMatrix))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform float iTime;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nfloat getProgress() {\n  float m = mod(iTime * 0.5, 2.0);\n  float t = fract(m);\n  if (m > 1.0) {\n    t = 1.0 - t;\n  }\n  return pow(2.0, 10.0 * t - 10.0);\n}\n\nvoid main() {\n  vec3 viewPos = vec3(0.0, 0.0, 2.5);\n  \n  vec3 objectColor = vec3(0.75, 0.45, 0.45);\n  vec3 fragNormal = normalize(vNormal);\n  vec3 fragPos = vPos;\n  \n  vec3 lightColor = vec3(1.0, 1.0, 0.75);\n  vec3 lightPos = vec3(-2.0, 2.0, 2.0);\n  vec3 lightDir = normalize(lightPos - fragPos);\n  \n  float ambient = 0.2;\n  float diffuse = dot(fragNormal, lightDir);\n  \n  vec3 viewDir = normalize(viewPos - fragPos);\n  vec3 reflectDir = reflect(-lightDir, fragNormal);  \n  float specular = max(dot(viewDir, reflectDir), 0.0);\n  \n  vec3 result = lightColor * (ambient + diffuse + specular) * objectColor;\n  \n  gl_FragColor = vec4(result, 1.0);\n}",
                            "defaultVertexShader": "varying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  vPos = vec3(modelMatrix * vec4(position, 1.0));\n  vNormal = normalize(mat3(transpose(inverse(modelMatrix))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform float iTime;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nfloat getProgress() {\n  float m = mod(iTime * 0.5, 2.0);\n  float t = fract(m);\n  if (m > 1.0) {\n    t = 1.0 - t;\n  }\n  return pow(2.0, 10.0 * t - 10.0);\n}\n\nvoid main() {\n  vec3 viewPos = vec3(0.0, 0.0, 2.5);\n  \n  vec3 objectColor = vec3(0.75, 0.45, 0.45);\n  vec3 fragNormal = normalize(vNormal);\n  vec3 fragPos = vPos;\n  \n  vec3 lightColor = vec3(1.0, 1.0, 0.75);\n  vec3 lightPos = vec3(-2.0, 2.0, 2.0);\n  vec3 lightDir = normalize(lightPos - fragPos);\n  \n  float ambient = 0.2;\n  float diffuse = dot(fragNormal, lightDir);\n  \n  vec3 viewDir = normalize(viewPos - fragPos);\n  vec3 reflectDir = reflect(-lightDir, fragNormal);  \n  float specular = max(dot(viewDir, reflectDir), 0.0);\n  \n  vec3 result = lightColor * (ambient + diffuse + specular) * objectColor;\n  \n  gl_FragColor = vec4(result, 1.0);\n}",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 84,
                        "slug": "halfway-vector",
                        "moduleId": 6,
                        "name": "Halfway Vector",
                        "order": 9,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": true,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 84,
                                "slug": "halfway-vector",
                                "moduleId": 6,
                                "name": "Halfway Vector",
                                "vertexShader": "uniform float iTime;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nmat4 getModel() {\n  float angle = iTime;\n  \n  mat4 rotate = transpose(mat4(\n    vec4(cos(angle), 0.0, sin(angle), 0.0),\n    vec4(0.0, 1.0, 0.0, 0.0),\n    vec4(-sin(angle), 0.0, cos(angle), 0.0),\n    vec4(0.0, 0.0, 0.0, 1.0)\n  ));\n\n  mat4 move = transpose(mat4(\n    vec4(1.0, 0.0, 0.0, 0.0),\n    vec4(0.0, 1.0, 0.0, -0.5),\n    vec4(0.0, 0.0, 1.0, 0.0),\n    vec4(0.0, 0.0, 0.0, 1.0)\n  ));\n  \n  return move * modelMatrix;\n}\n\nvoid main() {\n  mat4 model = getModel();\n  \n  vUv = uv;\n  vPos = vec3(model * vec4(position, 1.0));\n  \n  vNormal = normalize(mat3(transpose(inverse(model))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * model * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform float iTime;\nuniform sampler2D iChannel0;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvoid main() {\n  vec3 viewPos = vec3(0.0, 2.0, 2.0);\n  \n  vec3 objectColor = vec3(0.5);\n  vec3 fragNormal = normalize(vNormal);\n  vec3 fragPos = vPos;\n  \n  vec3 lightColor = vec3(1.0, 0.75, 0.75);\n  vec3 lightPos = vec3(0.0, sin(iTime) * 2.0 + 2.0, 2.0);\n  vec3 lightDir = normalize(lightPos - fragPos);\n  \n  float ambient = 0.2;\n  float diffuse = dot(fragNormal, lightDir);\n  \n  vec3 viewDir = normalize(viewPos - fragPos);\n  vec3 halfwayDir = normalize(lightDir + viewDir);\n  float specular = max(dot(fragNormal, halfwayDir), 0.0);\n  \n  vec3 result = lightColor * (ambient + diffuse + specular) * objectColor;\n  \n  gl_FragColor = vec4(result, 1.0);\n}",
                                "defaultVertexShader": "uniform float iTime;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nmat4 getModel() {\n  float angle = iTime;\n  \n  mat4 rotate = transpose(mat4(\n    vec4(cos(angle), 0.0, sin(angle), 0.0),\n    vec4(0.0, 1.0, 0.0, 0.0),\n    vec4(-sin(angle), 0.0, cos(angle), 0.0),\n    vec4(0.0, 0.0, 0.0, 1.0)\n  ));\n\n  mat4 move = transpose(mat4(\n    vec4(1.0, 0.0, 0.0, 0.0),\n    vec4(0.0, 1.0, 0.0, -0.5),\n    vec4(0.0, 0.0, 1.0, 0.0),\n    vec4(0.0, 0.0, 0.0, 1.0)\n  ));\n  \n  return move * modelMatrix;\n}\n\nvoid main() {\n  mat4 model = getModel();\n  \n  vUv = uv;\n  vPos = vec3(model * vec4(position, 1.0));\n  \n  vNormal = normalize(mat3(transpose(inverse(model))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * model * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform float iTime;\nuniform sampler2D iChannel0;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvoid main() {\n  vec3 viewPos = vec3(0.0, 2.0, 2.0);\n  \n  vec3 objectColor = vec3(0.5);\n  vec3 fragNormal = normalize(vNormal);\n  vec3 fragPos = vPos;\n  \n  vec3 lightColor = vec3(1.0, 0.75, 0.75);\n  vec3 lightPos = vec3(0.0, sin(iTime) * 2.0 + 2.0, 2.0);\n  vec3 lightDir = normalize(lightPos - fragPos);\n  \n  float ambient = 0.2;\n  float diffuse = dot(fragNormal, lightDir);\n  \n  vec3 viewDir = normalize(viewPos - fragPos);\n  vec3 reflectDir = reflect(-lightDir, fragNormal);  \n  float specular = max(dot(viewDir, reflectDir), 0.0);\n  \n  vec3 result = lightColor * (ambient + diffuse + specular) * objectColor;\n  \n  gl_FragColor = vec4(result, 1.0);\n}",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":\"0\",\"y\":\"0\",\"z\":\"2\"},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":\"45\",\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":\"0\",\"z\":\"-3\"},\"rotation\":{\"x\":\"0.25\",\"y\":0,\"z\":0},\"scale\":{\"x\":\"5\",\"y\":\"0.1\",\"z\":\"4\"},\"geometry\":\"2\",\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"backgroundRGBA\":\"CCCCCC\",\"background\":13421772}",
                                "description": "Phong's specular reflections can fail under certain conditions, particularly when the specular area becomes large.\n\n<br>\n\n### Issue with Phong Specular Reflections\n\n<br>\n\nWhen the angle between the view **V** and reflection vectors **L'** exceeds 90 degrees, the resulting dot product becomes negative. This leads to a specular factor of 0.0, creating a sharply defined border in the specular reflection area.\n\n<br>\n\n![](/files/halfway-vector-specular-issue.png)\n\n<br>\n\n### Halfway Vector\n\n<br>\n\nSo instead of relying on the reflection vector we can use a **halfway vector (H)**, that is a unit vector that lies exactly halfway between the view direction **V** and the light direction **L**. The closer this halfway vector aligns with the surface's normal **N**, the higher the specular contribution. The angle between the halfway vector and the surface normal never exceeds 90 degrees, ensuring a smoother and more consistent specular contribution.\n\n<br>\n\n![](/files/halfway-vector.png)\n\n<br>\n\n### Implementation\n\n<br>\n\nAdd the light direction vector **L** and the view direction vector **V**, then normalize the result to get the halfway vector **H**:\n```\nHalfwayDir = normalize(LightDir + ViewDir);\n```\n\n### Task\nReplace Phong's specular calculation with a halfway vector approach.",
                                "hints": [],
                                "restrictions": [],
                                "order": 9,
                                "cost": 5,
                                "threshold": 99,
                                "likes": 2,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": true,
                                "animationSteps": 6,
                                "animationStepTime": 1000,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "uniform float iTime;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nmat4 getModel() {\n  float angle = iTime;\n  \n  mat4 rotate = transpose(mat4(\n    vec4(cos(angle), 0.0, sin(angle), 0.0),\n    vec4(0.0, 1.0, 0.0, 0.0),\n    vec4(-sin(angle), 0.0, cos(angle), 0.0),\n    vec4(0.0, 0.0, 0.0, 1.0)\n  ));\n\n  mat4 move = transpose(mat4(\n    vec4(1.0, 0.0, 0.0, 0.0),\n    vec4(0.0, 1.0, 0.0, -0.5),\n    vec4(0.0, 0.0, 1.0, 0.0),\n    vec4(0.0, 0.0, 0.0, 1.0)\n  ));\n  \n  return move * modelMatrix;\n}\n\nvoid main() {\n  mat4 model = getModel();\n  \n  vUv = uv;\n  vPos = vec3(model * vec4(position, 1.0));\n  \n  vNormal = normalize(mat3(transpose(inverse(model))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * model * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform float iTime;\nuniform sampler2D iChannel0;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvoid main() {\n  vec3 viewPos = vec3(0.0, 2.0, 2.0);\n  \n  vec3 objectColor = vec3(0.5);\n  vec3 fragNormal = normalize(vNormal);\n  vec3 fragPos = vPos;\n  \n  vec3 lightColor = vec3(1.0, 0.75, 0.75);\n  vec3 lightPos = vec3(0.0, sin(iTime) * 2.0 + 2.0, 2.0);\n  vec3 lightDir = normalize(lightPos - fragPos);\n  \n  float ambient = 0.2;\n  float diffuse = dot(fragNormal, lightDir);\n  \n  vec3 viewDir = normalize(viewPos - fragPos);\n  vec3 reflectDir = reflect(-lightDir, fragNormal);  \n  float specular = max(dot(viewDir, reflectDir), 0.0);\n  \n  vec3 result = lightColor * (ambient + diffuse + specular) * objectColor;\n  \n  gl_FragColor = vec4(result, 1.0);\n}",
                            "defaultVertexShader": "uniform float iTime;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nmat4 getModel() {\n  float angle = iTime;\n  \n  mat4 rotate = transpose(mat4(\n    vec4(cos(angle), 0.0, sin(angle), 0.0),\n    vec4(0.0, 1.0, 0.0, 0.0),\n    vec4(-sin(angle), 0.0, cos(angle), 0.0),\n    vec4(0.0, 0.0, 0.0, 1.0)\n  ));\n\n  mat4 move = transpose(mat4(\n    vec4(1.0, 0.0, 0.0, 0.0),\n    vec4(0.0, 1.0, 0.0, -0.5),\n    vec4(0.0, 0.0, 1.0, 0.0),\n    vec4(0.0, 0.0, 0.0, 1.0)\n  ));\n  \n  return move * modelMatrix;\n}\n\nvoid main() {\n  mat4 model = getModel();\n  \n  vUv = uv;\n  vPos = vec3(model * vec4(position, 1.0));\n  \n  vNormal = normalize(mat3(transpose(inverse(model))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * model * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform float iTime;\nuniform sampler2D iChannel0;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvoid main() {\n  vec3 viewPos = vec3(0.0, 2.0, 2.0);\n  \n  vec3 objectColor = vec3(0.5);\n  vec3 fragNormal = normalize(vNormal);\n  vec3 fragPos = vPos;\n  \n  vec3 lightColor = vec3(1.0, 0.75, 0.75);\n  vec3 lightPos = vec3(0.0, sin(iTime) * 2.0 + 2.0, 2.0);\n  vec3 lightDir = normalize(lightPos - fragPos);\n  \n  float ambient = 0.2;\n  float diffuse = dot(fragNormal, lightDir);\n  \n  vec3 viewDir = normalize(viewPos - fragPos);\n  vec3 reflectDir = reflect(-lightDir, fragNormal);  \n  float specular = max(dot(viewDir, reflectDir), 0.0);\n  \n  vec3 result = lightColor * (ambient + diffuse + specular) * objectColor;\n  \n  gl_FragColor = vec4(result, 1.0);\n}",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 63,
                        "slug": "specular-map",
                        "moduleId": 6,
                        "name": "Specular Map",
                        "order": 10,
                        "cost": 10,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": true,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 63,
                                "slug": "specular-map",
                                "moduleId": 6,
                                "name": "Specular Map",
                                "vertexShader": "uniform float iTime;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nmat4 getModel() {\n  float angle = iTime;\n  \n  vec4 r1 = vec4(cos(angle), 0.0, sin(angle), 0.0);\n  vec4 r2 = vec4(0.0, 1.0, 0.0, 0.0);\n  vec4 r3 = vec4(-sin(angle), 0.0, cos(angle), 0.0);\n  vec4 r4 = vec4(0.0, 0.0, 0.0, 1.0);\n  mat4 transform = transpose(mat4(r1, r2, r3, r4));\n  \n  return modelMatrix * transform;\n}\n\nvoid main() {\n  mat4 model = getModel();\n  \n  vUv = uv;\n  vPos = vec3(model * vec4(position, 1.0));\n  \n  vNormal = normalize(mat3(transpose(inverse(model))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * model * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform float iTime;\nuniform sampler2D iChannel0;\nuniform sampler2D iChannel1;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvoid main() {\n  vec3 viewPos = vec3(0.0, 0.0, 2.5);\n  \n  vec3 objectColor = texture2D(iChannel0, vUv).rgb;\n  vec3 objectSpecular = texture2D(iChannel1, vUv).rgb;\n  vec3 fragNormal = normalize(vNormal);\n  vec3 fragPos = vPos;\n  \n  vec3 lightColor = vec3(1.0, 1.0, 0.75);\n  vec3 lightPos = vec3(-1.0, 2.0, 2.0);\n  vec3 lightDir = normalize(lightPos - fragPos);\n  \n  float ambient = 0.2;\n  float diffuse = dot(fragNormal, lightDir);\n  \n  vec3 viewDir = normalize(viewPos - fragPos);\n  vec3 reflectDir = reflect(-lightDir, fragNormal);  \n  float specular = pow(max(dot(viewDir, reflectDir), 0.0), 8.0);\n  \n  vec3 result = vec3(0.0);\n  result += ambient * objectColor;\n  result += diffuse * objectColor;\n  result += specular * objectSpecular;\n  result *= lightColor;\n  \n  gl_FragColor = vec4(result, 1.0);\n}",
                                "defaultVertexShader": "uniform float iTime;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nmat4 getModel() {\n  float angle = iTime;\n  \n  vec4 r1 = vec4(cos(angle), 0.0, sin(angle), 0.0);\n  vec4 r2 = vec4(0.0, 1.0, 0.0, 0.0);\n  vec4 r3 = vec4(-sin(angle), 0.0, cos(angle), 0.0);\n  vec4 r4 = vec4(0.0, 0.0, 0.0, 1.0);\n  mat4 transform = transpose(mat4(r1, r2, r3, r4));\n  \n  return modelMatrix * transform;\n}\n\nvoid main() {\n  mat4 model = getModel();\n  \n  vUv = uv;\n  vPos = vec3(model * vec4(position, 1.0));\n  \n  vNormal = normalize(mat3(transpose(inverse(model))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * model * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform float iTime;\nuniform sampler2D iChannel0;\nuniform sampler2D iChannel1;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvoid main() {\n  vec3 viewPos = vec3(0.0, 0.0, 2.5);\n  \n  vec3 objectColor = texture2D(iChannel0, vUv).rgb;\n  vec3 fragNormal = normalize(vNormal);\n  vec3 fragPos = vPos;\n  \n  vec3 lightColor = vec3(1.0, 1.0, 0.75);\n  vec3 lightPos = vec3(-1.0, 2.0, 2.0);\n  vec3 lightDir = normalize(lightPos - fragPos);\n  \n  float ambient = 0.2;\n  float diffuse = dot(fragNormal, lightDir);\n  \n  vec3 viewDir = normalize(viewPos - fragPos);\n  vec3 reflectDir = reflect(-lightDir, fragNormal);  \n  float specular = pow(max(dot(viewDir, reflectDir), 0.0), 8.0);\n\n  vec3 result = lightColor * (ambient + diffuse + specular) * objectColor;\n  \n  gl_FragColor = vec4(result, 1.0);\n}",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":\"0\",\"y\":\"0\",\"z\":\"2\"},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":\"45\",\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"object\":{\"position\":{\"x\":0,\"y\":\"-0.1\",\"z\":\"0\"},\"rotation\":{\"x\":\"-0.4\",\"y\":\"-0.6\",\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":\"2\"},\"backgroundRGBA\":\"CCCCCC\",\"background\":13421772}",
                                "description": "The surface of an object can consist of different types of materials: wood, metal, leather and etc. Each such material interacts with light differently depending on its physical properties. For example, when light interacts with wood, it scatters and does not give such a mirror-like shine as when it interacts with metal.\n\n<br>\n\n![Image 1 - Object Materials](/files/specular-map-materials.png)\n\n<br>\n\nIn order to control the specular intensity of each part of the object, we can use additional texture that is usually referred to as **specular map**. Each pixel of such texture is a color vector. In the fragment shader we sample the corresponding color value and multiply this value with the light's specular intensity. The more 'white' a pixel is, the higher the result of the multiplication and thus the brighter the specular component of an object becomes.\n\n<br>\n\n![Image 2 - Specular Map](/files/specular-map.png)\n\n<br>\n\n**Note**. Previously we multiplied the light's specular component by the color value from the *diffuse map*, now we need to use the color value from the *specular map*.\n\n### Task\nSample the specular map form `Channel1` to retrieve the fragment's corresponding specular intensity.\n\n",
                                "hints": [],
                                "restrictions": [],
                                "order": 10,
                                "cost": 10,
                                "threshold": 98,
                                "likes": 1,
                                "dislikes": 3,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [
                                    {
                                        "index": 0
                                    },
                                    {
                                        "index": 1
                                    }
                                ],
                                "animated": true,
                                "animationSteps": 12,
                                "animationStepTime": 500,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "uniform float iTime;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nmat4 getModel() {\n  float angle = iTime;\n  \n  vec4 r1 = vec4(cos(angle), 0.0, sin(angle), 0.0);\n  vec4 r2 = vec4(0.0, 1.0, 0.0, 0.0);\n  vec4 r3 = vec4(-sin(angle), 0.0, cos(angle), 0.0);\n  vec4 r4 = vec4(0.0, 0.0, 0.0, 1.0);\n  mat4 transform = transpose(mat4(r1, r2, r3, r4));\n  \n  return modelMatrix * transform;\n}\n\nvoid main() {\n  mat4 model = getModel();\n  \n  vUv = uv;\n  vPos = vec3(model * vec4(position, 1.0));\n  \n  vNormal = normalize(mat3(transpose(inverse(model))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * model * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform float iTime;\nuniform sampler2D iChannel0;\nuniform sampler2D iChannel1;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvoid main() {\n  vec3 viewPos = vec3(0.0, 0.0, 2.5);\n  \n  vec3 objectColor = texture2D(iChannel0, vUv).rgb;\n  vec3 fragNormal = normalize(vNormal);\n  vec3 fragPos = vPos;\n  \n  vec3 lightColor = vec3(1.0, 1.0, 0.75);\n  vec3 lightPos = vec3(-1.0, 2.0, 2.0);\n  vec3 lightDir = normalize(lightPos - fragPos);\n  \n  float ambient = 0.2;\n  float diffuse = dot(fragNormal, lightDir);\n  \n  vec3 viewDir = normalize(viewPos - fragPos);\n  vec3 reflectDir = reflect(-lightDir, fragNormal);  \n  float specular = pow(max(dot(viewDir, reflectDir), 0.0), 8.0);\n\n  vec3 result = lightColor * (ambient + diffuse + specular) * objectColor;\n  \n  gl_FragColor = vec4(result, 1.0);\n}",
                            "defaultVertexShader": "uniform float iTime;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nmat4 getModel() {\n  float angle = iTime;\n  \n  vec4 r1 = vec4(cos(angle), 0.0, sin(angle), 0.0);\n  vec4 r2 = vec4(0.0, 1.0, 0.0, 0.0);\n  vec4 r3 = vec4(-sin(angle), 0.0, cos(angle), 0.0);\n  vec4 r4 = vec4(0.0, 0.0, 0.0, 1.0);\n  mat4 transform = transpose(mat4(r1, r2, r3, r4));\n  \n  return modelMatrix * transform;\n}\n\nvoid main() {\n  mat4 model = getModel();\n  \n  vUv = uv;\n  vPos = vec3(model * vec4(position, 1.0));\n  \n  vNormal = normalize(mat3(transpose(inverse(model))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * model * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform float iTime;\nuniform sampler2D iChannel0;\nuniform sampler2D iChannel1;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvoid main() {\n  vec3 viewPos = vec3(0.0, 0.0, 2.5);\n  \n  vec3 objectColor = texture2D(iChannel0, vUv).rgb;\n  vec3 fragNormal = normalize(vNormal);\n  vec3 fragPos = vPos;\n  \n  vec3 lightColor = vec3(1.0, 1.0, 0.75);\n  vec3 lightPos = vec3(-1.0, 2.0, 2.0);\n  vec3 lightDir = normalize(lightPos - fragPos);\n  \n  float ambient = 0.2;\n  float diffuse = dot(fragNormal, lightDir);\n  \n  vec3 viewDir = normalize(viewPos - fragPos);\n  vec3 reflectDir = reflect(-lightDir, fragNormal);  \n  float specular = pow(max(dot(viewDir, reflectDir), 0.0), 8.0);\n\n  vec3 result = lightColor * (ambient + diffuse + specular) * objectColor;\n  \n  gl_FragColor = vec4(result, 1.0);\n}",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 64,
                        "slug": "normal-map",
                        "moduleId": 6,
                        "name": "Normal Map",
                        "order": 11,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": true,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 64,
                                "slug": "normal-map",
                                "moduleId": 6,
                                "name": "Normal Map",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\nuniform sampler2D iChannel0;\nuniform sampler2D iChannel1;\nuniform sampler2D iChannel2;\n\nvec3 getLightPos(vec3 ratio) {\n  vec2 delta = vec2(cos(iTime * 1.5), 0.0);\n  return vec3(0.5, 0.5, 1.0) * ratio + vec3(delta, 0.0) * ratio;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  vec3 ratio = vec3(iResolution.x / iResolution.y, 1.0, 1.0);\n    \n  vec3 viewPos = vec3(0.5, 0.5, 1.0) * ratio;\n  \n  vec3 objectDiffuse = texture2D(iChannel0, uv).rgb;\n  vec3 objectSpecular = texture2D(iChannel1, uv).rgb;\n  \n  vec3 fragNormal = texture2D(iChannel2, uv).rgb;\n  // transforms from [-1,1] to [0,1]\n  fragNormal = normalize(fragNormal * 2.0 - 1.0); \n  vec3 fragPos = vec3(uv, 0.0) * ratio;\n  \n  vec3 lightColor = vec3(1.0, 1.0, 0.75);\n  vec3 lightPos = getLightPos(ratio);\n  vec3 lightDir = normalize(lightPos - fragPos);\n  \n  float ambientFactor = 0.1;\n  float diffuseFactor = dot(fragNormal, lightDir);\n  \n  vec3 viewDir = normalize(viewPos - fragPos);\n  vec3 reflectDir = reflect(-lightDir, fragNormal);  \n  float specularFactor = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);\n\n  vec3 result = vec3(0.0);\n  result += ambientFactor * objectDiffuse;\n  result += diffuseFactor * objectDiffuse;\n  result += specularFactor * objectSpecular;\n  result *= lightColor;\n  \n  gl_FragColor = vec4(result, 1.0);\n}",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\nuniform sampler2D iChannel0;\nuniform sampler2D iChannel1;\nuniform sampler2D iChannel2;\n\nvec3 getLightPos(vec3 ratio) {\n  vec2 delta = vec2(cos(iTime * 1.5), 0.0);\n  return vec3(0.5, 0.5, 1.0) * ratio + vec3(delta, 0.0) * ratio;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  vec3 ratio = vec3(iResolution.x / iResolution.y, 1.0, 1.0);\n  \n  vec3 viewPos = vec3(0.5, 0.5, 1.0) * ratio;\n  \n  vec3 objectDiffuse = texture2D(iChannel0, uv).rgb;\n  vec3 objectSpecular = texture2D(iChannel1, uv).rgb;\n  \n  vec3 fragNormal = vec3(0.0, 0.0, 1.0);\n  vec3 fragPos = vec3(uv, 0.0) * ratio;\n  \n  vec3 lightColor = vec3(1.0, 1.0, 0.75);\n  vec3 lightPos = getLightPos(ratio);\n  vec3 lightDir = normalize(lightPos - fragPos);\n  \n  float ambientFactor = 0.1;\n  float diffuseFactor = dot(fragNormal, lightDir);\n  \n  vec3 viewDir = normalize(viewPos - fragPos);\n  vec3 reflectDir = reflect(-lightDir, fragNormal);  \n  float specularFactor = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);\n  \n  vec3 result = vec3(0.0);\n  result += ambientFactor * objectDiffuse;\n  result += diffuseFactor * objectDiffuse;\n  result += specularFactor * objectSpecular;\n  result *= lightColor;\n\n  gl_FragColor = vec4(result, 1.0);\n}\n",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1,\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "We can use a 2D texture to store per-fragment normal data. This way we can sample a 2D texture to get a normal vector for that specific fragment.\n\n<br>\n\nColor vectors in a texture are represented as a 3D vector with an **r**, **g**, and **b** component. To store the normal vector in the texture, you need to map the components of the normal vector from [-1, 1] to [0,1]:\n```\nvec3 rgb = normal * 0.5 + 0.5; // transforms from [-1,1] to [0,1] \n```\nThus, if we want to get the normal vector from the normal map, we need to perform the inverse transformation:\n```\n// obtain normal from normal map in range [0,1]\nnormal = texture(normalMap, texCoords).rgb;\n\n// transforms from [0,1] to [-1,1] \nnormal = normalize(normal * 2.0 - 1.0);\n```\n\n*A normal vector written to a normal map is usually normalized. However, when writing a value to a texture and then reading it from the texture, rounding or conversion errors may occur, causing the vector to be greater or less than one unit in length. Applying normalization ensures that the vector is accurately normalized and does not cause unexpected artefacts or visualisation errors.*\n\n<br>\n\nNow the sampled normal vector can be used for upcoming lighting calculations.\n\n### Task\nSample the normal map - `Channel2` - to retrieve the fragment's corresponding normal vector.",
                                "hints": [],
                                "restrictions": [],
                                "order": 11,
                                "cost": 5,
                                "threshold": 95,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [
                                    {
                                        "index": 0
                                    },
                                    {
                                        "index": 1
                                    },
                                    {
                                        "index": 2
                                    }
                                ],
                                "animated": true,
                                "animationSteps": 5,
                                "animationStepTime": 1000,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\nuniform sampler2D iChannel0;\nuniform sampler2D iChannel1;\nuniform sampler2D iChannel2;\n\nvec3 getLightPos(vec3 ratio) {\n  vec2 delta = vec2(cos(iTime * 1.5), 0.0);\n  return vec3(0.5, 0.5, 1.0) * ratio + vec3(delta, 0.0) * ratio;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  vec3 ratio = vec3(iResolution.x / iResolution.y, 1.0, 1.0);\n  \n  vec3 viewPos = vec3(0.5, 0.5, 1.0) * ratio;\n  \n  vec3 objectDiffuse = texture2D(iChannel0, uv).rgb;\n  vec3 objectSpecular = texture2D(iChannel1, uv).rgb;\n  \n  vec3 fragNormal = vec3(0.0, 0.0, 1.0);\n  vec3 fragPos = vec3(uv, 0.0) * ratio;\n  \n  vec3 lightColor = vec3(1.0, 1.0, 0.75);\n  vec3 lightPos = getLightPos(ratio);\n  vec3 lightDir = normalize(lightPos - fragPos);\n  \n  float ambientFactor = 0.1;\n  float diffuseFactor = dot(fragNormal, lightDir);\n  \n  vec3 viewDir = normalize(viewPos - fragPos);\n  vec3 reflectDir = reflect(-lightDir, fragNormal);  \n  float specularFactor = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);\n  \n  vec3 result = vec3(0.0);\n  result += ambientFactor * objectDiffuse;\n  result += diffuseFactor * objectDiffuse;\n  result += specularFactor * objectSpecular;\n  result *= lightColor;\n\n  gl_FragColor = vec4(result, 1.0);\n}\n",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\nuniform sampler2D iChannel0;\nuniform sampler2D iChannel1;\nuniform sampler2D iChannel2;\n\nvec3 getLightPos(vec3 ratio) {\n  vec2 delta = vec2(cos(iTime * 1.5), 0.0);\n  return vec3(0.5, 0.5, 1.0) * ratio + vec3(delta, 0.0) * ratio;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  vec3 ratio = vec3(iResolution.x / iResolution.y, 1.0, 1.0);\n  \n  vec3 viewPos = vec3(0.5, 0.5, 1.0) * ratio;\n  \n  vec3 objectDiffuse = texture2D(iChannel0, uv).rgb;\n  vec3 objectSpecular = texture2D(iChannel1, uv).rgb;\n  \n  vec3 fragNormal = vec3(0.0, 0.0, 1.0);\n  vec3 fragPos = vec3(uv, 0.0) * ratio;\n  \n  vec3 lightColor = vec3(1.0, 1.0, 0.75);\n  vec3 lightPos = getLightPos(ratio);\n  vec3 lightDir = normalize(lightPos - fragPos);\n  \n  float ambientFactor = 0.1;\n  float diffuseFactor = dot(fragNormal, lightDir);\n  \n  vec3 viewDir = normalize(viewPos - fragPos);\n  vec3 reflectDir = reflect(-lightDir, fragNormal);  \n  float specularFactor = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);\n  \n  vec3 result = vec3(0.0);\n  result += ambientFactor * objectDiffuse;\n  result += diffuseFactor * objectDiffuse;\n  result += specularFactor * objectSpecular;\n  result *= lightColor;\n\n  gl_FragColor = vec4(result, 1.0);\n}\n",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 82,
                        "slug": "spot-light",
                        "moduleId": 6,
                        "name": "Spot Light",
                        "order": 12,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": true,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 82,
                                "slug": "spot-light",
                                "moduleId": 6,
                                "name": "Spot Light",
                                "vertexShader": "uniform float iTime;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nmat4 getModel() {\n  float angle = iTime;\n  \n  vec4 r1 = vec4(cos(angle), 0.0, sin(angle), 0.0);\n  vec4 r2 = vec4(0.0, 1.0, 0.0, 0.0);\n  vec4 r3 = vec4(-sin(angle), 0.0, cos(angle), 0.0);\n  vec4 r4 = vec4(0.0, 0.0, 0.0, 1.0);\n  mat4 transform = transpose(mat4(r1, r2, r3, r4));\n  \n  return modelMatrix;\n}\n\nvoid main() {\n  mat4 model = getModel();\n  \n  vUv = uv;\n  vPos = vec3(model * vec4(position, 1.0));\n  \n  vNormal = normalize(mat3(transpose(inverse(model))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * model * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform float iTime;\nuniform sampler2D iChannel0;\nuniform sampler2D iChannel1;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvec3 getSpotLightDir() {\n  float dx = cos(iTime) * 0.25;\n  float dy = sin(iTime) * 0.25;\n  return normalize(vec3(0.0, 0.0, -1.0) + vec3(dx, dy, 0.0));\n}\n\nvoid main() {\n  vec3 viewPos = vec3(-4.0, 0.0, 2.5);\n  \n  vec3 objectColor = texture2D(iChannel0, vUv).rgb;\n  vec3 objectSpecular = texture2D(iChannel1, vUv).rgb;\n  vec3 fragNormal = normalize(vNormal);\n  vec3 fragPos = vPos;\n  \n  vec3 lightColor = vec3(1.0, 1.0, 0.75);\n  vec3 lightPos = vec3(0.0, 0.0, 2.0);\n  vec3 lightDir = normalize(lightPos - fragPos);\n  \n  float ambient = 0.2;\n  float diffuse = dot(fragNormal, lightDir);\n  \n  vec3 viewDir = normalize(viewPos - fragPos);\n  vec3 reflectDir = reflect(-lightDir, fragNormal);  \n  float specular = max(dot(viewDir, reflectDir), 0.0);\n  specular = pow(specular, 32.0);\n\n  vec3 spotLightDir = getSpotLightDir();\n  float theta = dot(spotLightDir, -lightDir);\n  float cutOff = cos(radians(12.0));\n  float intensity = step(cutOff, theta);\n\n  diffuse *= intensity;\n  specular *= intensity;\n  \n  vec3 result = vec3(0.0);\n  result += ambient * objectColor;\n  result += diffuse * objectColor;\n  result += specular * objectSpecular;\n  result *= lightColor;\n  \n  gl_FragColor = vec4(result, 1.0);\n}",
                                "defaultVertexShader": "uniform float iTime;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nmat4 getModel() {\n  float angle = iTime;\n  \n  vec4 r1 = vec4(cos(angle), 0.0, sin(angle), 0.0);\n  vec4 r2 = vec4(0.0, 1.0, 0.0, 0.0);\n  vec4 r3 = vec4(-sin(angle), 0.0, cos(angle), 0.0);\n  vec4 r4 = vec4(0.0, 0.0, 0.0, 1.0);\n  mat4 transform = transpose(mat4(r1, r2, r3, r4));\n  \n  return modelMatrix;\n}\n\nvoid main() {\n  mat4 model = getModel();\n  \n  vUv = uv;\n  vPos = vec3(model * vec4(position, 1.0));\n  \n  vNormal = normalize(mat3(transpose(inverse(model))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * model * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform float iTime;\nuniform sampler2D iChannel0;\nuniform sampler2D iChannel1;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvec3 getSpotLightDir() {\n  float dx = cos(iTime) * 0.25;\n  float dy = sin(iTime) * 0.25;\n  return normalize(vec3(0.0, 0.0, -1.0) + vec3(dx, dy, 0.0));\n}\n\nvoid main() {\n  vec3 viewPos = vec3(-4.0, 0.0, 2.5);\n  \n  vec3 objectColor = texture2D(iChannel0, vUv).rgb;\n  vec3 objectSpecular = texture2D(iChannel1, vUv).rgb;\n  vec3 fragNormal = normalize(vNormal);\n  vec3 fragPos = vPos;\n  \n  vec3 lightColor = vec3(1.0, 1.0, 0.75);\n  vec3 lightPos = vec3(0.0, 0.0, 2.0);\n  vec3 lightDir = normalize(lightPos - fragPos);\n  \n  float ambient = 0.2;\n  float diffuse = dot(fragNormal, lightDir);\n  \n  vec3 viewDir = normalize(viewPos - fragPos);\n  vec3 reflectDir = reflect(-lightDir, fragNormal);  \n  float specular = max(dot(viewDir, reflectDir), 0.0);\n  specular = pow(specular, 32.0);\n  \n  vec3 result = vec3(0.0);\n  result += ambient * objectColor;\n  result += diffuse * objectColor;\n  result += specular * objectSpecular;\n  result *= lightColor;\n  \n  gl_FragColor = vec4(result, 1.0);\n}",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":\"0\",\"y\":\"0\",\"z\":\"2\"},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":\"45\",\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"object\":{\"position\":{\"x\":0,\"y\":\"0\",\"z\":0},\"rotation\":{\"x\":\"0.0\",\"y\":\"-0.6\",\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":\"2\"},\"backgroundRGBA\":\"CCCCCC\",\"background\":13421772}",
                                "description": "A spotlight is a light source that is located somewhere in the environment that, instead of shooting light rays in all directions, only shoots them in a specific direction. The result is that only the objects within a certain radius of the spotlight's direction are lit and everything else stays dark.\n\n<br>\n\n![](/files/spot-light.png)\n\n<br>\n\nA spotlight is represented by a position **P**, a direction **L** and a cutoff angle **φ** that specifies the radius of the spotlight.\n\n<br>\n\nTo determine whether the fragment is illuminated, we need to find the angle between the spotlight direction **L** and the direction from the spotlight position to the position of the fragment **F**. If this angle **θ** is greater than the cutoff angle **φ**, the fragment is not illuminated.\n\n### Task\nFor each fragment calculate if the fragment is between the spotlight's cutoff directions and if so, lit the fragment with specular and diffused light. Leave ambient light unchanged. Spot light direction is defined by `getSpotLightDir` function, cutoff angle is `12` degrees.",
                                "hints": [],
                                "restrictions": [],
                                "order": 12,
                                "cost": 5,
                                "threshold": 95,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [
                                    {
                                        "index": 0
                                    },
                                    {
                                        "index": 1
                                    }
                                ],
                                "animated": true,
                                "animationSteps": 12,
                                "animationStepTime": 500,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "uniform float iTime;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nmat4 getModel() {\n  float angle = iTime;\n  \n  vec4 r1 = vec4(cos(angle), 0.0, sin(angle), 0.0);\n  vec4 r2 = vec4(0.0, 1.0, 0.0, 0.0);\n  vec4 r3 = vec4(-sin(angle), 0.0, cos(angle), 0.0);\n  vec4 r4 = vec4(0.0, 0.0, 0.0, 1.0);\n  mat4 transform = transpose(mat4(r1, r2, r3, r4));\n  \n  return modelMatrix;\n}\n\nvoid main() {\n  mat4 model = getModel();\n  \n  vUv = uv;\n  vPos = vec3(model * vec4(position, 1.0));\n  \n  vNormal = normalize(mat3(transpose(inverse(model))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * model * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform float iTime;\nuniform sampler2D iChannel0;\nuniform sampler2D iChannel1;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvec3 getSpotLightDir() {\n  float dx = cos(iTime) * 0.25;\n  float dy = sin(iTime) * 0.25;\n  return normalize(vec3(0.0, 0.0, -1.0) + vec3(dx, dy, 0.0));\n}\n\nvoid main() {\n  vec3 viewPos = vec3(-4.0, 0.0, 2.5);\n  \n  vec3 objectColor = texture2D(iChannel0, vUv).rgb;\n  vec3 objectSpecular = texture2D(iChannel1, vUv).rgb;\n  vec3 fragNormal = normalize(vNormal);\n  vec3 fragPos = vPos;\n  \n  vec3 lightColor = vec3(1.0, 1.0, 0.75);\n  vec3 lightPos = vec3(0.0, 0.0, 2.0);\n  vec3 lightDir = normalize(lightPos - fragPos);\n  \n  float ambient = 0.2;\n  float diffuse = dot(fragNormal, lightDir);\n  \n  vec3 viewDir = normalize(viewPos - fragPos);\n  vec3 reflectDir = reflect(-lightDir, fragNormal);  \n  float specular = max(dot(viewDir, reflectDir), 0.0);\n  specular = pow(specular, 32.0);\n  \n  vec3 result = vec3(0.0);\n  result += ambient * objectColor;\n  result += diffuse * objectColor;\n  result += specular * objectSpecular;\n  result *= lightColor;\n  \n  gl_FragColor = vec4(result, 1.0);\n}",
                            "defaultVertexShader": "uniform float iTime;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nmat4 getModel() {\n  float angle = iTime;\n  \n  vec4 r1 = vec4(cos(angle), 0.0, sin(angle), 0.0);\n  vec4 r2 = vec4(0.0, 1.0, 0.0, 0.0);\n  vec4 r3 = vec4(-sin(angle), 0.0, cos(angle), 0.0);\n  vec4 r4 = vec4(0.0, 0.0, 0.0, 1.0);\n  mat4 transform = transpose(mat4(r1, r2, r3, r4));\n  \n  return modelMatrix;\n}\n\nvoid main() {\n  mat4 model = getModel();\n  \n  vUv = uv;\n  vPos = vec3(model * vec4(position, 1.0));\n  \n  vNormal = normalize(mat3(transpose(inverse(model))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * model * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform float iTime;\nuniform sampler2D iChannel0;\nuniform sampler2D iChannel1;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvec3 getSpotLightDir() {\n  float dx = cos(iTime) * 0.25;\n  float dy = sin(iTime) * 0.25;\n  return normalize(vec3(0.0, 0.0, -1.0) + vec3(dx, dy, 0.0));\n}\n\nvoid main() {\n  vec3 viewPos = vec3(-4.0, 0.0, 2.5);\n  \n  vec3 objectColor = texture2D(iChannel0, vUv).rgb;\n  vec3 objectSpecular = texture2D(iChannel1, vUv).rgb;\n  vec3 fragNormal = normalize(vNormal);\n  vec3 fragPos = vPos;\n  \n  vec3 lightColor = vec3(1.0, 1.0, 0.75);\n  vec3 lightPos = vec3(0.0, 0.0, 2.0);\n  vec3 lightDir = normalize(lightPos - fragPos);\n  \n  float ambient = 0.2;\n  float diffuse = dot(fragNormal, lightDir);\n  \n  vec3 viewDir = normalize(viewPos - fragPos);\n  vec3 reflectDir = reflect(-lightDir, fragNormal);  \n  float specular = max(dot(viewDir, reflectDir), 0.0);\n  specular = pow(specular, 32.0);\n  \n  vec3 result = vec3(0.0);\n  result += ambient * objectColor;\n  result += diffuse * objectColor;\n  result += specular * objectSpecular;\n  result *= lightColor;\n  \n  gl_FragColor = vec4(result, 1.0);\n}",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 83,
                        "slug": "spot-light-soft-edges",
                        "moduleId": 6,
                        "name": "Spot Light - Soft edges",
                        "order": 13,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": true,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 83,
                                "slug": "spot-light-soft-edges",
                                "moduleId": 6,
                                "name": "Spot Light - Soft edges",
                                "vertexShader": "uniform float iTime;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nmat4 getModel() {\n  float angle = iTime;\n  \n  vec4 r1 = vec4(cos(angle), 0.0, sin(angle), 0.0);\n  vec4 r2 = vec4(0.0, 1.0, 0.0, 0.0);\n  vec4 r3 = vec4(-sin(angle), 0.0, cos(angle), 0.0);\n  vec4 r4 = vec4(0.0, 0.0, 0.0, 1.0);\n  mat4 transform = transpose(mat4(r1, r2, r3, r4));\n  \n  return modelMatrix;\n}\n\nvoid main() {\n  mat4 model = getModel();\n  \n  vUv = uv;\n  vPos = vec3(model * vec4(position, 1.0));\n  \n  vNormal = normalize(mat3(transpose(inverse(model))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * model * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform float iTime;\nuniform sampler2D iChannel0;\nuniform sampler2D iChannel1;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvec3 getSpotLightDir() {\n  float dx = cos(iTime) * 0.25;\n  float dy = sin(iTime) * 0.25;\n  return normalize(vec3(0.0, 0.0, -1.0) + vec3(dx, dy, 0.0));\n}\n\nvoid main() {\n  vec3 viewPos = vec3(-4.0, 0.0, 2.5);\n  \n  vec3 objectColor = texture2D(iChannel0, vUv).rgb;\n  vec3 objectSpecular = texture2D(iChannel1, vUv).rgb;\n  vec3 fragNormal = normalize(vNormal);\n  vec3 fragPos = vPos;\n  \n  vec3 lightColor = vec3(1.0, 1.0, 0.75);\n  vec3 lightPos = vec3(0.0, 0.0, 2.0);\n  vec3 lightDir = normalize(lightPos - fragPos);\n  \n  float ambient = 0.2;\n  float diffuse = dot(fragNormal, lightDir);\n  \n  vec3 viewDir = normalize(viewPos - fragPos);\n  vec3 reflectDir = reflect(-lightDir, fragNormal);  \n  float specular = max(dot(viewDir, reflectDir), 0.0);\n  specular = pow(specular, 32.0);\n\n  vec3 spotLightDir = getSpotLightDir();\n  float theta = dot(spotLightDir, -lightDir);\n  float cutOff = cos(radians(10.0));\n  float outerCutOff = cos(radians(12.0));\n  float epsilon = cutOff - outerCutOff;\n  float intensity = clamp((theta - outerCutOff) / epsilon, 0.0, 1.0);\n\n  diffuse *= intensity;\n  specular *= intensity;\n  \n  vec3 result = vec3(0.0);\n  result += ambient * objectColor;\n  result += diffuse * objectColor;\n  result += specular * objectSpecular;\n  result *= lightColor;\n  \n  gl_FragColor = vec4(result, 1.0);\n}",
                                "defaultVertexShader": "uniform float iTime;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nmat4 getModel() {\n  float angle = iTime;\n  \n  vec4 r1 = vec4(cos(angle), 0.0, sin(angle), 0.0);\n  vec4 r2 = vec4(0.0, 1.0, 0.0, 0.0);\n  vec4 r3 = vec4(-sin(angle), 0.0, cos(angle), 0.0);\n  vec4 r4 = vec4(0.0, 0.0, 0.0, 1.0);\n  mat4 transform = transpose(mat4(r1, r2, r3, r4));\n  \n  return modelMatrix;\n}\n\nvoid main() {\n  mat4 model = getModel();\n  \n  vUv = uv;\n  vPos = vec3(model * vec4(position, 1.0));\n  \n  vNormal = normalize(mat3(transpose(inverse(model))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * model * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform float iTime;\nuniform sampler2D iChannel0;\nuniform sampler2D iChannel1;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvec3 getSpotLightDir() {\n  float dx = cos(iTime) * 0.25;\n  float dy = sin(iTime) * 0.25;\n  return normalize(vec3(0.0, 0.0, -1.0) + vec3(dx, dy, 0.0));\n}\n\nvoid main() {\n  vec3 viewPos = vec3(-4.0, 0.0, 2.5);\n  \n  vec3 objectColor = texture2D(iChannel0, vUv).rgb;\n  vec3 objectSpecular = texture2D(iChannel1, vUv).rgb;\n  vec3 fragNormal = normalize(vNormal);\n  vec3 fragPos = vPos;\n  \n  vec3 lightColor = vec3(1.0, 1.0, 0.75);\n  vec3 lightPos = vec3(0.0, 0.0, 2.0);\n  vec3 lightDir = normalize(lightPos - fragPos);\n  \n  float ambient = 0.2;\n  float diffuse = dot(fragNormal, lightDir);\n  \n  vec3 viewDir = normalize(viewPos - fragPos);\n  vec3 reflectDir = reflect(-lightDir, fragNormal);  \n  float specular = max(dot(viewDir, reflectDir), 0.0);\n  specular = pow(specular, 32.0);\n  \n  vec3 result = vec3(0.0);\n  result += ambient * objectColor;\n  result += diffuse * objectColor;\n  result += specular * objectSpecular;\n  result *= lightColor;\n  \n  gl_FragColor = vec4(result, 1.0);\n}",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":\"0\",\"y\":\"0\",\"z\":\"2\"},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":\"45\",\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":\"-0.6\",\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":\"2\",\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"backgroundRGBA\":\"CCCCCC\",\"background\":13421772}",
                                "description": "To simulate a spotlight with smooth edges, we use an inner and an outer cone. The outer cone gradually fades the light from the inner cone to the edges of the outer cone.\n\n<br>\n\n### Implementaion Steps\n\n<br>\n\n1\\. Define the angles for the inner and outer cones relative to the spotlight's direction vector:\n\n- • **Inner cone** represents the core area of the spotlight where the light intensity is at its maximum.\n\n- • **Outer cone** represents the area where the light gradually fades to zero.\n\n2\\. Determine light intensity:\n\n- • **Inside inner cone**. If a fragment is within the inner cone, its light intensity is 1.0.\n\n- • **Outside outer cone**. If a fragment is outside the outer cone, its light intensity is 0.0.\n\n- • **Between cones**. If a fragment is between the inner and outer cones, calculate an intensity value between 0.0 and 1.0 based on its position.\n\n### Task\nFor each fragment calculate if the fragment is between the spotlight's cutoff directions and if so, lit the fragment with specular and diffused light. If the fragment is between the inner and the outer cutoff, calculate an intensity value between 0.0 and 1.0. \n\n<br>\n\nThe Spot light direction is defined by `getSpotLightDir` function, inner cutoff angle is `10` degrees, outer is `12`.",
                                "hints": [],
                                "restrictions": [],
                                "order": 13,
                                "cost": 5,
                                "threshold": 95,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [
                                    {
                                        "index": 0
                                    },
                                    {
                                        "index": 1
                                    }
                                ],
                                "animated": true,
                                "animationSteps": 12,
                                "animationStepTime": 500,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "uniform float iTime;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nmat4 getModel() {\n  float angle = iTime;\n  \n  vec4 r1 = vec4(cos(angle), 0.0, sin(angle), 0.0);\n  vec4 r2 = vec4(0.0, 1.0, 0.0, 0.0);\n  vec4 r3 = vec4(-sin(angle), 0.0, cos(angle), 0.0);\n  vec4 r4 = vec4(0.0, 0.0, 0.0, 1.0);\n  mat4 transform = transpose(mat4(r1, r2, r3, r4));\n  \n  return modelMatrix;\n}\n\nvoid main() {\n  mat4 model = getModel();\n  \n  vUv = uv;\n  vPos = vec3(model * vec4(position, 1.0));\n  \n  vNormal = normalize(mat3(transpose(inverse(model))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * model * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform float iTime;\nuniform sampler2D iChannel0;\nuniform sampler2D iChannel1;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvec3 getSpotLightDir() {\n  float dx = cos(iTime) * 0.25;\n  float dy = sin(iTime) * 0.25;\n  return normalize(vec3(0.0, 0.0, -1.0) + vec3(dx, dy, 0.0));\n}\n\nvoid main() {\n  vec3 viewPos = vec3(-4.0, 0.0, 2.5);\n  \n  vec3 objectColor = texture2D(iChannel0, vUv).rgb;\n  vec3 objectSpecular = texture2D(iChannel1, vUv).rgb;\n  vec3 fragNormal = normalize(vNormal);\n  vec3 fragPos = vPos;\n  \n  vec3 lightColor = vec3(1.0, 1.0, 0.75);\n  vec3 lightPos = vec3(0.0, 0.0, 2.0);\n  vec3 lightDir = normalize(lightPos - fragPos);\n  \n  float ambient = 0.2;\n  float diffuse = dot(fragNormal, lightDir);\n  \n  vec3 viewDir = normalize(viewPos - fragPos);\n  vec3 reflectDir = reflect(-lightDir, fragNormal);  \n  float specular = max(dot(viewDir, reflectDir), 0.0);\n  specular = pow(specular, 32.0);\n  \n  vec3 result = vec3(0.0);\n  result += ambient * objectColor;\n  result += diffuse * objectColor;\n  result += specular * objectSpecular;\n  result *= lightColor;\n  \n  gl_FragColor = vec4(result, 1.0);\n}",
                            "defaultVertexShader": "uniform float iTime;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nmat4 getModel() {\n  float angle = iTime;\n  \n  vec4 r1 = vec4(cos(angle), 0.0, sin(angle), 0.0);\n  vec4 r2 = vec4(0.0, 1.0, 0.0, 0.0);\n  vec4 r3 = vec4(-sin(angle), 0.0, cos(angle), 0.0);\n  vec4 r4 = vec4(0.0, 0.0, 0.0, 1.0);\n  mat4 transform = transpose(mat4(r1, r2, r3, r4));\n  \n  return modelMatrix;\n}\n\nvoid main() {\n  mat4 model = getModel();\n  \n  vUv = uv;\n  vPos = vec3(model * vec4(position, 1.0));\n  \n  vNormal = normalize(mat3(transpose(inverse(model))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * model * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform float iTime;\nuniform sampler2D iChannel0;\nuniform sampler2D iChannel1;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvec3 getSpotLightDir() {\n  float dx = cos(iTime) * 0.25;\n  float dy = sin(iTime) * 0.25;\n  return normalize(vec3(0.0, 0.0, -1.0) + vec3(dx, dy, 0.0));\n}\n\nvoid main() {\n  vec3 viewPos = vec3(-4.0, 0.0, 2.5);\n  \n  vec3 objectColor = texture2D(iChannel0, vUv).rgb;\n  vec3 objectSpecular = texture2D(iChannel1, vUv).rgb;\n  vec3 fragNormal = normalize(vNormal);\n  vec3 fragPos = vPos;\n  \n  vec3 lightColor = vec3(1.0, 1.0, 0.75);\n  vec3 lightPos = vec3(0.0, 0.0, 2.0);\n  vec3 lightDir = normalize(lightPos - fragPos);\n  \n  float ambient = 0.2;\n  float diffuse = dot(fragNormal, lightDir);\n  \n  vec3 viewDir = normalize(viewPos - fragPos);\n  vec3 reflectDir = reflect(-lightDir, fragNormal);  \n  float specular = max(dot(viewDir, reflectDir), 0.0);\n  specular = pow(specular, 32.0);\n  \n  vec3 result = vec3(0.0);\n  result += ambient * objectColor;\n  result += diffuse * objectColor;\n  result += specular * objectSpecular;\n  result *= lightColor;\n  \n  gl_FragColor = vec4(result, 1.0);\n}",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 91,
                        "slug": "metallic",
                        "moduleId": 6,
                        "name": "Metallic",
                        "order": 17,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": true,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 91,
                                "slug": "metallic",
                                "moduleId": 6,
                                "name": "Metallic",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\nuniform sampler2D iChannel0;\nuniform sampler2D iChannel1;\nuniform sampler2D iChannel2;\n\nvec3 getLightPos(vec3 ratio) {\n  vec2 delta = vec2(cos(iTime * 1.0), 0.0);\n  return vec3(0.5, 0.5, 1.0) * ratio + vec3(delta, 0.0) * ratio;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  vec3 ratio = vec3(iResolution.x / iResolution.y, 1.0, 1.0);\n  \n  vec3 viewPos = vec3(0.5, 0.5, 1.0) * ratio;\n  \n  vec3 fragDiffuse = pow(texture2D(iChannel0, uv).rgb, vec3(2.2));\n  vec3 fragNormal = normalize(texture2D(iChannel1, uv).rgb * 2.0 - 1.0);\n  float fragMetallic = texture2D(iChannel2, uv).r;\n  \n  vec3 fragPos = vec3(uv, 0.0) * ratio;\n  vec3 lightColor = vec3(1.0, 1.0, 0.75);\n  vec3 lightPos = getLightPos(ratio);\n  vec3 lightDir = normalize(lightPos - fragPos);\n  vec3 viewDir = normalize(viewPos - fragPos);\n  vec3 halfwayDir = normalize(viewDir + lightDir);\n  \n  float diffuseFactor = dot(fragNormal, lightDir);\n  float specularFactor = pow(max(dot(fragNormal, halfwayDir), 0.0), 32.0);\n\t\n  vec3 surfaceReflectance = vec3(0.04);\n  surfaceReflectance = mix(surfaceReflectance, fragDiffuse, fragMetallic);\n  \n  vec3 surfaceDiffuse = vec3(1.0) - surfaceReflectance;\n  surfaceDiffuse *= 1.0 - fragMetallic;\n  \n  vec3 specular = surfaceReflectance * specularFactor;\n  vec3 diffuse = surfaceDiffuse * diffuseFactor * fragDiffuse;\n  \n  vec3 result = (diffuse + specular) * lightColor;\n\n  gl_FragColor = vec4(result, 1.0);\n}",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\nuniform sampler2D iChannel0;\nuniform sampler2D iChannel1;\nuniform sampler2D iChannel2;\n\nvec3 getLightPos(vec3 ratio) {\n  vec2 delta = vec2(cos(iTime * 1.0), 0.0);\n  return vec3(0.5, 0.5, 1.0) * ratio + vec3(delta, 0.0) * ratio;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  vec3 ratio = vec3(iResolution.x / iResolution.y, 1.0, 1.0);\n    \n  vec3 viewPos = vec3(0.5, 0.5, 1.0) * ratio;\n  \n  vec3 fragDiffuse = pow(texture2D(iChannel0, uv).rgb, vec3(2.2));\n  vec3 fragNormal = normalize(texture2D(iChannel1, uv).rgb * 2.0 - 1.0);\n  vec3 fragSpecular = texture2D(iChannel2, uv).rgb;\n  \n  vec3 fragPos = vec3(uv, 0.0) * ratio;\n  vec3 lightColor = vec3(1.0, 1.0, 0.75);\n  vec3 lightPos = getLightPos(ratio);\n  vec3 lightDir = normalize(lightPos - fragPos);\n  vec3 viewDir = normalize(viewPos - fragPos);\n  vec3 halfwayDir = normalize(viewDir + lightDir);\n  \n  float diffuseFactor = dot(fragNormal, lightDir);\n  float specularFactor = pow(max(dot(fragNormal, halfwayDir), 0.0), 32.0);\n  \n  vec3 result = (diffuseFactor * fragDiffuse + specularFactor * fragSpecular) * lightColor;\n  \n  gl_FragColor = vec4(result, 1.0);\n}",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1,\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "### Interaction with Light\n\n<br>\n\nMetal surfaces interact with light differently than non-metal (dielectric) surfaces. While both obey the laws of refraction and reflection, metals absorb all refracted light without scattering, leaving only specularly reflected light. This means metal surfaces do not have a diffuse color.\n\n<br>\n\n### Metallicity Map\n\n<br>\n\nSimilar to specular or color maps, a metallicity map indicates the metallicity of each fragment of an object. When a metallicity map is available, specular maps are typically not used. Instead, the specular parameter is calculated based on the fragment's metallicity.\n\n<br>\n\nBefore calculating the specular reflection of a surface, it is necessary to determine its basic reflectivity:\n```\nvec3 F0 = vec3(0.04);\nF0 = mix(F0, surfaceColor.rgb, metalness);\n```\n\nBased on how metallic a surface is, we either take the dielectric base reflectivity `F0` or the surface color. Because metallic surfaces absorb all refracted light, they have no diffuse reflections and we can directly use the surface color texture as their base reflectivity.\n\n<br>\n\nFor most dielectrics, the base reflectance is kept at `0.04` and gives physically plausible results without the need to specify an additional surface parameter.\n\n<br>\n\n*Theoretically, the metallicity of a surface takes only two values: it is either a metal or it is not; the surface cannot be both. However, most render pipelines allow you to adjust the metallicity of a surface linearly between 0.0 and 1.0. This is necessary to create a surface, for example, with small particles of dust and sand, scratches on the metal surface.*\n\n<br>\n\nWe can use the `F0` value to denote the contribution of the source to the specular reflection `kS` of the surface. From the quantity we can also get the refractive index `kD`:\n\n```\nvec3 kS = F;\nvec3 kD = vec3(1.0) - kS;\n  \nkD *= 1.0 - metallic;\t\n```\n\nSince we consider the value `kS` to represent the amount of light energy reflected by the surface, then subtracting it from `1.0`, we get the energy of refracted light `kD`. Also, since metals do not refract light and do not have a diffuse component of re-emitted light, the `kD` component will be modulated to be zero for a completely metallic material.\n\n### Task\nUse the metallic map from `iChannel2` to calculate the specular and diffuse components of light.",
                                "hints": [],
                                "restrictions": [],
                                "order": 17,
                                "cost": 5,
                                "threshold": 95,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [
                                    {
                                        "index": 0
                                    },
                                    {
                                        "index": 1
                                    },
                                    {
                                        "index": 2
                                    }
                                ],
                                "animated": true,
                                "animationSteps": 6,
                                "animationStepTime": 500,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\nuniform sampler2D iChannel0;\nuniform sampler2D iChannel1;\nuniform sampler2D iChannel2;\n\nvec3 getLightPos(vec3 ratio) {\n  vec2 delta = vec2(cos(iTime * 1.0), 0.0);\n  return vec3(0.5, 0.5, 1.0) * ratio + vec3(delta, 0.0) * ratio;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  vec3 ratio = vec3(iResolution.x / iResolution.y, 1.0, 1.0);\n    \n  vec3 viewPos = vec3(0.5, 0.5, 1.0) * ratio;\n  \n  vec3 fragDiffuse = pow(texture2D(iChannel0, uv).rgb, vec3(2.2));\n  vec3 fragNormal = normalize(texture2D(iChannel1, uv).rgb * 2.0 - 1.0);\n  vec3 fragSpecular = texture2D(iChannel2, uv).rgb;\n  \n  vec3 fragPos = vec3(uv, 0.0) * ratio;\n  vec3 lightColor = vec3(1.0, 1.0, 0.75);\n  vec3 lightPos = getLightPos(ratio);\n  vec3 lightDir = normalize(lightPos - fragPos);\n  vec3 viewDir = normalize(viewPos - fragPos);\n  vec3 halfwayDir = normalize(viewDir + lightDir);\n  \n  float diffuseFactor = dot(fragNormal, lightDir);\n  float specularFactor = pow(max(dot(fragNormal, halfwayDir), 0.0), 32.0);\n  \n  vec3 result = (diffuseFactor * fragDiffuse + specularFactor * fragSpecular) * lightColor;\n  \n  gl_FragColor = vec4(result, 1.0);\n}",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\nuniform sampler2D iChannel0;\nuniform sampler2D iChannel1;\nuniform sampler2D iChannel2;\n\nvec3 getLightPos(vec3 ratio) {\n  vec2 delta = vec2(cos(iTime * 1.0), 0.0);\n  return vec3(0.5, 0.5, 1.0) * ratio + vec3(delta, 0.0) * ratio;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  vec3 ratio = vec3(iResolution.x / iResolution.y, 1.0, 1.0);\n    \n  vec3 viewPos = vec3(0.5, 0.5, 1.0) * ratio;\n  \n  vec3 fragDiffuse = pow(texture2D(iChannel0, uv).rgb, vec3(2.2));\n  vec3 fragNormal = normalize(texture2D(iChannel1, uv).rgb * 2.0 - 1.0);\n  vec3 fragSpecular = texture2D(iChannel2, uv).rgb;\n  \n  vec3 fragPos = vec3(uv, 0.0) * ratio;\n  vec3 lightColor = vec3(1.0, 1.0, 0.75);\n  vec3 lightPos = getLightPos(ratio);\n  vec3 lightDir = normalize(lightPos - fragPos);\n  vec3 viewDir = normalize(viewPos - fragPos);\n  vec3 halfwayDir = normalize(viewDir + lightDir);\n  \n  float diffuseFactor = dot(fragNormal, lightDir);\n  float specularFactor = pow(max(dot(fragNormal, halfwayDir), 0.0), 32.0);\n  \n  vec3 result = (diffuseFactor * fragDiffuse + specularFactor * fragSpecular) * lightColor;\n  \n  gl_FragColor = vec4(result, 1.0);\n}",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 92,
                        "slug": "roughness-normal-distribution-function",
                        "moduleId": 6,
                        "name": "Roughness - Normal distribution function",
                        "order": 18,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": true,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 92,
                                "slug": "roughness-normal-distribution-function",
                                "moduleId": 6,
                                "name": "Roughness - Normal distribution function",
                                "vertexShader": "varying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  vPos = vec3(modelMatrix * vec4(position, 1.0));\n  \n  vNormal = normalize(mat3(transpose(inverse(modelMatrix))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform float iTime;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nfloat distributionGGX(vec3 N, vec3 H, float a) {\n    float a2     = a*a;\n    float NdotH  = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\t\n    float nom    = a2;\n    float denom  = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom        = 3.14 * denom * denom;\n\t\n    return nom / denom;\n}\n\nvoid main() {\n  vec3 viewPos = vec3(0.0, 0.0, 2.5);\n  \n  vec3 fragDiffuse = vec3(1.0, 0.6, 0.6);\n  vec3 fragNormal = normalize(vNormal);\n  float fragRoughness = 0.01 + (sin(iTime * 0.5) * 0.5 + 0.5) * 0.99;\n  \n  vec3 fragPos = vPos;\n  vec3 lightColor = vec3(1.0, 1.0, 0.75);\n  vec3 lightPos = vec3(-2.0, 2.0, 2.0);\n  vec3 lightDir = normalize(lightPos - fragPos);\n  vec3 viewDir = normalize(viewPos - fragPos);\n  vec3 halfwayDir = normalize(viewDir + lightDir);\n  \n  float specular = distributionGGX(fragNormal, halfwayDir, fragRoughness);\n    \n  vec3 result = specular * fragDiffuse * lightColor;\n\n  gl_FragColor = vec4(result, 1.0);\n}",
                                "postProcessShader": "",
                                "properties": "",
                                "defaultVertexShader": "varying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  vPos = vec3(modelMatrix * vec4(position, 1.0));\n  \n  vNormal = normalize(mat3(transpose(inverse(modelMatrix))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform float iTime;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvoid main() {\n  vec3 viewPos = vec3(0.0, 0.0, 2.5);\n  \n  vec3 fragDiffuse = vec3(1.0, 0.6, 0.6);\n  vec3 fragNormal = normalize(vNormal);\n  \n  vec3 fragPos = vPos;\n  vec3 lightColor = vec3(1.0, 1.0, 0.75);\n  vec3 lightPos = vec3(-2.0, 2.0, 2.0);\n  vec3 lightDir = normalize(lightPos - fragPos);\n  vec3 viewDir = normalize(viewPos - fragPos);\n  vec3 halfwayDir = normalize(viewDir + lightDir);\n  \n  float ambient = 0.2;\n  \n  float t = 1.0 - (sin(iTime * 0.5) * 0.5 + 0.5) * 0.99;\n  float shininess = 256.0 * t;\n  float specular = pow(max(dot(fragNormal, halfwayDir), 0.0),  shininess);\n    \n  vec3 result = specular * fragDiffuse * lightColor;\n\n  gl_FragColor = vec4(result, 1.0);\n}\n",
                                "defaultPostProcessShader": "",
                                "defaultProperties": "",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":\"0\",\"y\":\"0\",\"z\":\"1.4\"},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":\"45\",\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":\"0\",\"y\":\"0\",\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":\"3\",\"model\":null,\"meshes\":[{\"name\":\"main\",\"materialId\":0}],\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"materials\":[],\"actions\":[],\"backgroundRGBA\":\"CCCCCC\",\"background\":13421772,\"customDepthBufferTexture\":false,\"glslVersion\":1}",
                                "description": "The **Normal Distribution Function (NDF)** statistically approximates the relative surface area of microfacets that are exactly aligned with the halfway vector. \n\n<br>\n\n![](/files/ndf-microfacets-normals.png)\n\n<br>\n\nThese *microfacets* are tiny surface elements that collectively determine the overall roughness and reflective properties of a material. The **NDF** helps calculate how light interacts with a surface at the microscopic level, influencing the resulting shading and highlights.\n\n<br>\n\n### Mathematical Definition\n\n<br>\n\nOne commonly used NDF is the **Trowbridge-Reitz GGX**:\n\n$$\n\\text{NDF} = \\frac{r^2}{\\pi \\left( ( \\mathbf{n} \\cdot \\mathbf{h} )^2 \\times (r^2 - 1) + 1 \\right)^2}\n$$\n\n$r$ - surface roughness value, $\\mathbf{n}$ - surface normal, $\\mathbf{h}$ - the halfway vector.\n\n<br>\n\n### Roughness\n\n<br>\n\nThe roughness parameter $r$ is a key factor in the **NDF** and directly affects the appearance of a material's surface. Roughness controls the spread of microfacet orientations:\n\n<br>\n\n![](/files/roughness.png)\n\n<br>\n\nWhen the *roughness is low* (the surface is smooth), a highly concentrated number of microfacets are aligned to halfway vectors over a small radius. Due to this high concentration, the **NDF** displays a very bright spot.\n\n<br>\n\nWhen the *roughness is high*, the microfacets are aligned in much more random directions, you'll find a much larger number of halfway vectors **H** somewhat aligned to the microfacets (but less concentrated), giving us the more faded results.\n\n### Task\nReplace the given specular reflection calculation with the **Trowbridge-Reitz GGX** normal distribution function. Vary surface roughness values from `0.01` to `1.0` over time `sin(iTime * 0.5)`.",
                                "hints": [],
                                "restrictions": [],
                                "order": 18,
                                "cost": 5,
                                "threshold": 95,
                                "likes": 1,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": true,
                                "animationSteps": 10,
                                "animationStepTime": 1000,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "varying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  vPos = vec3(modelMatrix * vec4(position, 1.0));\n  \n  vNormal = normalize(mat3(transpose(inverse(modelMatrix))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform float iTime;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvoid main() {\n  vec3 viewPos = vec3(0.0, 0.0, 2.5);\n  \n  vec3 fragDiffuse = vec3(1.0, 0.6, 0.6);\n  vec3 fragNormal = normalize(vNormal);\n  \n  vec3 fragPos = vPos;\n  vec3 lightColor = vec3(1.0, 1.0, 0.75);\n  vec3 lightPos = vec3(-2.0, 2.0, 2.0);\n  vec3 lightDir = normalize(lightPos - fragPos);\n  vec3 viewDir = normalize(viewPos - fragPos);\n  vec3 halfwayDir = normalize(viewDir + lightDir);\n  \n  float ambient = 0.2;\n  \n  float t = 1.0 - (sin(iTime * 0.5) * 0.5 + 0.5) * 0.99;\n  float shininess = 256.0 * t;\n  float specular = pow(max(dot(fragNormal, halfwayDir), 0.0),  shininess);\n    \n  vec3 result = specular * fragDiffuse * lightColor;\n\n  gl_FragColor = vec4(result, 1.0);\n}\n",
                            "postProcessShader": "",
                            "properties": "",
                            "defaultVertexShader": "varying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  vPos = vec3(modelMatrix * vec4(position, 1.0));\n  \n  vNormal = normalize(mat3(transpose(inverse(modelMatrix))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform float iTime;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvoid main() {\n  vec3 viewPos = vec3(0.0, 0.0, 2.5);\n  \n  vec3 fragDiffuse = vec3(1.0, 0.6, 0.6);\n  vec3 fragNormal = normalize(vNormal);\n  \n  vec3 fragPos = vPos;\n  vec3 lightColor = vec3(1.0, 1.0, 0.75);\n  vec3 lightPos = vec3(-2.0, 2.0, 2.0);\n  vec3 lightDir = normalize(lightPos - fragPos);\n  vec3 viewDir = normalize(viewPos - fragPos);\n  vec3 halfwayDir = normalize(viewDir + lightDir);\n  \n  float ambient = 0.2;\n  \n  float t = 1.0 - (sin(iTime * 0.5) * 0.5 + 0.5) * 0.99;\n  float shininess = 256.0 * t;\n  float specular = pow(max(dot(fragNormal, halfwayDir), 0.0),  shininess);\n    \n  vec3 result = specular * fragDiffuse * lightColor;\n\n  gl_FragColor = vec4(result, 1.0);\n}\n",
                            "defaultPostProcessShader": "",
                            "defaultProperties": "",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 93,
                        "slug": "roughness-geometry-function",
                        "moduleId": 6,
                        "name": "Roughness - Geometry function",
                        "order": 19,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": true,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 93,
                                "slug": "roughness-geometry-function",
                                "moduleId": 6,
                                "name": "Roughness - Geometry function",
                                "vertexShader": "varying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  vPos = vec3(modelMatrix * vec4(position, 1.0));\n  \n  vNormal = normalize(mat3(transpose(inverse(modelMatrix))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform float iTime;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nfloat geometryGGX(float NdotV, float k) {\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\t\n    return nom / denom;\n}\n  \nfloat geometrySmith(vec3 N, vec3 V, vec3 L, float k) {\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx1 = geometryGGX(NdotV, k);\n    float ggx2 = geometryGGX(NdotL, k);\n\t\n    return ggx1 * ggx2;\n}\n\nfloat distributionGGX(vec3 N, vec3 H, float a) {\n    float a2     = a*a;\n    float NdotH  = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\t\n    float nom    = a2;\n    float denom  = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom        = 3.14 * denom * denom;\n\t\n    return nom / denom;\n}\n\nvoid main() {\n  vec3 viewPos = vec3(0.0, 0.0, 2.5);\n  \n  vec3 fragColor = vec3(1.0, 0.6, 0.6);\n  vec3 fragNormal = normalize(vNormal);\n  float fragRoughness = 0.01 + (sin(iTime * 0.5) * 0.5 + 0.5) * 0.99;\n  \n  vec3 fragPos = vPos;\n  vec3 lightColor = vec3(1.0, 1.0, 0.75);\n  vec3 lightPos = vec3(-2.0, 2.0, 2.0);\n  vec3 lightDir = normalize(lightPos - fragPos);\n  vec3 viewDir = normalize(viewPos - fragPos);\n  vec3 halfwayDir = normalize(viewDir + lightDir);\n  \n  float shininess = 2.0;\n  float specular = pow(max(dot(fragNormal, halfwayDir), 0.0),  shininess);\n\n  float k = pow(fragRoughness + 1.0, 2.0) / 8.0;\n  specular *= geometrySmith(fragNormal, viewDir, lightDir, k);\n  \n  vec3 result = specular * fragColor * lightColor;\n\n  gl_FragColor = vec4(result, 1.0);\n}\n",
                                "postProcessShader": "",
                                "properties": "",
                                "defaultVertexShader": "varying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  vPos = vec3(modelMatrix * vec4(position, 1.0));\n  \n  vNormal = normalize(mat3(transpose(inverse(modelMatrix))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform float iTime;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvoid main() {\n  vec3 viewPos = vec3(0.0, 0.0, 2.5);\n  \n  vec3 fragColor = vec3(1.0, 0.6, 0.6);\n  vec3 fragNormal = normalize(vNormal);\n  float fragRoughness = 0.01 + (sin(iTime * 0.5) * 0.5 + 0.5) * 0.99;\n  \n  vec3 fragPos = vPos;\n  vec3 lightColor = vec3(1.0, 1.0, 0.75);\n  vec3 lightPos = vec3(-2.0, 2.0, 2.0);\n  vec3 lightDir = normalize(lightPos - fragPos);\n  vec3 viewDir = normalize(viewPos - fragPos);\n  vec3 halfwayDir = normalize(viewDir + lightDir);\n\n  float shininess = 2.0;\n  float specular = pow(max(dot(fragNormal, halfwayDir), 0.0),  shininess);\n  \n  vec3 result = specular * fragColor * lightColor;\n\n  gl_FragColor = vec4(result, 1.0);\n}\n",
                                "defaultPostProcessShader": "",
                                "defaultProperties": "",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":\"0\",\"y\":0,\"z\":1.4},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":\"45\",\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":\"3\",\"model\":null,\"meshes\":[{\"name\":\"main\",\"materialId\":0}],\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"materials\":[],\"actions\":[],\"backgroundRGBA\":\"CCCCCC\",\"background\":13421772,\"customDepthBufferTexture\":false,\"glslVersion\":1}",
                                "description": "The **Geometry Function** describes the attenuation of light due to the microfacets blocking (shadowing) and being blocked (masking) by other microfacets. This function ensures that the amount of reflected light is consistent with the physical behavior of rough surfaces.\n\n<br>\n\n![](/files/geometry-function-microfacets-shadowing.png)\n\n<br>\n\nThe geometry function is a factor ranging from 0.0 to 1.0. White (or a value of 1.0) indicates no shadowing of the microfacets, while black (or a value of 0.0) signifies complete shadowing of the microfacets. *Note that this function is applicable only to the specular light component.*\n\n<br>\n\n### Mathematical Definition\n\n<br>\n\nOne of the widely used geometry functions in computer graphics is the **Smith GGX** geometry function:\n\n$$\nG(L, V) = G_1(L) \\cdot G_1(V)\n$$\n\n\\- $G(L, V)$ is the combined geometry function for the light direction and the view direction.\n<br>\n\\- $G1(L)$ is the geometry function for the light direction.\n<br>\n\\- $G1(V)$ is the geometry function for the view direction.\n\n<br>\n\nThe individual geometry terms `G1` for the **GGX** model are given by:\n\n$$\nG(n, x, k) = \\frac{(\\mathbf{n} \\cdot \\mathbf{x})}{(\\mathbf{n} \\cdot \\mathbf{x}) \\cdot (1 - k) + k}\n$$\n\n\\- $\\mathbf{n}$ is the surface normal.\n<br>\n\\- $\\mathbf{x}$ can be either the light direction or the view direction.\n<br>\n\\- $k$ is the roughness transformation function.\n\n<br>\n\nSince we use the geometry function for direct illumination the transformation function will be as follows:\n\n$$\nk = \\frac{(r + 1)^2}{8}\n$$\n\n\\- $r$ is the roughness parameter, controlling the spread of the microfacet normals.\n\n<br>\n\nOn the following graphs, you can see how the value of the geometry function changes with the angle between the normal and the view/light direction.\n\n<br>\n\n![](/files/geometry-function-change-value.png)\n\n<br>\n\nThe first graph might raise questions since it is unclear why self-shadowing appears on an absolutely smooth surface. However, in the case of image based lighting (IBL), we consistently get a value of 1 regardless of the viewing angle for an absolutely smooth surface. For IBL we use a slightly different roughness transformation function:\n\n$$\nk_\\text{IBL} = \\frac{r^2}{2}\n$$\n\nIt's not necessary to dive into the topic of IBL right now, as it will be covered in future tasks.\n\n### Task\nIn this task, you need to implement specular light attenuation due to self-shadowing of microfacets using the **Smith** geometry function. `fragRoughness` variable is defined.",
                                "hints": [],
                                "restrictions": [],
                                "order": 19,
                                "cost": 5,
                                "threshold": 95,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": true,
                                "animationSteps": 10,
                                "animationStepTime": 1000,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "varying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  vPos = vec3(modelMatrix * vec4(position, 1.0));\n  \n  vNormal = normalize(mat3(transpose(inverse(modelMatrix))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform float iTime;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvoid main() {\n  vec3 viewPos = vec3(0.0, 0.0, 2.5);\n  \n  vec3 fragColor = vec3(1.0, 0.6, 0.6);\n  vec3 fragNormal = normalize(vNormal);\n  float fragRoughness = 0.01 + (sin(iTime * 0.5) * 0.5 + 0.5) * 0.99;\n  \n  vec3 fragPos = vPos;\n  vec3 lightColor = vec3(1.0, 1.0, 0.75);\n  vec3 lightPos = vec3(-2.0, 2.0, 2.0);\n  vec3 lightDir = normalize(lightPos - fragPos);\n  vec3 viewDir = normalize(viewPos - fragPos);\n  vec3 halfwayDir = normalize(viewDir + lightDir);\n\n  float shininess = 2.0;\n  float specular = pow(max(dot(fragNormal, halfwayDir), 0.0),  shininess);\n  \n  vec3 result = specular * fragColor * lightColor;\n\n  gl_FragColor = vec4(result, 1.0);\n}\n",
                            "postProcessShader": "",
                            "properties": "",
                            "defaultVertexShader": "varying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  vPos = vec3(modelMatrix * vec4(position, 1.0));\n  \n  vNormal = normalize(mat3(transpose(inverse(modelMatrix))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform float iTime;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvoid main() {\n  vec3 viewPos = vec3(0.0, 0.0, 2.5);\n  \n  vec3 fragColor = vec3(1.0, 0.6, 0.6);\n  vec3 fragNormal = normalize(vNormal);\n  float fragRoughness = 0.01 + (sin(iTime * 0.5) * 0.5 + 0.5) * 0.99;\n  \n  vec3 fragPos = vPos;\n  vec3 lightColor = vec3(1.0, 1.0, 0.75);\n  vec3 lightPos = vec3(-2.0, 2.0, 2.0);\n  vec3 lightDir = normalize(lightPos - fragPos);\n  vec3 viewDir = normalize(viewPos - fragPos);\n  vec3 halfwayDir = normalize(viewDir + lightDir);\n\n  float shininess = 2.0;\n  float specular = pow(max(dot(fragNormal, halfwayDir), 0.0),  shininess);\n  \n  vec3 result = specular * fragColor * lightColor;\n\n  gl_FragColor = vec4(result, 1.0);\n}\n",
                            "defaultPostProcessShader": "",
                            "defaultProperties": "",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 214,
                        "slug": "fresnel-reflectance",
                        "moduleId": 6,
                        "name": "Fresnel Reflectance",
                        "order": 20,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": true,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 214,
                                "slug": "fresnel-reflectance",
                                "moduleId": 6,
                                "name": "Fresnel Reflectance",
                                "vertexShader": "varying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  vPos = vec3(modelMatrix * vec4(position, 1.0));\n  \n  vNormal = normalize(mat3(transpose(inverse(modelMatrix))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\nuniform sampler2D iChannel0;\nuniform sampler2D iChannel1;\nuniform sampler2D iChannel2;\nuniform mat4 inverseViewMatrix;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nvec3 getViewPos() {\n  return (inverseViewMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz;  \n}\n\nvoid main() {\n  vec3 viewPos = getViewPos();\n  \n  vec3 fragColor = vec3(1.0, 0.6, 0.6);\n  vec3 fragNormal = normalize(vNormal);\n  float fragMetallic = 0.0;\n  \n  vec3 fragPos = vPos;\n  vec3 lightColor = vec3(1.0, 1.0, 1.0);\n  vec3 lightPos = vec3(0.0, 0.5, -0.6);\n  vec3 lightDir = normalize(lightPos - fragPos);\n  vec3 viewDir = normalize(viewPos - fragPos);\n  vec3 halfwayDir = normalize(viewDir + lightDir);\n\n  // Phong Specular Component\n  float shininess = 8.0;\n  float specular = pow(max(dot(fragNormal, halfwayDir), 0.0),  shininess);\n  float NoL = dot(fragNormal, lightDir);\n\n  // Base Reflectance\n  vec3 F0 = vec3(0.04);\n\n  // Fresnel-Schlick Approximation\n  vec3 kS = fresnelSchlick(max(dot(halfwayDir, viewDir), 0.0), F0);\n  vec3 kD = vec3(1.0) - kS;\n\n  vec3 d = fragColor * NoL * lightColor * kD;\n  vec3 s = specular * lightColor * kS;\n  \n  gl_FragColor = vec4(d + s, 1.0);\n}",
                                "postProcessShader": "",
                                "properties": "",
                                "defaultVertexShader": "varying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  vPos = vec3(modelMatrix * vec4(position, 1.0));\n  \n  vNormal = normalize(mat3(transpose(inverse(modelMatrix))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\nuniform sampler2D iChannel0;\nuniform sampler2D iChannel1;\nuniform sampler2D iChannel2;\nuniform mat4 inverseViewMatrix;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nvec3 getViewPos() {\n  return (inverseViewMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz;  \n}\n\nvoid main() {\n  vec3 viewPos = getViewPos();\n  \n  vec3 fragColor = vec3(1.0, 0.6, 0.6);\n  vec3 fragNormal = normalize(vNormal);\n  float fragMetallic = 0.0;\n  \n  vec3 fragPos = vPos;\n  vec3 lightColor = vec3(1.0, 1.0, 1.0);\n  vec3 lightPos = vec3(0.0, 0.5, -0.6);\n  vec3 lightDir = normalize(lightPos - fragPos);\n  vec3 viewDir = normalize(viewPos - fragPos);\n  vec3 halfwayDir = normalize(viewDir + lightDir);\n\n  float shininess = 8.0;\n  float specular = pow(max(dot(fragNormal, halfwayDir), 0.0),  shininess);\n  float NoL = dot(fragNormal, lightDir);\n\n  // Base Reflectance\n  vec3 F0 = vec3(0.04);\n\n  gl_FragColor = vec4(fragColor * NoL * lightColor + specular * lightColor, 1.0);\n}",
                                "defaultPostProcessShader": "",
                                "defaultProperties": "",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":0,\"y\":0.2,\"z\":2.7},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":45,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":1,\"z\":0},\"scale\":{\"x\":2,\"y\":0.25,\"z\":2},\"geometry\":\"2\",\"model\":null,\"meshes\":[{\"name\":\"main\",\"materialId\":0}],\"colorRGBA\":\"FFFFFF\",\"color\":null},{\"position\":{\"x\":0,\"y\":0.5,\"z\":-0.6},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":0.25,\"y\":0.25,\"z\":0.25},\"geometry\":\"3\",\"model\":null,\"meshes\":[{\"name\":\"main\",\"materialId\":1}],\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"materials\":[{\"vertex\":\"\\nvoid main() {\\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\\n}\\n\",\"fragment\":\"void main() {\\n  gl_FragColor = vec4(1.0);\\n}\\n\",\"properties\":\"\"}],\"actions\":[{\"type\":1,\"time\":3000,\"distance\":{\"x\":0,\"y\":3,\"z\":-2},\"pivot\":{\"x\":0,\"y\":0,\"z\":0}}],\"backgroundRGBA\":\"4080A0\",\"background\":4227232,\"customDepthBufferTexture\":false,\"glslVersion\":1}",
                                "description": "Let's make a clear distinction between the light components. The moment a beam of light reaches a surface, it splits into reflected and refracted components. The **reflected** component is the light reflected directly and does not penetrate the surface, we know it as the *specular* component of light.\n\n$$\nL_{\\text{in}} = L_{\\text{refracted}} + L_{\\text{reflected}}\n$$\n\nThe **refracted** component is light that penetrates and is absorbed by a surface. In general, not all the energy is absorbed, and the light continues to diffuse in (mostly) random directions, where it again collides with other particles until it runs out of energy, or it leaves the surface again. Thus the surface starts to re-emit light rays, contributing to the observed (*diffuse*) color of the surface.\n\n<br>\n\n### Reflection Equation\n\n<br>\n\nThe **Fresnel equation** describes the ratio of reflected to refracted light, which depends on the viewing angle. When light hits a surface, the Fresnel equation gives the percentage of light reflected based on the angle. The Fresnel equation is quite complex, but it can be simplified using the **Fresnel-Schlick** approximation:\n\n$$\nF = F_0 + (1 - F_0) \\times (1 - (\\mathbf{V} \\cdot \\mathbf{H}))^5\n$$\n\n\\- $F$ is the reflectance coefficient.\n<br>\n\\- $F_0$ is the base reflectance at normal incidence.\n<br>\n\\- $V$ is the view direction vector.\n<br>\n\\- $H$ is the halfway vector between the light direction and the view direction.\n\n<br>\n\nLet's emphasize that the Fresnel equation helps determine **the proportion of reflected light relative to refracted light** based on the angle of incidence and the refractive indices of the media, but **it doesn't provide the specific amount of reflected light** that will be observed. It doesn't account for other factors, such as the intensity of the incident light or geometric aspects that may affect the amount of observed reflected light (surface normal, direction of reflected light).\n\n<br>\n\n### Base Reflectance\n\n<br>\n\nEvery surface or material has a base reflectance level $F_0$, observed when looking at the surface directly. However, when you view the surface at a 90-degree angle to the normal (parallel), reflections become more noticeable. In theory, all surfaces fully reflect light when viewed at a perfect 90-degree angle.\n\n<br>\n\nThe base reflectance $F_0$ at normal incidence can be found in large databases like [this one](https://refractiveindex.info/).\n\n<br>\n\n### Outgoing Light\n\n<br>\n\nAccording to the law of conservation of energy, the refracted part of the light equals the remaining energy:\n\n$$\nL_o = L_{\\text{diffuse}} \\times (1 - F) + L_{\\text{specular}} \\times F\n$$\n\nThis approach ensures that the total outgoing light (diffuse + specular) does not exceed the incoming light.\n\n\n### Task\nYour task is to use the **Fresnel-Schlick** approximation to correct the distribution of diffuse and specular light based on the viewing angle, ensuring that the total amount of outgoing light (diffuse + specular) does not exceed the incoming light.\n",
                                "hints": [],
                                "restrictions": [],
                                "order": 20,
                                "cost": 5,
                                "threshold": 95,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": true,
                                "animationSteps": 6,
                                "animationStepTime": 500,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "varying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  vPos = vec3(modelMatrix * vec4(position, 1.0));\n  \n  vNormal = normalize(mat3(transpose(inverse(modelMatrix))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\nuniform sampler2D iChannel0;\nuniform sampler2D iChannel1;\nuniform sampler2D iChannel2;\nuniform mat4 inverseViewMatrix;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nvec3 getViewPos() {\n  return (inverseViewMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz;  \n}\n\nvoid main() {\n  vec3 viewPos = getViewPos();\n  \n  vec3 fragColor = vec3(1.0, 0.6, 0.6);\n  vec3 fragNormal = normalize(vNormal);\n  float fragMetallic = 0.0;\n  \n  vec3 fragPos = vPos;\n  vec3 lightColor = vec3(1.0, 1.0, 1.0);\n  vec3 lightPos = vec3(0.0, 0.5, -0.6);\n  vec3 lightDir = normalize(lightPos - fragPos);\n  vec3 viewDir = normalize(viewPos - fragPos);\n  vec3 halfwayDir = normalize(viewDir + lightDir);\n\n  float shininess = 8.0;\n  float specular = pow(max(dot(fragNormal, halfwayDir), 0.0),  shininess);\n  float NoL = dot(fragNormal, lightDir);\n\n  // Base Reflectance\n  vec3 F0 = vec3(0.04);\n\n  gl_FragColor = vec4(fragColor * NoL * lightColor + specular * lightColor, 1.0);\n}",
                            "postProcessShader": "",
                            "properties": "",
                            "defaultVertexShader": "varying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  vPos = vec3(modelMatrix * vec4(position, 1.0));\n  \n  vNormal = normalize(mat3(transpose(inverse(modelMatrix))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\nuniform sampler2D iChannel0;\nuniform sampler2D iChannel1;\nuniform sampler2D iChannel2;\nuniform mat4 inverseViewMatrix;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nvec3 getViewPos() {\n  return (inverseViewMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz;  \n}\n\nvoid main() {\n  vec3 viewPos = getViewPos();\n  \n  vec3 fragColor = vec3(1.0, 0.6, 0.6);\n  vec3 fragNormal = normalize(vNormal);\n  float fragMetallic = 0.0;\n  \n  vec3 fragPos = vPos;\n  vec3 lightColor = vec3(1.0, 1.0, 1.0);\n  vec3 lightPos = vec3(0.0, 0.5, -0.6);\n  vec3 lightDir = normalize(lightPos - fragPos);\n  vec3 viewDir = normalize(viewPos - fragPos);\n  vec3 halfwayDir = normalize(viewDir + lightDir);\n\n  float shininess = 8.0;\n  float specular = pow(max(dot(fragNormal, halfwayDir), 0.0),  shininess);\n  float NoL = dot(fragNormal, lightDir);\n\n  // Base Reflectance\n  vec3 F0 = vec3(0.04);\n\n  gl_FragColor = vec4(fragColor * NoL * lightColor + specular * lightColor, 1.0);\n}",
                            "defaultPostProcessShader": "",
                            "defaultProperties": "",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 216,
                        "slug": "matallic-reflectance",
                        "moduleId": 6,
                        "name": "Matallic Reflectance",
                        "order": 21,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": true,
                        "premiumLock": 0,
                        "premium": false,
                        "child": {
                            "task": {
                                "id": 216,
                                "slug": "matallic-reflectance",
                                "moduleId": 6,
                                "name": "Matallic Reflectance",
                                "vertexShader": "varying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  vPos = vec3(modelMatrix * vec4(position, 1.0));\n  \n  vNormal = normalize(mat3(transpose(inverse(modelMatrix))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\nuniform sampler2D iChannel0;\nuniform sampler2D iChannel1;\nuniform sampler2D iChannel2;\nuniform mat4 inverseViewMatrix;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nvec3 getViewPos() {\n  return (inverseViewMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz;  \n}\n\nvoid main() {\n  vec3 viewPos = getViewPos();\n  \n  vec3 fragColor = vec3(1.0, 0.6, 0.6);\n  vec3 fragNormal = normalize(vNormal);\n  float fragMetallic = 1.0;\n  \n  vec3 fragPos = vPos;\n  vec3 lightColor = vec3(1.0, 1.0, 1.0);\n  vec3 lightPos = vec3(0.0, 0.5, -0.6);\n  vec3 lightDir = normalize(lightPos - fragPos);\n  vec3 viewDir = normalize(viewPos - fragPos);\n  vec3 halfwayDir = normalize(viewDir + lightDir);\n\n  // Phong Specular Component\n  float shininess = 8.0;\n  float specular = pow(max(dot(fragNormal, halfwayDir), 0.0),  shininess);\n  float NoL = dot(fragNormal, lightDir);\n\n  // Base Reflectance\n  vec3 F0 = vec3(0.04);\n  F0 = mix(F0, fragColor, fragMetallic);\n\n  // Fresnel-Schlick Approximation\n  vec3 kS = fresnelSchlick(max(dot(halfwayDir, viewDir), 0.0), F0);\n  vec3 kD = vec3(1.0) - kS;\n  kD *= 1.0 - fragMetallic;\n\n  vec3 d = fragColor * NoL * lightColor * kD;\n  vec3 s = specular * lightColor * kS;\n  \n  gl_FragColor = vec4(d + s, 1.0);\n}",
                                "postProcessShader": "",
                                "properties": "",
                                "defaultVertexShader": "varying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  vPos = vec3(modelMatrix * vec4(position, 1.0));\n  \n  vNormal = normalize(mat3(transpose(inverse(modelMatrix))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\nuniform sampler2D iChannel0;\nuniform sampler2D iChannel1;\nuniform sampler2D iChannel2;\nuniform mat4 inverseViewMatrix;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nvec3 getViewPos() {\n  return (inverseViewMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz;  \n}\n\nvoid main() {\n  vec3 viewPos = getViewPos();\n  \n  vec3 fragColor = vec3(1.0, 0.6, 0.6);\n  vec3 fragNormal = normalize(vNormal);\n  float fragMetallic = 1.0;\n  \n  vec3 fragPos = vPos;\n  vec3 lightColor = vec3(1.0, 1.0, 1.0);\n  vec3 lightPos = vec3(0.0, 0.5, -0.6);\n  vec3 lightDir = normalize(lightPos - fragPos);\n  vec3 viewDir = normalize(viewPos - fragPos);\n  vec3 halfwayDir = normalize(viewDir + lightDir);\n\n  // Phong Specular Component\n  float shininess = 8.0;\n  float specular = pow(max(dot(fragNormal, halfwayDir), 0.0),  shininess);\n  float NoL = dot(fragNormal, lightDir);\n\n  // Base Reflectance\n  vec3 F0 = vec3(0.04);\n\n  // Fresnel-Schlick Approximation\n  vec3 kS = fresnelSchlick(max(dot(halfwayDir, viewDir), 0.0), F0);\n  vec3 kD = vec3(1.0) - kS;\n\n  vec3 d = fragColor * NoL * lightColor * kD;\n  vec3 s = specular * lightColor * kS;\n  \n  gl_FragColor = vec4(d + s, 1.0);\n}",
                                "defaultPostProcessShader": "",
                                "defaultProperties": "",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":0,\"y\":0.2,\"z\":2.7},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":45,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":1,\"z\":0},\"scale\":{\"x\":2,\"y\":0.25,\"z\":2},\"geometry\":\"2\",\"model\":null,\"meshes\":[{\"name\":\"main\",\"materialId\":0}],\"colorRGBA\":\"FFFFFF\",\"color\":null},{\"position\":{\"x\":0,\"y\":0.5,\"z\":-0.6},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":0.25,\"y\":0.25,\"z\":0.25},\"geometry\":\"3\",\"model\":null,\"meshes\":[{\"name\":\"main\",\"materialId\":1}],\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"materials\":[{\"vertex\":\"\\nvoid main() {\\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\\n}\\n\",\"fragment\":\"void main() {\\n  gl_FragColor = vec4(1.0);\\n}\\n\",\"properties\":\"\"}],\"actions\":[{\"type\":1,\"time\":3000,\"distance\":{\"x\":0,\"y\":3,\"z\":-2},\"pivot\":{\"x\":0,\"y\":0,\"z\":0}}],\"backgroundRGBA\":\"4080A0\",\"background\":4227232,\"customDepthBufferTexture\":false,\"glslVersion\":1}",
                                "description": "In the following graphs, you can see how the value of the *Fresnel-Schlick* function changes depending on the basic reflectivity $F_0$ and the angle between the half-vector $H$ and the view vector $V$:\n\n<br>\n\n![](/files/fresnel-function-reflectance-value.png)\n\n<br>\n\nIn the third graph, you can see that the curve appears as a straight line equal to $F_0$ all the way through. This means the intensity of reflected light remains relatively stable regardless of the angle of light incidence and the viewing angle if the basic reflectivity is above 0.5. *Such high basic reflectivity is typically found only in metallic surfaces*.\n\n<br>\n\n### Light-Metal interaction\n\n<br>\n\nMetallic surfaces interact with light differently than non-metallic ones (dielectrics). When light (an electromagnetic wave) hits a metal, its electric field interacts with the electrons in the metal, causing them to accelerate. Free electrons in the metal move easily under the influence of this electric field. Under the light's electric field, the electrons begin to oscillate and accelerate. Since accelerated charges emit electromagnetic waves (according to the laws of classical electrodynamics), these oscillating electrons start emitting light. Because of this, the reflected light takes on a hue characteristic of the specific metal. For example, gold reflects light with a yellow hue, copper—with a reddish one.\n\n<br>\n\n### Reflection Equation\n\n<br>\n\nWe can use the same Fresnel-Schlick approximation for metallic and dielectric (non-metallic) surfaces, but we need to adjust the basic reflectivity if we have a metallic surface. Usually, we do this as follows:\n\n```\nvec3 F0 = vec3(0.04);\nF0 = mix(F0, surfaceColor, metalness);\n```\n\nFor most dielectrics, the base reflectance $F_0$ is kept at `0.04` and gives physically plausible results without the need to specify an additional surface parameter.\n\n<br>\n\nBased on how metallic a surface is, we either take the dielectric base reflectivity $F_0$ or the surface color. Because metallic surfaces absorb all refracted light, they have no diffuse reflections and we can directly use the surface color texture as their base reflectivity.\n\n<br>\n\n*Theoretically, the metallicity of a surface takes only two values: it is either a metal or it is not; the surface cannot be both. However, most render pipelines allow you to adjust the metallicity of a surface linearly between 0.0 and 1.0. This is necessary to create a surface, for example, with small particles of dust and sand, scratches on the metal surface.*\n\n<br>\n\nAdditionally, since metals do not refract light and do not have a diffuse component of re-emitted light, for a fully metallic material, the diffuse component will be zero:\n\n$$\nL_o = L_{\\text{diffuse}} \\cdot (1 - F) \\cdot (1 - \\text{metallic}) + L_{\\text{specular}} \\cdot F\n$$\n\nThis highlights the unique reflective properties of metallic surfaces, distinguishing them from non-metallic materials.\n\n### Task\nYou have already developed a lighting calculation system for rendering surfaces. However, it currently lacks the specific handling of metallic surfaces. Your task is to extend the existing system to include the accurate processing of metallic surfaces.",
                                "hints": [],
                                "restrictions": [],
                                "order": 21,
                                "cost": 5,
                                "threshold": 95,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": true,
                                "animationSteps": 6,
                                "animationStepTime": 500,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": false
                            },
                            "vertexShader": "varying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  vPos = vec3(modelMatrix * vec4(position, 1.0));\n  \n  vNormal = normalize(mat3(transpose(inverse(modelMatrix))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\nuniform sampler2D iChannel0;\nuniform sampler2D iChannel1;\nuniform sampler2D iChannel2;\nuniform mat4 inverseViewMatrix;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nvec3 getViewPos() {\n  return (inverseViewMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz;  \n}\n\nvoid main() {\n  vec3 viewPos = getViewPos();\n  \n  vec3 fragColor = vec3(1.0, 0.6, 0.6);\n  vec3 fragNormal = normalize(vNormal);\n  float fragMetallic = 1.0;\n  \n  vec3 fragPos = vPos;\n  vec3 lightColor = vec3(1.0, 1.0, 1.0);\n  vec3 lightPos = vec3(0.0, 0.5, -0.6);\n  vec3 lightDir = normalize(lightPos - fragPos);\n  vec3 viewDir = normalize(viewPos - fragPos);\n  vec3 halfwayDir = normalize(viewDir + lightDir);\n\n  // Phong Specular Component\n  float shininess = 8.0;\n  float specular = pow(max(dot(fragNormal, halfwayDir), 0.0),  shininess);\n  float NoL = dot(fragNormal, lightDir);\n\n  // Base Reflectance\n  vec3 F0 = vec3(0.04);\n\n  // Fresnel-Schlick Approximation\n  vec3 kS = fresnelSchlick(max(dot(halfwayDir, viewDir), 0.0), F0);\n  vec3 kD = vec3(1.0) - kS;\n\n  vec3 d = fragColor * NoL * lightColor * kD;\n  vec3 s = specular * lightColor * kS;\n  \n  gl_FragColor = vec4(d + s, 1.0);\n}",
                            "postProcessShader": "",
                            "properties": "",
                            "defaultVertexShader": "varying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  vPos = vec3(modelMatrix * vec4(position, 1.0));\n  \n  vNormal = normalize(mat3(transpose(inverse(modelMatrix))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\nuniform sampler2D iChannel0;\nuniform sampler2D iChannel1;\nuniform sampler2D iChannel2;\nuniform mat4 inverseViewMatrix;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nvec3 getViewPos() {\n  return (inverseViewMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz;  \n}\n\nvoid main() {\n  vec3 viewPos = getViewPos();\n  \n  vec3 fragColor = vec3(1.0, 0.6, 0.6);\n  vec3 fragNormal = normalize(vNormal);\n  float fragMetallic = 1.0;\n  \n  vec3 fragPos = vPos;\n  vec3 lightColor = vec3(1.0, 1.0, 1.0);\n  vec3 lightPos = vec3(0.0, 0.5, -0.6);\n  vec3 lightDir = normalize(lightPos - fragPos);\n  vec3 viewDir = normalize(viewPos - fragPos);\n  vec3 halfwayDir = normalize(viewDir + lightDir);\n\n  // Phong Specular Component\n  float shininess = 8.0;\n  float specular = pow(max(dot(fragNormal, halfwayDir), 0.0),  shininess);\n  float NoL = dot(fragNormal, lightDir);\n\n  // Base Reflectance\n  vec3 F0 = vec3(0.04);\n\n  // Fresnel-Schlick Approximation\n  vec3 kS = fresnelSchlick(max(dot(halfwayDir, viewDir), 0.0), F0);\n  vec3 kD = vec3(1.0) - kS;\n\n  vec3 d = fragColor * NoL * lightColor * kD;\n  vec3 s = specular * lightColor * kS;\n  \n  gl_FragColor = vec4(d + s, 1.0);\n}",
                            "defaultPostProcessShader": "",
                            "defaultProperties": "",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 219,
                        "slug": "brdf",
                        "moduleId": 6,
                        "name": "BRDF",
                        "order": 22,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": true,
                        "premiumLock": 0,
                        "premium": false,
                        "child": {
                            "task": {
                                "id": 219,
                                "slug": "brdf",
                                "moduleId": 6,
                                "name": "BRDF",
                                "vertexShader": "varying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  vPos = vec3(modelMatrix * vec4(position, 1.0));\n  \n  vNormal = normalize(mat3(transpose(inverse(modelMatrix))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\nuniform sampler2D iChannel0;\nuniform sampler2D iChannel1;\nuniform sampler2D iChannel2;\nuniform mat4 inverseViewMatrix;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nconst float PI = 3.14159265359;\n\nstruct TLight { vec3 position; vec3 color; };\n\nTLight c_Lights[3] = TLight[3](\n  TLight(vec3( 0.0, 5.0, 10.0), vec3(1.0, 1.0, 1.0)),\n  TLight(vec3( 8.0, 5.0, -8.0), vec3(0.5, 1.0, 0.5)),\n  TLight(vec3(-8.0, 5.0, -8.0), vec3(0.5, 0.5, 1.0))\n);\n\nfloat geometryGGX(float NdotV, float k) {\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\t\n    return nom / denom;\n}\n  \nfloat geometrySmith(vec3 N, vec3 V, vec3 L, float k) {\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx1 = geometryGGX(NdotV, k);\n    float ggx2 = geometryGGX(NdotL, k);\n\t\n    return ggx1 * ggx2;\n}\n\nfloat distributionGGX(vec3 N, vec3 H, float a) {\n    float a2     = a*a;\n    float NdotH  = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\t\n    float nom    = a2;\n    float denom  = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom        = 3.14 * denom * denom;\n\t\n    return nom / denom;\n}\n\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nvec3 getViewPos() {\n  return (inverseViewMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz;  \n}\n\nvoid main() {\n  vec3  fragColor = vec3(1.0, 0.6, 0.6);\n  vec3  fragNormal = normalize(vNormal);\n  float fragMetallic = 0.8;\n  float fragRoughness = 0.3;\n  vec3  fragPos = vPos;\n\n  // Base Reflectance\n  vec3 F0 = vec3(0.04);\n  F0 = mix(F0, fragColor, fragMetallic);\n\n  vec3 viewPos = getViewPos();\n  vec3 viewDir = normalize(viewPos - fragPos);\n    \n  vec3 result = vec3(0.0);\n  for (int i= 0; i < 3; i++) {\n    vec3 lightColor = c_Lights[i].color;\n    vec3 lightPos = c_Lights[i].position;\n    vec3 lightDir = normalize(lightPos - fragPos);\n    vec3 halfwayDir = normalize(viewDir + lightDir);\n\n    float dist = distance(lightPos, fragPos);\n    float attenuation = 1.0 / (dist * 0.01 + 1.0);\n    lightColor *= attenuation;\n    \n    float NoL = dot(fragNormal, lightDir);\n    if (NoL > 0.0) {\n      float NoV = max(dot(fragNormal, viewDir), 0.0);\n      float HoV = max(dot(halfwayDir, viewDir), 0.0);\n\n      float k = pow(fragRoughness + 1.0, 2.0) / 8.0;\n      float G = geometrySmith(fragNormal, viewDir, lightDir, k);\n      vec3  F = fresnelSchlick(HoV, F0);\n      float D = distributionGGX(fragNormal, halfwayDir, fragRoughness);\n  \n      vec3 Lo = vec3(0.0);\n      Lo += F * D * G / (4.0 * NoL * NoV);\n      Lo *= lightColor * NoL;\n  \n      result += Lo;\n    }\n  }\n  \n  gl_FragColor = vec4(result, 1.0);\n}",
                                "postProcessShader": "",
                                "properties": "",
                                "defaultVertexShader": "varying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  vPos = vec3(modelMatrix * vec4(position, 1.0));\n  \n  vNormal = normalize(mat3(transpose(inverse(modelMatrix))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\nuniform sampler2D iChannel0;\nuniform sampler2D iChannel1;\nuniform sampler2D iChannel2;\nuniform mat4 inverseViewMatrix;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nconst float PI = 3.14159265359;\n\nstruct TLight { vec3 position; vec3 color; };\n\nTLight c_Lights[3] = TLight[3](\n  TLight(vec3( 0.0, 5.0, 10.0), vec3(1.0, 1.0, 1.0)),\n  TLight(vec3( 8.0, 5.0, -8.0), vec3(0.5, 1.0, 0.5)),\n  TLight(vec3(-8.0, 5.0, -8.0), vec3(0.5, 0.5, 1.0))\n);\n\nfloat geometryGGX(float NdotV, float k) {\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\t\n    return nom / denom;\n}\n  \nfloat geometrySmith(vec3 N, vec3 V, vec3 L, float k) {\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx1 = geometryGGX(NdotV, k);\n    float ggx2 = geometryGGX(NdotL, k);\n\t\n    return ggx1 * ggx2;\n}\n\nfloat distributionGGX(vec3 N, vec3 H, float a) {\n    float a2     = a*a;\n    float NdotH  = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\t\n    float nom    = a2;\n    float denom  = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom        = 3.14 * denom * denom;\n\t\n    return nom / denom;\n}\n\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nvec3 getViewPos() {\n  return (inverseViewMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz;  \n}\n\nvoid main() {\n  vec3  fragColor = vec3(1.0, 0.6, 0.6);\n  vec3  fragNormal = normalize(vNormal);\n  float fragMetallic = 0.8;\n  float fragRoughness = 0.3;\n  vec3  fragPos = vPos;\n\n  // Base Reflectance\n  vec3 F0 = vec3(0.04);\n\n  vec3 viewPos = getViewPos();\n  vec3 viewDir = normalize(viewPos - fragPos);\n    \n  vec3 result = vec3(0.0);\n  for (int i = 0; i < 3; i++) {\n    vec3 lightColor = c_Lights[i].color;\n    vec3 lightPos = c_Lights[i].position;\n    vec3 lightDir = normalize(lightPos - fragPos);\n    vec3 halfwayDir = normalize(viewDir + lightDir);\n\n    float dist = distance(lightPos, fragPos);\n    float attenuation = 1.0 / (dist * 0.01 + 1.0);\n    lightColor *= attenuation;\n\n    float NoL = dot(fragNormal, lightDir);\n    if (NoL > 0.0) {\n      // Phong Specular Component\n      float shininess = 32.0;\n      float specular = pow(max(dot(fragNormal, halfwayDir), 0.0),  shininess);\n      \n      result += specular * lightColor;\n    }\n  }  \n  \n  gl_FragColor = vec4(result, 1.0);\n}",
                                "defaultPostProcessShader": "",
                                "defaultProperties": "",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":0,\"y\":15,\"z\":20},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":45,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":-1.57,\"y\":0,\"z\":0},\"scale\":{\"x\":2.5,\"y\":2.5,\"z\":2.5},\"geometry\":\"10\",\"model\":\"rabbit.glb\",\"meshes\":[{\"name\":\"21941_Rabbit_v1_NEW\",\"materialId\":0}],\"colorRGBA\":\"FFFFFF\",\"color\":null},{\"position\":{\"x\":0,\"y\":5,\"z\":10},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":2.5,\"y\":2.5,\"z\":2.5},\"geometry\":\"3\",\"model\":null,\"meshes\":[{\"name\":\"main\",\"materialId\":1}],\"colorRGBA\":\"FFFFFF\",\"color\":16777215},{\"position\":{\"x\":8,\"y\":5,\"z\":-8},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":2.5,\"y\":2.5,\"z\":2.5},\"geometry\":\"3\",\"model\":null,\"meshes\":[{\"name\":\"main\",\"materialId\":1}],\"colorRGBA\":\"19FF19\",\"color\":1703705},{\"position\":{\"x\":-8,\"y\":5,\"z\":-8},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":2.5,\"y\":2.5,\"z\":2.5},\"geometry\":\"3\",\"model\":null,\"meshes\":[{\"name\":\"main\",\"materialId\":1}],\"colorRGBA\":\"1919FF\",\"color\":1645055}],\"materials\":[{\"vertex\":\"attribute vec4 color;\\n\\nvarying vec4 vColor;\\n\\nvoid main() {\\n  vColor = color;\\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\\n}\\n\",\"fragment\":\"varying vec4 vColor;\\n\\nvoid main() {\\n  gl_FragColor = vColor * 5.0;\\n}\\n\",\"properties\":\"\"}],\"actions\":[{\"type\":0,\"speed\":1,\"pivot\":{\"x\":0,\"y\":5,\"z\":0}}],\"backgroundRGBA\":\"4080A0\",\"background\":4227232,\"customDepthBufferTexture\":false,\"glslVersion\":1}",
                                "description": "**Bidirectional Reflectance Distribution Function (BRDF)** approximates how much each individual light ray $\\omega_i$ contributes to the final reflected light $\\omega_r$ of an opaque surface given its material properties. \n\n<br>\n\nMathematically, it is expressed as:\n\n$$\nf_r(\\omega_i, \\omega_r) = \\frac{dL_r(\\omega_r)}{dE_i(\\omega_i)}\n$$\n\n\\- $\\omega_i$ is the incident light direction.\n<br>\n\\- $\\omega_r$ is the reflected light direction.\n<br>\n\\- $dL_r$ is the reflected radiance.\n<br>\n\\- $dE_i$ is the incident irradiance.\n\n<br>\n\n### Incident Irradiance\n\n<br>\n\nThe incident irradiance $E_i$ is the measure of the power of incoming light hitting a surface per unit area. It represents the intensity of light energy striking a surface from a specific direction. Different directions can contribute different amounts of irradiance.\n\n<br>\n\n### Reflected Radiance\n\n<br>\n\nReflected radiance $L_r$ is the measure of the intensity of light that is reflected from a surface in a specific direction. It represents the amount of light that is scattered or reflected by the surface and travels away from it. The amount of reflected radiance depends on the properties of the surface, such as its roughness, color, and material type.\n\n<br>\n\n### BRDF Models\n\n<br>\n\nthe Blinn-Fong model is considered to be a BRDF taking the same $w_i$ and $w_r$ as input. However, the Blinn-Fong model is not considered physically correct because it does not guarantee the law of conservation of energy.\n\n<br>\n\nOne of the most commonly used physically-based BRDF models is the **Cook-Torrance model**. This model is based on microfacet theory and includes several key components:\n\n<br>\n\n1\\. **Normal Distribution Function (N)**: Describes the distribution of microfacets on the surface.\n<br>\n2\\. **Geometry Function (G)**: Accounts for shadowing and masking effects.\n<br>\n3\\. **Fresnel Term (F)**: Describes how reflectance varies with the angle of incidence.\n\n<br>\n\nThe Cook-Torrance model ensures energy conservation and provides more realistic rendering by accurately modeling surface roughness and the angular dependence of reflectance:\n\n$$\nf_r(\\omega_i, \\omega_r) = \\frac{D(\\omega_h) G(\\omega_i, \\omega_r) F(\\omega_i, \\omega_r)}{4 (\\omega_i \\cdot n) (\\omega_r \\cdot n)}\n$$\n\n\\- $\\omega_i$ is the incident light direction.\n<br>\n\\- $\\omega_r$ is the reflected light direction.\n<br>\n\\- $\\omega_h$ is the half-vector between $\\omega_i$ and $\\omega_r$.\n<br>\n\\- $D$ is the microfacet normal distribution function.\n<br>\n\\- $G$ is the geometry function.\n<br>\n\\- $F$ is the Fresnel term.\n\n<br>\n\n### Surface Illumination\n\n<br>\n\nTo calculate the specular radiation (amount of specular light) from a surface point, we sum the BRDF from all directions of incoming light. For a given point $P$, the reflected radiance $L_r$ can be computed as:\n\n$$\nL_r(P, \\omega_r) = \\sum_{\\text{light sources}} f_r(\\omega_i, \\omega_r) L_i(\\omega_i) (N \\cdot \\omega_i)\n$$\n\n\\- $L_r(P, \\omega_r)$ is the outgoing radiance in the view direction $\\omega_r$.\n<br>\n\\- $f_r$ is BRDF.\n<br>\n\\- $L_i(\\omega_i)$ is the incoming radiance from the light source in direction $\\omega_i$.\n<br>\n\\- $(N \\cdot \\omega_i)$ is the cosine term accounting for the angle of incidence.\n\n\n### Task\nYou are required to replace the Blinn-Phong reflection model with the Cook-Torrance Bidirectional Reflectance Distribution Function (BRDF) to calculate the specular radiance at each point on the model in the scene. Additionally, ensure that metalness is considered when calculating the specular radiance.",
                                "hints": [],
                                "restrictions": [],
                                "order": 22,
                                "cost": 5,
                                "threshold": 95,
                                "likes": 1,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": true,
                                "animationSteps": 6,
                                "animationStepTime": 500,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": false
                            },
                            "vertexShader": "varying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  vPos = vec3(modelMatrix * vec4(position, 1.0));\n  \n  vNormal = normalize(mat3(transpose(inverse(modelMatrix))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\nuniform sampler2D iChannel0;\nuniform sampler2D iChannel1;\nuniform sampler2D iChannel2;\nuniform mat4 inverseViewMatrix;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nconst float PI = 3.14159265359;\n\nstruct TLight { vec3 position; vec3 color; };\n\nTLight c_Lights[3] = TLight[3](\n  TLight(vec3( 0.0, 5.0, 10.0), vec3(1.0, 1.0, 1.0)),\n  TLight(vec3( 8.0, 5.0, -8.0), vec3(0.5, 1.0, 0.5)),\n  TLight(vec3(-8.0, 5.0, -8.0), vec3(0.5, 0.5, 1.0))\n);\n\nfloat geometryGGX(float NdotV, float k) {\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\t\n    return nom / denom;\n}\n  \nfloat geometrySmith(vec3 N, vec3 V, vec3 L, float k) {\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx1 = geometryGGX(NdotV, k);\n    float ggx2 = geometryGGX(NdotL, k);\n\t\n    return ggx1 * ggx2;\n}\n\nfloat distributionGGX(vec3 N, vec3 H, float a) {\n    float a2     = a*a;\n    float NdotH  = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\t\n    float nom    = a2;\n    float denom  = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom        = 3.14 * denom * denom;\n\t\n    return nom / denom;\n}\n\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nvec3 getViewPos() {\n  return (inverseViewMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz;  \n}\n\nvoid main() {\n  vec3  fragColor = vec3(1.0, 0.6, 0.6);\n  vec3  fragNormal = normalize(vNormal);\n  float fragMetallic = 0.8;\n  float fragRoughness = 0.3;\n  vec3  fragPos = vPos;\n\n  // Base Reflectance\n  vec3 F0 = vec3(0.04);\n\n  vec3 viewPos = getViewPos();\n  vec3 viewDir = normalize(viewPos - fragPos);\n    \n  vec3 result = vec3(0.0);\n  for (int i = 0; i < 3; i++) {\n    vec3 lightColor = c_Lights[i].color;\n    vec3 lightPos = c_Lights[i].position;\n    vec3 lightDir = normalize(lightPos - fragPos);\n    vec3 halfwayDir = normalize(viewDir + lightDir);\n\n    float dist = distance(lightPos, fragPos);\n    float attenuation = 1.0 / (dist * 0.01 + 1.0);\n    lightColor *= attenuation;\n\n    float NoL = dot(fragNormal, lightDir);\n    if (NoL > 0.0) {\n      // Phong Specular Component\n      float shininess = 32.0;\n      float specular = pow(max(dot(fragNormal, halfwayDir), 0.0),  shininess);\n      \n      result += specular * lightColor;\n    }\n  }  \n  \n  gl_FragColor = vec4(result, 1.0);\n}",
                            "postProcessShader": "",
                            "properties": "",
                            "defaultVertexShader": "varying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  vPos = vec3(modelMatrix * vec4(position, 1.0));\n  \n  vNormal = normalize(mat3(transpose(inverse(modelMatrix))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\nuniform sampler2D iChannel0;\nuniform sampler2D iChannel1;\nuniform sampler2D iChannel2;\nuniform mat4 inverseViewMatrix;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nconst float PI = 3.14159265359;\n\nstruct TLight { vec3 position; vec3 color; };\n\nTLight c_Lights[3] = TLight[3](\n  TLight(vec3( 0.0, 5.0, 10.0), vec3(1.0, 1.0, 1.0)),\n  TLight(vec3( 8.0, 5.0, -8.0), vec3(0.5, 1.0, 0.5)),\n  TLight(vec3(-8.0, 5.0, -8.0), vec3(0.5, 0.5, 1.0))\n);\n\nfloat geometryGGX(float NdotV, float k) {\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\t\n    return nom / denom;\n}\n  \nfloat geometrySmith(vec3 N, vec3 V, vec3 L, float k) {\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx1 = geometryGGX(NdotV, k);\n    float ggx2 = geometryGGX(NdotL, k);\n\t\n    return ggx1 * ggx2;\n}\n\nfloat distributionGGX(vec3 N, vec3 H, float a) {\n    float a2     = a*a;\n    float NdotH  = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\t\n    float nom    = a2;\n    float denom  = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom        = 3.14 * denom * denom;\n\t\n    return nom / denom;\n}\n\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nvec3 getViewPos() {\n  return (inverseViewMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz;  \n}\n\nvoid main() {\n  vec3  fragColor = vec3(1.0, 0.6, 0.6);\n  vec3  fragNormal = normalize(vNormal);\n  float fragMetallic = 0.8;\n  float fragRoughness = 0.3;\n  vec3  fragPos = vPos;\n\n  // Base Reflectance\n  vec3 F0 = vec3(0.04);\n\n  vec3 viewPos = getViewPos();\n  vec3 viewDir = normalize(viewPos - fragPos);\n    \n  vec3 result = vec3(0.0);\n  for (int i = 0; i < 3; i++) {\n    vec3 lightColor = c_Lights[i].color;\n    vec3 lightPos = c_Lights[i].position;\n    vec3 lightDir = normalize(lightPos - fragPos);\n    vec3 halfwayDir = normalize(viewDir + lightDir);\n\n    float dist = distance(lightPos, fragPos);\n    float attenuation = 1.0 / (dist * 0.01 + 1.0);\n    lightColor *= attenuation;\n\n    float NoL = dot(fragNormal, lightDir);\n    if (NoL > 0.0) {\n      // Phong Specular Component\n      float shininess = 32.0;\n      float specular = pow(max(dot(fragNormal, halfwayDir), 0.0),  shininess);\n      \n      result += specular * lightColor;\n    }\n  }  \n  \n  gl_FragColor = vec4(result, 1.0);\n}",
                            "defaultPostProcessShader": "",
                            "defaultProperties": "",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 218,
                        "slug": "lambert-diffuse-reflection",
                        "moduleId": 6,
                        "name": "Lambert Diffuse Reflection",
                        "order": 23,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": true,
                        "premiumLock": 0,
                        "premium": false,
                        "child": {
                            "task": {
                                "id": 218,
                                "slug": "lambert-diffuse-reflection",
                                "moduleId": 6,
                                "name": "Lambert Diffuse Reflection",
                                "vertexShader": "varying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  vPos = vec3(modelMatrix * vec4(position, 1.0));\n  \n  vNormal = normalize(mat3(transpose(inverse(modelMatrix))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\nuniform sampler2D iChannel0;\nuniform sampler2D iChannel1;\nuniform sampler2D iChannel2;\nuniform mat4 inverseViewMatrix;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nconst float PI = 3.14159265359;\n\nstruct TLight { vec3 position; vec3 color; };\n\nTLight c_Lights[3] = TLight[3](\n  TLight(vec3( 0.0, 5.0, 10.0), vec3(3.0, 3.0, 3.0)),\n  TLight(vec3( 8.0, 5.0, -8.0), vec3(1.5, 3.0, 1.5)),\n  TLight(vec3(-8.0, 5.0, -8.0), vec3(1.5, 1.5, 3.0))\n);\n\nfloat geometryGGX(float NdotV, float k) {\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\t\n    return nom / denom;\n}\n  \nfloat geometrySmith(vec3 N, vec3 V, vec3 L, float k) {\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx1 = geometryGGX(NdotV, k);\n    float ggx2 = geometryGGX(NdotL, k);\n\t\n    return ggx1 * ggx2;\n}\n\nfloat distributionGGX(vec3 N, vec3 H, float a) {\n    float a2     = a*a;\n    float NdotH  = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\t\n    float nom    = a2;\n    float denom  = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom        = 3.14 * denom * denom;\n\t\n    return nom / denom;\n}\n\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nvec3 getViewPos() {\n  return (inverseViewMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz;  \n}\n\nvoid main() {\n  vec3  fragColor = vec3(1.0, 0.6, 0.6);\n  vec3  fragNormal = normalize(vNormal);\n  float fragMetallic = 0.3;\n  float fragRoughness = 0.4;\n  vec3  fragPos = vPos;\n\n  // Base Reflectance\n  vec3 F0 = vec3(0.04);\n  F0 = mix(F0, fragColor, fragMetallic);\n\n  vec3 viewPos = getViewPos();\n  vec3 viewDir = normalize(viewPos - fragPos);\n    \n  vec3 result = vec3(0.0);\n  for (int i= 0; i < 3; i++) {\n    vec3 lightColor = c_Lights[i].color;\n    vec3 lightPos = c_Lights[i].position;\n    vec3 lightDir = normalize(lightPos - fragPos);\n    vec3 halfwayDir = normalize(viewDir + lightDir);\n\n    float dist = distance(lightPos, fragPos);\n    float attenuation = 1.0 / (dist * 0.01 + 1.0);\n    lightColor *= attenuation;\n    \n    float NoL = dot(fragNormal, lightDir);\n    if (NoL > 0.0) {\n      float NoV = max(dot(fragNormal, viewDir), 0.0);\n      float HoV = max(dot(halfwayDir, viewDir), 0.0);\n\n      float k = pow(fragRoughness + 1.0, 2.0) / 8.0;\n      float G = geometrySmith(fragNormal, viewDir, lightDir, k);\n      vec3  F = fresnelSchlick(HoV, F0);\n      float D = distributionGGX(fragNormal, halfwayDir, fragRoughness);\n\n      vec3 kD = vec3(1.0) - F;\n      kD *= 1.0 - fragMetallic;\n      \n      vec3 Lo = vec3(0.0);\n      Lo += kD * fragColor / PI; \n      Lo += F * D * G / (4.0 * NoL * NoV);\n      Lo *= lightColor * NoL;\n  \n      result += Lo;\n    }\n  }\n  \n  gl_FragColor = vec4(result, 1.0);\n}",
                                "postProcessShader": "",
                                "properties": "",
                                "defaultVertexShader": "varying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  vPos = vec3(modelMatrix * vec4(position, 1.0));\n  \n  vNormal = normalize(mat3(transpose(inverse(modelMatrix))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\nuniform sampler2D iChannel0;\nuniform sampler2D iChannel1;\nuniform sampler2D iChannel2;\nuniform mat4 inverseViewMatrix;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nconst float PI = 3.14159265359;\n\nstruct TLight { vec3 position; vec3 color; };\n\nTLight c_Lights[3] = TLight[3](\n  TLight(vec3( 0.0, 5.0, 10.0), vec3(3.0, 3.0, 3.0)),\n  TLight(vec3( 8.0, 5.0, -8.0), vec3(1.5, 3.0, 1.5)),\n  TLight(vec3(-8.0, 5.0, -8.0), vec3(1.5, 1.5, 3.0))\n);\n\nfloat geometryGGX(float NdotV, float k) {\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\t\n    return nom / denom;\n}\n  \nfloat geometrySmith(vec3 N, vec3 V, vec3 L, float k) {\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx1 = geometryGGX(NdotV, k);\n    float ggx2 = geometryGGX(NdotL, k);\n\t\n    return ggx1 * ggx2;\n}\n\nfloat distributionGGX(vec3 N, vec3 H, float a) {\n    float a2     = a*a;\n    float NdotH  = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\t\n    float nom    = a2;\n    float denom  = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom        = 3.14 * denom * denom;\n\t\n    return nom / denom;\n}\n\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nvec3 getViewPos() {\n  return (inverseViewMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz;  \n}\n\nvoid main() {\n  vec3  fragColor = vec3(1.0, 0.6, 0.6);\n  vec3  fragNormal = normalize(vNormal);\n  float fragMetallic = 0.3;\n  float fragRoughness = 0.4;\n  vec3  fragPos = vPos;\n\n  // Base Reflectance\n  vec3 F0 = vec3(0.04);\n  F0 = mix(F0, fragColor, fragMetallic);\n\n  vec3 viewPos = getViewPos();\n  vec3 viewDir = normalize(viewPos - fragPos);\n    \n  vec3 result = vec3(0.0);\n  for (int i= 0; i < 3; i++) {\n    vec3 lightColor = c_Lights[i].color;\n    vec3 lightPos = c_Lights[i].position;\n    vec3 lightDir = normalize(lightPos - fragPos);\n    vec3 halfwayDir = normalize(viewDir + lightDir);\n\n    float dist = distance(lightPos, fragPos);\n    float attenuation = 1.0 / (dist * 0.01 + 1.0);\n    lightColor *= attenuation;\n    \n    float NoL = dot(fragNormal, lightDir);\n    if (NoL > 0.0) {\n      float NoV = max(dot(fragNormal, viewDir), 0.0);\n      float HoV = max(dot(halfwayDir, viewDir), 0.0);\n\n      float k = pow(fragRoughness + 1.0, 2.0) / 8.0;\n      float G = geometrySmith(fragNormal, viewDir, lightDir, k);\n      vec3  F = fresnelSchlick(HoV, F0);\n      float D = distributionGGX(fragNormal, halfwayDir, fragRoughness);\n      \n      vec3 Lo = vec3(0.0);\n      Lo += F * D * G / (4.0 * NoL * NoV);\n      Lo *= lightColor * NoL;\n  \n      result += Lo;\n    }\n  }\n  \n  gl_FragColor = vec4(result, 1.0);\n}",
                                "defaultPostProcessShader": "",
                                "defaultProperties": "",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":0,\"y\":15,\"z\":20},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":45,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":-1.57,\"y\":0,\"z\":0},\"scale\":{\"x\":2.5,\"y\":2.5,\"z\":2.5},\"geometry\":\"10\",\"model\":\"rabbit.glb\",\"meshes\":[{\"name\":\"21941_Rabbit_v1_NEW\",\"materialId\":0}],\"colorRGBA\":\"FFFFFF\",\"color\":null},{\"position\":{\"x\":0,\"y\":5,\"z\":10},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":2.5,\"y\":2.5,\"z\":2.5},\"geometry\":\"3\",\"model\":null,\"meshes\":[{\"name\":\"main\",\"materialId\":1}],\"colorRGBA\":\"FFFFFF\",\"color\":16777215},{\"position\":{\"x\":8,\"y\":5,\"z\":-8},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":2.5,\"y\":2.5,\"z\":2.5},\"geometry\":\"3\",\"model\":null,\"meshes\":[{\"name\":\"main\",\"materialId\":1}],\"colorRGBA\":\"19FF19\",\"color\":1703705},{\"position\":{\"x\":-8,\"y\":5,\"z\":-8},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":2.5,\"y\":2.5,\"z\":2.5},\"geometry\":\"3\",\"model\":null,\"meshes\":[{\"name\":\"main\",\"materialId\":1}],\"colorRGBA\":\"1919FF\",\"color\":1645055}],\"materials\":[{\"vertex\":\"attribute vec4 color;\\n\\nvarying vec4 vColor;\\n\\nvoid main() {\\n  vColor = color;\\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\\n}\\n\",\"fragment\":\"varying vec4 vColor;\\n\\nvoid main() {\\n  gl_FragColor = vColor * 5.0;\\n}\\n\",\"properties\":\"\"}],\"actions\":[{\"type\":0,\"speed\":1,\"pivot\":{\"x\":0,\"y\":5,\"z\":0}}],\"backgroundRGBA\":\"4080A0\",\"background\":4227232,\"customDepthBufferTexture\":false,\"glslVersion\":1}",
                                "description": "The Cook-Torrance reflection model is mainly used to describe specular reflection, but for a complete lighting model, a diffuse component is often added. In the simplest case, diffuse reflection can be added using **Lambert's diffuse reflection** model:\n\n$$\nf_\\text{lambert} = \\frac{c}{\\pi}\n$$\n\nwhere $c$ is the albedo or color of the surface (diffuse texture of the surface). We divide the diffuse part by ${\\pi}$ in the lighting model to normalize the distribution of light over the hemisphere around the surface. This is because, in diffuse reflection, light is evenly scattered in all directions.\n\n<br>\n\nThen, the overall BRDF formula will look as follows:\n\n$$\nfr(\\omega_i, \\omega_r) = \\frac{D(\\omega_h) G(\\omega_i, \\omega_r) F(\\omega_i, \\omega_r)}{4 (\\omega_i \\cdot n) (\\omega_r \\cdot n)} + (1 - F(\\omega_i, \\omega_r)) \\frac{c}{\\pi}\n$$\n\n### Task\nYou have a program that calculates specular radiance using the Cook-Torrance Bidirectional Reflectance Distribution Function (BRDF). Your task is to complete the lighting model by adding Lambert's diffuse reflection. Additionally, ensure that metalness is considered when calculating the diffuse reflection.",
                                "hints": [],
                                "restrictions": [],
                                "order": 23,
                                "cost": 5,
                                "threshold": 95,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": true,
                                "animationSteps": 6,
                                "animationStepTime": 500,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": false
                            },
                            "vertexShader": "varying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  vPos = vec3(modelMatrix * vec4(position, 1.0));\n  \n  vNormal = normalize(mat3(transpose(inverse(modelMatrix))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\nuniform sampler2D iChannel0;\nuniform sampler2D iChannel1;\nuniform sampler2D iChannel2;\nuniform mat4 inverseViewMatrix;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nconst float PI = 3.14159265359;\n\nstruct TLight { vec3 position; vec3 color; };\n\nTLight c_Lights[3] = TLight[3](\n  TLight(vec3( 0.0, 5.0, 10.0), vec3(3.0, 3.0, 3.0)),\n  TLight(vec3( 8.0, 5.0, -8.0), vec3(1.5, 3.0, 1.5)),\n  TLight(vec3(-8.0, 5.0, -8.0), vec3(1.5, 1.5, 3.0))\n);\n\nfloat geometryGGX(float NdotV, float k) {\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\t\n    return nom / denom;\n}\n  \nfloat geometrySmith(vec3 N, vec3 V, vec3 L, float k) {\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx1 = geometryGGX(NdotV, k);\n    float ggx2 = geometryGGX(NdotL, k);\n\t\n    return ggx1 * ggx2;\n}\n\nfloat distributionGGX(vec3 N, vec3 H, float a) {\n    float a2     = a*a;\n    float NdotH  = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\t\n    float nom    = a2;\n    float denom  = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom        = 3.14 * denom * denom;\n\t\n    return nom / denom;\n}\n\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nvec3 getViewPos() {\n  return (inverseViewMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz;  \n}\n\nvoid main() {\n  vec3  fragColor = vec3(1.0, 0.6, 0.6);\n  vec3  fragNormal = normalize(vNormal);\n  float fragMetallic = 0.3;\n  float fragRoughness = 0.4;\n  vec3  fragPos = vPos;\n\n  // Base Reflectance\n  vec3 F0 = vec3(0.04);\n  F0 = mix(F0, fragColor, fragMetallic);\n\n  vec3 viewPos = getViewPos();\n  vec3 viewDir = normalize(viewPos - fragPos);\n    \n  vec3 result = vec3(0.0);\n  for (int i= 0; i < 3; i++) {\n    vec3 lightColor = c_Lights[i].color;\n    vec3 lightPos = c_Lights[i].position;\n    vec3 lightDir = normalize(lightPos - fragPos);\n    vec3 halfwayDir = normalize(viewDir + lightDir);\n\n    float dist = distance(lightPos, fragPos);\n    float attenuation = 1.0 / (dist * 0.01 + 1.0);\n    lightColor *= attenuation;\n    \n    float NoL = dot(fragNormal, lightDir);\n    if (NoL > 0.0) {\n      float NoV = max(dot(fragNormal, viewDir), 0.0);\n      float HoV = max(dot(halfwayDir, viewDir), 0.0);\n\n      float k = pow(fragRoughness + 1.0, 2.0) / 8.0;\n      float G = geometrySmith(fragNormal, viewDir, lightDir, k);\n      vec3  F = fresnelSchlick(HoV, F0);\n      float D = distributionGGX(fragNormal, halfwayDir, fragRoughness);\n      \n      vec3 Lo = vec3(0.0);\n      Lo += F * D * G / (4.0 * NoL * NoV);\n      Lo *= lightColor * NoL;\n  \n      result += Lo;\n    }\n  }\n  \n  gl_FragColor = vec4(result, 1.0);\n}",
                            "postProcessShader": "",
                            "properties": "",
                            "defaultVertexShader": "varying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  vPos = vec3(modelMatrix * vec4(position, 1.0));\n  \n  vNormal = normalize(mat3(transpose(inverse(modelMatrix))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\nuniform sampler2D iChannel0;\nuniform sampler2D iChannel1;\nuniform sampler2D iChannel2;\nuniform mat4 inverseViewMatrix;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nconst float PI = 3.14159265359;\n\nstruct TLight { vec3 position; vec3 color; };\n\nTLight c_Lights[3] = TLight[3](\n  TLight(vec3( 0.0, 5.0, 10.0), vec3(3.0, 3.0, 3.0)),\n  TLight(vec3( 8.0, 5.0, -8.0), vec3(1.5, 3.0, 1.5)),\n  TLight(vec3(-8.0, 5.0, -8.0), vec3(1.5, 1.5, 3.0))\n);\n\nfloat geometryGGX(float NdotV, float k) {\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\t\n    return nom / denom;\n}\n  \nfloat geometrySmith(vec3 N, vec3 V, vec3 L, float k) {\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx1 = geometryGGX(NdotV, k);\n    float ggx2 = geometryGGX(NdotL, k);\n\t\n    return ggx1 * ggx2;\n}\n\nfloat distributionGGX(vec3 N, vec3 H, float a) {\n    float a2     = a*a;\n    float NdotH  = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\t\n    float nom    = a2;\n    float denom  = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom        = 3.14 * denom * denom;\n\t\n    return nom / denom;\n}\n\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nvec3 getViewPos() {\n  return (inverseViewMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz;  \n}\n\nvoid main() {\n  vec3  fragColor = vec3(1.0, 0.6, 0.6);\n  vec3  fragNormal = normalize(vNormal);\n  float fragMetallic = 0.3;\n  float fragRoughness = 0.4;\n  vec3  fragPos = vPos;\n\n  // Base Reflectance\n  vec3 F0 = vec3(0.04);\n  F0 = mix(F0, fragColor, fragMetallic);\n\n  vec3 viewPos = getViewPos();\n  vec3 viewDir = normalize(viewPos - fragPos);\n    \n  vec3 result = vec3(0.0);\n  for (int i= 0; i < 3; i++) {\n    vec3 lightColor = c_Lights[i].color;\n    vec3 lightPos = c_Lights[i].position;\n    vec3 lightDir = normalize(lightPos - fragPos);\n    vec3 halfwayDir = normalize(viewDir + lightDir);\n\n    float dist = distance(lightPos, fragPos);\n    float attenuation = 1.0 / (dist * 0.01 + 1.0);\n    lightColor *= attenuation;\n    \n    float NoL = dot(fragNormal, lightDir);\n    if (NoL > 0.0) {\n      float NoV = max(dot(fragNormal, viewDir), 0.0);\n      float HoV = max(dot(halfwayDir, viewDir), 0.0);\n\n      float k = pow(fragRoughness + 1.0, 2.0) / 8.0;\n      float G = geometrySmith(fragNormal, viewDir, lightDir, k);\n      vec3  F = fresnelSchlick(HoV, F0);\n      float D = distributionGGX(fragNormal, halfwayDir, fragRoughness);\n      \n      vec3 Lo = vec3(0.0);\n      Lo += F * D * G / (4.0 * NoL * NoV);\n      Lo *= lightColor * NoL;\n  \n      result += Lo;\n    }\n  }\n  \n  gl_FragColor = vec4(result, 1.0);\n}",
                            "defaultPostProcessShader": "",
                            "defaultProperties": "",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 221,
                        "slug": "equirectangular-texture",
                        "moduleId": 6,
                        "name": "Equirectangular texture",
                        "order": 25,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": true,
                        "premiumLock": 0,
                        "premium": false,
                        "child": {
                            "task": {
                                "id": 221,
                                "slug": "equirectangular-texture",
                                "moduleId": 6,
                                "name": "Equirectangular texture",
                                "vertexShader": "varying vec3 vPos;\nvarying vec3 vNormal;\n\nvoid main() {\n  vPos = vec3(modelMatrix * vec4(position, 1.0));\n  vNormal = normalize(mat3(transpose(inverse(modelMatrix))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform sampler2D iChannel0;\n\nconst float PI = 3.14;\n\nvarying vec3 vPos;\n\nvoid main() {\n  vec3 P = normalize(vPos);\n\n  float phi = atan(P.x, P.z);\n  float theta = asin(P.y);\n\n  float u = (phi + PI) / (2.0 * PI);\n  float v = (theta + PI * 0.5) / (PI);\n  \n  gl_FragColor = texture(iChannel0, vec2(u, v));\n}",
                                "postProcessShader": "",
                                "properties": "",
                                "defaultVertexShader": "varying vec3 vPos;\nvarying vec3 vNormal;\n\nvoid main() {\n  vPos = vec3(modelMatrix * vec4(position, 1.0));\n  vNormal = normalize(mat3(transpose(inverse(modelMatrix))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\nuniform sampler2D iChannel0;\n\nconst float PI = 3.14;\n\nvarying vec3 vPos;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  gl_FragColor = texture(iChannel0, uv);\n}",
                                "defaultPostProcessShader": "",
                                "defaultProperties": "",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":0,\"y\":0,\"z\":0.9},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":\"3\",\"model\":null,\"meshes\":[{\"name\":\"main\",\"materialId\":0}],\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"materials\":[],\"actions\":[{\"type\":0,\"speed\":0.5,\"pivot\":{\"x\":0,\"y\":0,\"z\":0}}],\"backgroundRGBA\":\"333333\",\"background\":3355443,\"customDepthBufferTexture\":false,\"glslVersion\":1}",
                                "description": "**Equirectangular texture** represents a spherical projection where the top and bottom parts of the image correspond to the poles, while the central part represents the equator.\n\n<br>\n\n![](/files/equirectangular_earth.jpg)\n\n<br>\n\nEach pixel of an equirectangular map represents a specific direction in space. To properly map the texture onto an object's surface, the surface normal is used. When projecting the map onto a sphere centered at the origin, the direction can be found by normalizing the position of the sphere fragment:\n\n```\nP = normalize(pos)\n```\n\nThis creates a unit sphere (with a radius of 1). Therefore, the vector from the sphere's center to the point $P$ on its surface will always have a length of 1.\n\n<br>\n\n![](/files/equirectangular_sphere.png)\n\n<br>\n\nFirst, we look at the plane formed by the $Y$ axis and the vector pointing to $P$. In this plane, the angle $\\phi$ is irrelevant.\n\n<br>\n\n![](/files/equirectangular_yp.png)\n\n<br>\n\nThe cross-section of the sphere in this plane is half of the unit circle (only half because we are interested in the interval $\\left[-\\frac{\\pi}{2}, \\frac{\\pi}{2}\\right]$ ). The position along the $Y$ axis is equal to the sine of the angle $\\theta$:\n\n$$\ny = sin(\\theta)\n$$\n\nTo find $\\theta$, we use the arcsine function:\n\n$$\n\\theta  = asin(y)\n$$\n\nThe value of $\\theta$ lies within the interval $\\left[-\\frac{\\pi}{2}, \\frac{\\pi}{2}\\right]$. To normalize it to the range $[0, 1]$ for use as the $v$ component of the texture coordinates:\n\n$$\nv = \\frac{(\\theta + \\frac{\\pi}{2})}{π}\n$$\n\nNext, let’s examine the $XZ$ plane:\n\n<br>\n\n![](/files/equirectangular_xz.png)\n\n<br>\n\nHere, the cross-section of the sphere is a full unit circle (covering the interval $\\left[0, 2\\pi\\right]$ ), where:\n\n$$\nx = sin(\\phi) \\qquad z = cos(\\phi)\n$$\n\nIn this case, point $P'$ is the same as point $P$, but with the $y$ component set to 0:\n\n$$\nP' = (P_x, 0, P_z)\n$$\n\nHowever, the projection $OP'$ is not always a unit vector. To calculate the angle, we use the tangent (the ratio of $x$ to $z$ ):\n\n$$\ntan(\\phi) = P_x/P_z\n$$\n\n$$\n\\phi = arctan(P_x/P_z)\n$$\n\nHere, $\\phi$ is within the interval $\\left[-\\pi, \\pi\\right]$. To normalize it to the range $\\left[0, 1\\right]$ for the $u$ texture coordinate:\n\n$$\nu = \\frac{\\phi + \\pi}{2\\pi}\n$$\n\n### Task\nYou are given an equirectangular texture representing the Earth map. This is a two-dimensional image of the spherical projection. Write a shader that maps the given equirectangular texture onto a sphere located at the center of the scene.\n",
                                "hints": [],
                                "restrictions": [],
                                "order": 25,
                                "cost": 5,
                                "threshold": 95,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [
                                    {
                                        "index": 0
                                    }
                                ],
                                "animated": true,
                                "animationSteps": 6,
                                "animationStepTime": 500,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": false
                            },
                            "vertexShader": "varying vec3 vPos;\nvarying vec3 vNormal;\n\nvoid main() {\n  vPos = vec3(modelMatrix * vec4(position, 1.0));\n  vNormal = normalize(mat3(transpose(inverse(modelMatrix))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\nuniform sampler2D iChannel0;\n\nconst float PI = 3.14;\n\nvarying vec3 vPos;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  gl_FragColor = texture(iChannel0, uv);\n}",
                            "postProcessShader": "",
                            "properties": "",
                            "defaultVertexShader": "varying vec3 vPos;\nvarying vec3 vNormal;\n\nvoid main() {\n  vPos = vec3(modelMatrix * vec4(position, 1.0));\n  vNormal = normalize(mat3(transpose(inverse(modelMatrix))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\nuniform sampler2D iChannel0;\n\nconst float PI = 3.14;\n\nvarying vec3 vPos;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  gl_FragColor = texture(iChannel0, uv);\n}",
                            "defaultPostProcessShader": "",
                            "defaultProperties": "",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    }
                ],
                "cover": true,
                "pageHeaderImage": true,
                "fullDesc": "This module is designed for developers who want to master the basics of lighting in computer graphics. You will learn about the Blinn-Phong lighting model, different types of light sources, texture maps and the fundamentals of Physically Based Rendering (PBR). Each topic includes theoretical material and a practical task that can be completed directly on the website.",
                "skillsDesc": "the Blinn-Phong lighting model and how it is applied in computer graphics.<br>different types of light sources, such as point, directional, and ambient lights.<br>master working with diffuse, specular and normal maps to add surface detail.<br>what metallicity is and how it affects the appearance of objects.<br>the basics of Physically Based Rendering (PBR) and its application for creating photorealistic images.",
                "importanceDesc": "Lighting plays a crucial role in creating realistic and visually appealing 3D scenes. Understanding the basics of lighting allows developers to create scenes with proper light and shadow distribution, making objects appear more three-dimensional and lifelike.",
                "certifiable": false,
                "images": [
                    "img-1.png",
                    "img-2.png",
                    "img-3.png",
                    "img-4.png",
                    "img-5.png",
                    "img-6.png"
                ]
            }
        },
        {
            "id": 12,
            "slug": "shadow-map",
            "name": "Shadow Map",
            "description": "Shadow mapping is a technique used in computer graphics to create realistic shadows in real-time rendering",
            "tasks": 8,
            "acceptedTasks": 0,
            "isOpen": false,
            "order": 4,
            "locked": false,
            "cover": true,
            "child": {
                "id": 12,
                "slug": "shadow-map",
                "name": "Shadow Map",
                "description": "Shadow mapping is a technique used in computer graphics to create realistic shadows in real-time rendering",
                "order": 4,
                "createdBy": {
                    "id": 3,
                    "name": "Alexander"
                },
                "locked": false,
                "tasks": [
                    {
                        "id": 164,
                        "slug": "shadow-map-view",
                        "moduleId": 12,
                        "name": "Shadow Map - View",
                        "order": 0,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": 0,
                        "premium": false,
                        "child": {
                            "task": {
                                "id": 164,
                                "slug": "shadow-map-view",
                                "moduleId": 12,
                                "name": "Shadow Map - View",
                                "vertexShader": "attribute vec4 color;\n\nvarying vec3 vLightDir;\nvarying vec3 vNormal;\nvarying vec4 vColor;\n\nvoid main() {\n  vec3 lightDir = normalize(vec3(-0.5, -0.8, 0.0));\n  vec3 lightPos = vec3(1.5, 2.4, 0.0);\n\n  vec3 front = -lightDir;\n  vec3 up = vec3(0.0, 1.0, 0.0);\n  vec3 right = normalize(cross(up, front));\n  vec3 fixedUp = normalize(cross(front, right));\n\n  // column major\n  mat4 lightView;\n  \n  // row 0 = dot(right, vertex_pos)\n  lightView[0][0] = right.x;\n  lightView[1][0] = right.y;\n  lightView[2][0] = right.z;\n  lightView[3][0] = -dot(lightPos, right);\n\n  // row 1 = dot(fixedUp, vertex_pos)\n  lightView[0][1] = fixedUp.x;\n  lightView[1][1] = fixedUp.y;\n  lightView[2][1] = fixedUp.z;\n  lightView[3][1] = -dot(lightPos, fixedUp);\n\n  // row 2 = dot(-front, vertex_pos)\n  lightView[0][2] = front.x;\n  lightView[1][2] = front.y;\n  lightView[2][2] = front.z;\n  lightView[3][2] = -dot(lightPos, front);\n\n  //row 3\n  lightView[0][3] = 0.0;\n  lightView[1][3] = 0.0;\n  lightView[2][3] = 0.0;\n  lightView[3][3] = 1.0;\n\n  gl_Position = projectionMatrix * lightView * modelMatrix * vec4(position, 1.0);\n\n  vLightDir = lightDir;\n  vNormal = mat3(modelMatrix) * normal;\n  vColor = color;\n}\n",
                                "fragmentShader": "varying vec3 vLightDir;\nvarying vec3 vNormal;\nvarying vec4 vColor;\n\nvoid main() {\n  float ambient = 0.2;  \n  float diffuse = dot(normalize(vNormal), normalize(-vLightDir));\n  \n  gl_FragColor = vec4((ambient + diffuse) * vColor.rgb, 1.0);\n}",
                                "defaultVertexShader": "attribute vec4 color;\n\nvarying vec3 vLightDir;\nvarying vec3 vNormal;\nvarying vec4 vColor;\n\nvoid main() {\n  vec3 lightDir = normalize(vec3(-0.5, -0.8, 0.0));\n  vec3 lightPos = vec3(1.5, 2.4, 0.0);\n\n  mat4 lightView = viewMatrix;\n  \n  gl_Position = projectionMatrix * lightView * modelMatrix * vec4(position, 1.0);\n\n  vLightDir = lightDir;\n  vNormal = mat3(modelMatrix) * normal;\n  vColor = color;\n}\n",
                                "defaultFragmentShader": "varying vec3 vLightDir;\nvarying vec3 vNormal;\nvarying vec4 vColor;\n\nvoid main() {\n  float ambient = 0.2;  \n  float diffuse = dot(normalize(vNormal), normalize(-vLightDir));\n  \n  gl_FragColor = vec4((ambient + diffuse) * vColor.rgb, 1.0);\n}",
                                "vertexCodeEditable": true,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":0,\"y\":0.75,\"z\":3.5},\"rotation\":{\"x\":-0.4,\"y\":0,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":45,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":-1,\"z\":0},\"rotation\":{\"x\":-1.57,\"y\":0,\"z\":0},\"scale\":{\"x\":8,\"y\":8,\"z\":1},\"geometry\":1,\"colorRGBA\":\"4080A0\",\"color\":4227232},{\"position\":{\"x\":0,\"y\":-0.25,\"z\":0},\"rotation\":{\"x\":0,\"y\":0.5,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":\"2\",\"colorRGBA\":\"008080\",\"color\":32896}],\"backgroundRGBA\":\"EEEEEE\",\"background\":15658734}",
                                "description": "The idea behind shadow maps is as follows: we additionally draw the scene from the light source point of view. The view for the shadow map is aligned with the light's local coordinate system. Everything that is visible is illuminated, the rest is in shadow.\n\n<br>\n\n![](/files/shadow-map-overview.png)\n\n<br>\n\nTo implement the algorithm we first need to figure out how to form a new view matrix having the direction vector **F** in a right-handed coordinate system (OpenGL is right-handed). Follow these steps:\n\n1. Normalize and flip the direction vector **F**, since the Z-axis must be pointing towards the camera in the right-handed coordinate system.\n\n<br>\n\n![](/files/shadow-map-view-flip-front.png)\n\n<br>\n\n2. Take up vector **U** in world space, it is typically `(0, 1, 0)`.\n3. Compute the right vector **R**. The right vector **R** is perpendicular to the direction vector **-F** and the up vector **U**. You can compute it using the cross product: **R** = **U** x **-F**\n\n<br>\n\n![](/files/shadow-map-view-right.png)\n\n<br>\n\n4. Compute the new Up vector. We know for sure that vectors **-F** and **R** are perpendicular, but we cannot guarantee that **-F** and **U** are perpendicular since their values were taken independently of each other. Therefore, we need to calculate a new vector **U'** that completes the orthogonal system: **U'** = **-F** x **R**.\n\n<br>\n\n![](/files/shadow-map-view-up.png)\n\n<br>\n\n5. Create the View Matrix. The view matrix is a 4x4 matrix that combines the right, up, and direction vectors. It looks like this:\n\n```\n    | Rx   Ry   Rz  0|\n    | U`x  U`y  U`z 0|\n    |-Fx  -Fy  -Fz  0|\n    | 0    0    0   1|\n```\n\n6. Add Translation. To translate an object from world space coordinates to view space coordinates, we must subtract the position of view **P** from the position of the object. This can be represented as a matrix:\n\n```\n    | 1 0 0 -Px|\n    | 0 1 0 -Py|\n    | 0 0 1 -Pz|\n    | 0 0 0  1 |\n```\n\nWe can add the translation to our view matrix by matrix multiplication:\n\n```\n    | Rx   Ry   Rz  0|   | 1 0 0 -Px|\n    | U`x  U`y  U`z 0| X | 0 1 0 -Py|\n    |-Fx  -Fy  -Fz  0|   | 0 0 1 -Pz|\n    | 0    0    0   1|   | 0 0 0  1 |\n```\n\n7. If rendering system expects column-major matrices (like OpenGL), transpose the matrix.\n\n### Task\n\nCalculate a new view matrix (also known as a light view matrix) that transforms the scene to the light source’s space. This allows us to see the scene as if we were looking directly from the light source.",
                                "hints": [],
                                "restrictions": [],
                                "order": 0,
                                "cost": 5,
                                "threshold": 98,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": false
                            },
                            "vertexShader": "attribute vec4 color;\n\nvarying vec3 vLightDir;\nvarying vec3 vNormal;\nvarying vec4 vColor;\n\nvoid main() {\n  vec3 lightDir = normalize(vec3(-0.5, -0.8, 0.0));\n  vec3 lightPos = vec3(1.5, 2.4, 0.0);\n\n  mat4 lightView = viewMatrix;\n  \n  gl_Position = projectionMatrix * lightView * modelMatrix * vec4(position, 1.0);\n\n  vLightDir = lightDir;\n  vNormal = mat3(modelMatrix) * normal;\n  vColor = color;\n}\n",
                            "fragmentShader": "varying vec3 vLightDir;\nvarying vec3 vNormal;\nvarying vec4 vColor;\n\nvoid main() {\n  float ambient = 0.2;  \n  float diffuse = dot(normalize(vNormal), normalize(-vLightDir));\n  \n  gl_FragColor = vec4((ambient + diffuse) * vColor.rgb, 1.0);\n}",
                            "defaultVertexShader": "attribute vec4 color;\n\nvarying vec3 vLightDir;\nvarying vec3 vNormal;\nvarying vec4 vColor;\n\nvoid main() {\n  vec3 lightDir = normalize(vec3(-0.5, -0.8, 0.0));\n  vec3 lightPos = vec3(1.5, 2.4, 0.0);\n\n  mat4 lightView = viewMatrix;\n  \n  gl_Position = projectionMatrix * lightView * modelMatrix * vec4(position, 1.0);\n\n  vLightDir = lightDir;\n  vNormal = mat3(modelMatrix) * normal;\n  vColor = color;\n}\n",
                            "defaultFragmentShader": "varying vec3 vLightDir;\nvarying vec3 vNormal;\nvarying vec4 vColor;\n\nvoid main() {\n  float ambient = 0.2;  \n  float diffuse = dot(normalize(vNormal), normalize(-vLightDir));\n  \n  gl_FragColor = vec4((ambient + diffuse) * vColor.rgb, 1.0);\n}",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 165,
                        "slug": "shadow-map-orthographic-projection",
                        "moduleId": 12,
                        "name": "Shadow Map - Orthographic Projection",
                        "order": 1,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": true,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 165,
                                "slug": "shadow-map-orthographic-projection",
                                "moduleId": 12,
                                "name": "Shadow Map - Orthographic Projection",
                                "vertexShader": "uniform vec2 iResolution;\n\nattribute vec4 color;\n\nvarying vec3 vLightDir;\nvarying vec3 vNormal;\nvarying vec4 vColor;\n\nmat4 getLightProjection() {\n  float ratio = iResolution.x / iResolution.y;\n  float size = 2.0;\n  float left = -size * ratio;\n  float right = size * ratio;\n  float top = size;\n  float bottom = -size;\n  float far = 8.0;\n  float near = 0.1;\n  \n  mat4 lightProjection;\n  \n  lightProjection[0][0] = 2.0 / (right - left);\n  lightProjection[1][0] = 0.0;\n  lightProjection[2][0] = 0.0;\n  lightProjection[3][0] = -(right + left) / (right - left);\n\n  lightProjection[0][1] = 0.0;\n  lightProjection[1][1] = 2.0 / (top - bottom);\n  lightProjection[2][1] = 0.0;\n  lightProjection[3][1] = -(top + bottom) / (top - bottom);\n\n  lightProjection[0][2] = 0.0;\n  lightProjection[1][2] = 0.0;\n  lightProjection[2][2] = -2.0 / (far - near);\n  lightProjection[3][2] = -(far + near) / (far - near);\n\n  lightProjection[0][3] = 0.0;\n  lightProjection[1][3] = 0.0;\n  lightProjection[2][3] = 0.0;\n  lightProjection[3][3] = 1.0;\n\n  return lightProjection;\n}\n\nvoid main() {\n  vec3 lightDir = normalize(vec3(-0.5, -0.8, 0.0));\n  vec3 lightPos = vec3(1.5, 2.4, 0.0);\n\n  vec3 front = -lightDir;\n  vec3 up = vec3(0.0, 1.0, 0.0);\n  vec3 right = normalize(cross(up, front));\n  vec3 fixedUp = normalize(cross(front, right));\n\n  // column major\n  mat4 lightView;\n  \n  // row 0 = dot(right, vertex_pos)\n  lightView[0][0] = right.x;\n  lightView[1][0] = right.y;\n  lightView[2][0] = right.z;\n  lightView[3][0] = -dot(lightPos, right);\n\n  // row 1 = dot(fixedUp, vertex_pos)\n  lightView[0][1] = fixedUp.x;\n  lightView[1][1] = fixedUp.y;\n  lightView[2][1] = fixedUp.z;\n  lightView[3][1] = -dot(lightPos, fixedUp);\n\n  // row 2 = dot(-front, vertex_pos)\n  lightView[0][2] = front.x;\n  lightView[1][2] = front.y;\n  lightView[2][2] = front.z;\n  lightView[3][2] = -dot(lightPos, front);\n\n  //row 3\n  lightView[0][3] = 0.0;\n  lightView[1][3] = 0.0;\n  lightView[2][3] = 0.0;\n  lightView[3][3] = 1.0;\n\n  gl_Position = getLightProjection() * lightView * modelMatrix * vec4(position, 1.0);\n\n  vLightDir = lightDir;\n  vNormal = mat3(modelMatrix) * normal;\n  vColor = color;\n}\n",
                                "fragmentShader": "varying vec3 vLightDir;\nvarying vec3 vNormal;\nvarying vec4 vColor;\n\nvoid main() {\n  float ambient = 0.2;  \n  float diffuse = dot(normalize(vNormal), normalize(-vLightDir));\n  \n  gl_FragColor = vec4((ambient + diffuse) * vColor.rgb, 1.0);\n}",
                                "defaultVertexShader": "uniform vec2 iResolution;\n\nattribute vec4 color;\n\nvarying vec3 vLightDir;\nvarying vec3 vNormal;\nvarying vec4 vColor;\n\nmat4 getLightProjection() {\n  float left = -2.0;\n  float right = 2.0;\n  float top = 2.0;\n  float bottom = -2.0;\n  float far = 8.0;\n  float near = 0.1;\n\n  mat4 lightProjection; \n  return lightProjection;\n}\n\nvoid main() {\n  \n  vec3 lightDir = normalize(vec3(-0.5, -0.8, 0.0));\n  vec3 lightPos = vec3(1.5, 2.4, 0.0);\n\n  mat4 lightView = viewMatrix;\n  \n  gl_Position = projectionMatrix * lightView * modelMatrix * vec4(position, 1.0);\n\n  vLightDir = lightDir;\n  vNormal = mat3(modelMatrix) * normal;\n  vColor = color;\n}\n",
                                "defaultFragmentShader": "varying vec3 vLightDir;\nvarying vec3 vNormal;\nvarying vec4 vColor;\n\nvoid main() {\n  float ambient = 0.2;  \n  float diffuse = dot(normalize(vNormal), normalize(-vLightDir));\n  \n  gl_FragColor = vec4((ambient + diffuse) * vColor.rgb, 1.0);\n}",
                                "vertexCodeEditable": true,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":0,\"y\":0.75,\"z\":3.5},\"rotation\":{\"x\":-0.4,\"y\":0,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":45,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":-1,\"z\":0},\"rotation\":{\"x\":-1.57,\"y\":0,\"z\":0},\"scale\":{\"x\":8,\"y\":8,\"z\":1},\"geometry\":1,\"colorRGBA\":\"4080A0\",\"color\":4227232},{\"position\":{\"x\":0,\"y\":-0.25,\"z\":0},\"rotation\":{\"x\":0,\"y\":0.5,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":\"2\",\"colorRGBA\":\"008080\",\"color\":32896}],\"backgroundRGBA\":\"EEEEEE\",\"background\":15658734}",
                                "description": "We are modelling a directional light source, so all light rays are parallel. \n\n<br>\n\n![](/files/shadow-map-directed-light.png)\n\n<br>\n\nFor this reason, we are going to use an orthographic projection matrix for the light source as there is no perspective distortion and all rays remain parallel. \n\n<br>\n\n![](/files/shadow-map-ortho-vs-persp.png)\n\n<br>\n\nIn orthographic projection camera-space points are always mapped to the projection plane by casting rays that are parallel to the camera’s viewing direction.\n\n<br>\n\nTo create an orthogonal projection matrix, you will need the following parameters:\n1. Left (**L**), Right (**R**): The extents of the view volume along the X-axis.\n2. Bottom (**B**), Top (**T**): The extents along the Y-axis.\n3. Near plane distance (**N**): The closest distance from the camera where objects are visible.\n4. Far plane distance (**F**): The farthest distance where objects are still visible.\n\nThe orthogonal projection matrix maps the x and y coordinates from the ranges [**L**, **R**] and [**B**, **T**] to the range [−1,1]:\n\n```\nx` = (x-L)/(R-L) * 2 - 1 = x*[2/(R-L)] + [-(R+L)/(R-L)]\ny` = (y-B)/(T-B) * 2 - 1 = y*[2/(T-B)] + [-(T+B)/(T-B)]\n```\n\nIn a similar manner, but negating z since we use the right-handed coordinate system where the Z-axis is directed into the camera:\n\n```\nz` = (-z-N)/(F-N) * 2 - 1 = z*[-2/(F-N)] + [-(F+N)/(F-N)]\n```\n\nWe purposely emphasised the multiplicative and aditive parts of the coordinate transformation to make it easier to represent the transformation in matrix form:\n\n```\n| 2/(R-L)    0        0    -(R+L)/(R-L)|\n|    0    2/(T-B)     0    -(T+B)/(T-B)|\n|    0       0    -2/(F-N) -(F+N)/(F-N)|\n|    0       0        0          1     |\n```\n\nDon't forget to transpose the matrix if the rendering system expects column-major matrices (like OpenGL).\n\n### Task\n\nDraw the scene from the light source point of view using orthogonal projection. When forming the projection matrix, take into account the aspect ratio of the screen.",
                                "hints": [],
                                "restrictions": [],
                                "order": 1,
                                "cost": 5,
                                "threshold": 98,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "uniform vec2 iResolution;\n\nattribute vec4 color;\n\nvarying vec3 vLightDir;\nvarying vec3 vNormal;\nvarying vec4 vColor;\n\nmat4 getLightProjection() {\n  float left = -2.0;\n  float right = 2.0;\n  float top = 2.0;\n  float bottom = -2.0;\n  float far = 8.0;\n  float near = 0.1;\n\n  mat4 lightProjection; \n  return lightProjection;\n}\n\nvoid main() {\n  \n  vec3 lightDir = normalize(vec3(-0.5, -0.8, 0.0));\n  vec3 lightPos = vec3(1.5, 2.4, 0.0);\n\n  mat4 lightView = viewMatrix;\n  \n  gl_Position = projectionMatrix * lightView * modelMatrix * vec4(position, 1.0);\n\n  vLightDir = lightDir;\n  vNormal = mat3(modelMatrix) * normal;\n  vColor = color;\n}\n",
                            "fragmentShader": "varying vec3 vLightDir;\nvarying vec3 vNormal;\nvarying vec4 vColor;\n\nvoid main() {\n  float ambient = 0.2;  \n  float diffuse = dot(normalize(vNormal), normalize(-vLightDir));\n  \n  gl_FragColor = vec4((ambient + diffuse) * vColor.rgb, 1.0);\n}",
                            "defaultVertexShader": "uniform vec2 iResolution;\n\nattribute vec4 color;\n\nvarying vec3 vLightDir;\nvarying vec3 vNormal;\nvarying vec4 vColor;\n\nmat4 getLightProjection() {\n  float left = -2.0;\n  float right = 2.0;\n  float top = 2.0;\n  float bottom = -2.0;\n  float far = 8.0;\n  float near = 0.1;\n\n  mat4 lightProjection; \n  return lightProjection;\n}\n\nvoid main() {\n  \n  vec3 lightDir = normalize(vec3(-0.5, -0.8, 0.0));\n  vec3 lightPos = vec3(1.5, 2.4, 0.0);\n\n  mat4 lightView = viewMatrix;\n  \n  gl_Position = projectionMatrix * lightView * modelMatrix * vec4(position, 1.0);\n\n  vLightDir = lightDir;\n  vNormal = mat3(modelMatrix) * normal;\n  vColor = color;\n}\n",
                            "defaultFragmentShader": "varying vec3 vLightDir;\nvarying vec3 vNormal;\nvarying vec4 vColor;\n\nvoid main() {\n  float ambient = 0.2;  \n  float diffuse = dot(normalize(vNormal), normalize(-vLightDir));\n  \n  gl_FragColor = vec4((ambient + diffuse) * vColor.rgb, 1.0);\n}",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 166,
                        "slug": "shadow-map-depth-buffer",
                        "moduleId": 12,
                        "name": "Shadow Map - Depth Buffer",
                        "order": 2,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": true,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 166,
                                "slug": "shadow-map-depth-buffer",
                                "moduleId": 12,
                                "name": "Shadow Map - Depth Buffer",
                                "vertexShader": "uniform vec2 iResolution;\n\nattribute vec4 color;\n\nvarying vec3 vLightDir;\nvarying vec3 vNormal;\nvarying vec4 vColor;\nvarying vec4 vPos;\n\nmat4 getLightProjection() {\n  float ratio = iResolution.x / iResolution.y;\n  float size = 2.0;\n  float left = -size * ratio;\n  float right = size * ratio;\n  float top = size;\n  float bottom = -size;\n  float far = 8.0;\n  float near = 0.1;\n  \n  mat4 lightProjection;\n  \n  lightProjection[0][0] = 2.0 / (right - left);\n  lightProjection[1][0] = 0.0;\n  lightProjection[2][0] = 0.0;\n  lightProjection[3][0] = -(right + left) / (right - left);\n\n  lightProjection[0][1] = 0.0;\n  lightProjection[1][1] = 2.0 / (top - bottom);\n  lightProjection[2][1] = 0.0;\n  lightProjection[3][1] = -(top + bottom) / (top - bottom);\n\n  lightProjection[0][2] = 0.0;\n  lightProjection[1][2] = 0.0;\n  lightProjection[2][2] = -2.0 / (far - near);\n  lightProjection[3][2] = -(far + near) / (far - near);\n\n  lightProjection[0][3] = 0.0;\n  lightProjection[1][3] = 0.0;\n  lightProjection[2][3] = 0.0;\n  lightProjection[3][3] = 1.0;\n\n  return lightProjection;\n}\n\nvoid main() {\n  vec3 lightDir = normalize(vec3(-0.5, -0.8, 0.0));\n  vec3 lightPos = vec3(1.5, 2.4, 0.0);\n\n  vec3 front = -lightDir;\n  vec3 up = vec3(0.0, 1.0, 0.0);\n  vec3 right = normalize(cross(up, front));\n  vec3 fixedUp = normalize(cross(front, right));\n\n  // column major\n  mat4 lightView;\n  \n  // row 0 = dot(right, vertex_pos)\n  lightView[0][0] = right.x;\n  lightView[1][0] = right.y;\n  lightView[2][0] = right.z;\n  lightView[3][0] = -dot(lightPos, right);\n\n  // row 1 = dot(fixedUp, vertex_pos)\n  lightView[0][1] = fixedUp.x;\n  lightView[1][1] = fixedUp.y;\n  lightView[2][1] = fixedUp.z;\n  lightView[3][1] = -dot(lightPos, fixedUp);\n\n  // row 2 = dot(-front, vertex_pos)\n  lightView[0][2] = front.x;\n  lightView[1][2] = front.y;\n  lightView[2][2] = front.z;\n  lightView[3][2] = -dot(lightPos, front);\n\n  //row 3\n  lightView[0][3] = 0.0;\n  lightView[1][3] = 0.0;\n  lightView[2][3] = 0.0;\n  lightView[3][3] = 1.0;\n\n  vec4 pos = getLightProjection() * lightView * modelMatrix * vec4(position, 1.0);\n  gl_Position = pos;\n\n  vLightDir = lightDir;\n  vNormal = mat3(modelMatrix) * normal;\n  vColor = color;\n  vPos = pos;\n}\n",
                                "fragmentShader": "varying vec3 vLightDir;\nvarying vec3 vNormal;\nvarying vec4 vColor;\nvarying vec4 vPos;\n\nvoid main() {\n  // float ambient = 0.2;  \n  // float diffuse = dot(normalize(vNormal), normalize(-vLightDir));\n  // gl_FragColor = vec4((ambient + diffuse) * vColor.rgb, 1.0);\n\n  float depth = vPos.z * 0.5 + 0.5;\n  gl_FragColor = vec4(depth, depth, depth, 1.0);\n}",
                                "defaultVertexShader": "uniform vec2 iResolution;\n\nattribute vec4 color;\n\nvarying vec3 vLightDir;\nvarying vec3 vNormal;\nvarying vec4 vColor;\n\nmat4 getLightProjection() {\n  float left = -2.0;\n  float right = 2.0;\n  float top = 2.0;\n  float bottom = -2.0;\n  float far = 8.0;\n  float near = 0.1;\n\n  mat4 lightProjection; \n  return lightProjection;\n}\n\nvoid main() {\n  \n  vec3 lightDir = normalize(vec3(-0.5, -0.8, 0.0));\n  vec3 lightPos = vec3(1.5, 2.4, 0.0);\n\n  mat4 lightView = viewMatrix;\n  \n  gl_Position = projectionMatrix * lightView * modelMatrix * vec4(position, 1.0);\n\n  vLightDir = lightDir;\n  vNormal = mat3(modelMatrix) * normal;\n  vColor = color;\n}\n",
                                "defaultFragmentShader": "varying vec3 vLightDir;\nvarying vec3 vNormal;\nvarying vec4 vColor;\n\nvoid main() {\n  float ambient = 0.2;  \n  float diffuse = dot(normalize(vNormal), normalize(-vLightDir));\n  \n  gl_FragColor = vec4((ambient + diffuse) * vColor.rgb, 1.0);\n}",
                                "vertexCodeEditable": true,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":0,\"y\":0.75,\"z\":3.5},\"rotation\":{\"x\":-0.4,\"y\":0,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":45,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":-1,\"z\":0},\"rotation\":{\"x\":-1.57,\"y\":0,\"z\":0},\"scale\":{\"x\":8,\"y\":8,\"z\":1},\"geometry\":1,\"colorRGBA\":\"4080A0\",\"color\":4227232},{\"position\":{\"x\":0,\"y\":-0.25,\"z\":0},\"rotation\":{\"x\":0,\"y\":0.5,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":\"2\",\"colorRGBA\":\"008080\",\"color\":32896}],\"backgroundRGBA\":\"EEEEEE\",\"background\":15658734}",
                                "description": "A **depth map** is a texture with depth values rendered from the perspective of a light source. Each pixel in the depth map stores the distance from the camera to the corresponding point in the scene. In a view space the Z-coordinate of a fragment corresponds directly to its distance from the camera. \n\n<br>\n\n![](/files/shadow-map-depth-buffer.png)\n\n<br>\n\nThe distance are usually normalized in the range **[0, 1]**. A value of **0** typically corresponds to the near plane (closest to the camera), and a value of **1** corresponds to the far plane (farthest visible distance). Intermediate values represent depths between these planes.\n\n### Task\n\nDraw the scene depth from the light source point of view using orthogonal projection. When forming the projection matrix, take into account the aspect ratio of the screen.",
                                "hints": [],
                                "restrictions": [],
                                "order": 2,
                                "cost": 5,
                                "threshold": 98,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "uniform vec2 iResolution;\n\nattribute vec4 color;\n\nvarying vec3 vLightDir;\nvarying vec3 vNormal;\nvarying vec4 vColor;\n\nmat4 getLightProjection() {\n  float left = -2.0;\n  float right = 2.0;\n  float top = 2.0;\n  float bottom = -2.0;\n  float far = 8.0;\n  float near = 0.1;\n\n  mat4 lightProjection; \n  return lightProjection;\n}\n\nvoid main() {\n  \n  vec3 lightDir = normalize(vec3(-0.5, -0.8, 0.0));\n  vec3 lightPos = vec3(1.5, 2.4, 0.0);\n\n  mat4 lightView = viewMatrix;\n  \n  gl_Position = projectionMatrix * lightView * modelMatrix * vec4(position, 1.0);\n\n  vLightDir = lightDir;\n  vNormal = mat3(modelMatrix) * normal;\n  vColor = color;\n}\n",
                            "fragmentShader": "varying vec3 vLightDir;\nvarying vec3 vNormal;\nvarying vec4 vColor;\n\nvoid main() {\n  float ambient = 0.2;  \n  float diffuse = dot(normalize(vNormal), normalize(-vLightDir));\n  \n  gl_FragColor = vec4((ambient + diffuse) * vColor.rgb, 1.0);\n}",
                            "defaultVertexShader": "uniform vec2 iResolution;\n\nattribute vec4 color;\n\nvarying vec3 vLightDir;\nvarying vec3 vNormal;\nvarying vec4 vColor;\n\nmat4 getLightProjection() {\n  float left = -2.0;\n  float right = 2.0;\n  float top = 2.0;\n  float bottom = -2.0;\n  float far = 8.0;\n  float near = 0.1;\n\n  mat4 lightProjection; \n  return lightProjection;\n}\n\nvoid main() {\n  \n  vec3 lightDir = normalize(vec3(-0.5, -0.8, 0.0));\n  vec3 lightPos = vec3(1.5, 2.4, 0.0);\n\n  mat4 lightView = viewMatrix;\n  \n  gl_Position = projectionMatrix * lightView * modelMatrix * vec4(position, 1.0);\n\n  vLightDir = lightDir;\n  vNormal = mat3(modelMatrix) * normal;\n  vColor = color;\n}\n",
                            "defaultFragmentShader": "varying vec3 vLightDir;\nvarying vec3 vNormal;\nvarying vec4 vColor;\n\nvoid main() {\n  float ambient = 0.2;  \n  float diffuse = dot(normalize(vNormal), normalize(-vLightDir));\n  \n  gl_FragColor = vec4((ambient + diffuse) * vColor.rgb, 1.0);\n}",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 167,
                        "slug": "shadow-map-render-passes",
                        "moduleId": 12,
                        "name": "Shadow Map - Render Passes",
                        "order": 3,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": true,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 167,
                                "slug": "shadow-map-render-passes",
                                "moduleId": 12,
                                "name": "Shadow Map - Render Passes",
                                "vertexShader": "uniform vec2 iResolution;\nuniform int iDepthPass;\n\nattribute vec4 color;\nattribute int id;\n\nflat varying int vId;\nvarying vec3 vLightDir;\nvarying vec3 vNormal;\nvarying vec4 vColor;\nvarying vec4 vPos;\nvarying vec2 vUv;\n\nmat4 getLightProjection() {\n  float ratio = iResolution.x / iResolution.y;\n  float size = 2.0;\n  float left = -size * ratio;\n  float right = size * ratio;\n  float top = size;\n  float bottom = -size;\n  float far = 8.0;\n  float near = 0.1;\n  \n  mat4 lightProjection;\n  \n  lightProjection[0][0] = 2.0 / (right - left);\n  lightProjection[1][0] = 0.0;\n  lightProjection[2][0] = 0.0;\n  lightProjection[3][0] = -(right + left) / (right - left);\n\n  lightProjection[0][1] = 0.0;\n  lightProjection[1][1] = 2.0 / (top - bottom);\n  lightProjection[2][1] = 0.0;\n  lightProjection[3][1] = -(top + bottom) / (top - bottom);\n\n  lightProjection[0][2] = 0.0;\n  lightProjection[1][2] = 0.0;\n  lightProjection[2][2] = -2.0 / (far - near);\n  lightProjection[3][2] = -(far + near) / (far - near);\n\n  lightProjection[0][3] = 0.0;\n  lightProjection[1][3] = 0.0;\n  lightProjection[2][3] = 0.0;\n  lightProjection[3][3] = 1.0;\n\n  return lightProjection;\n}\n\nvoid main() {\n  vec3 lightDir = normalize(vec3(-0.5, -0.8, 0.0));\n  vec3 lightPos = vec3(1.5, 2.4, 0.0);\n\n  vec3 front = -lightDir;\n  vec3 up = vec3(0.0, 1.0, 0.0);\n  vec3 right = normalize(cross(up, front));\n  vec3 fixedUp = normalize(cross(front, right));\n\n  // column major\n  mat4 lightView;\n  \n  // row 0 = dot(right, vertex_pos)\n  lightView[0][0] = right.x;\n  lightView[1][0] = right.y;\n  lightView[2][0] = right.z;\n  lightView[3][0] = -dot(lightPos, right);\n\n  // row 1 = dot(fixedUp, vertex_pos)\n  lightView[0][1] = fixedUp.x;\n  lightView[1][1] = fixedUp.y;\n  lightView[2][1] = fixedUp.z;\n  lightView[3][1] = -dot(lightPos, fixedUp);\n\n  // row 2 = dot(-front, vertex_pos)\n  lightView[0][2] = front.x;\n  lightView[1][2] = front.y;\n  lightView[2][2] = front.z;\n  lightView[3][2] = -dot(lightPos, front);\n\n  //row 3\n  lightView[0][3] = 0.0;\n  lightView[1][3] = 0.0;\n  lightView[2][3] = 0.0;\n  lightView[3][3] = 1.0;\n\n  mat4 projView;\n  if (iDepthPass == 1) {\n    projView = getLightProjection() * lightView;\n  } else {\n    projView = projectionMatrix * viewMatrix;\n  }\n\n  vec4 pos = projView * modelMatrix * vec4(position, 1.0);\n  gl_Position = pos;\n\n  vId = id;\n  vLightDir = lightDir;\n  vNormal = mat3(modelMatrix) * normal;\n  vColor = color;\n  vPos = pos;\n  vUv = uv;\n}\n",
                                "fragmentShader": "uniform sampler2D iDepthBuffer;\nuniform int iDepthPass;\n\nflat varying int vId;\nvarying vec3 vLightDir;\nvarying vec3 vNormal;\nvarying vec4 vColor;\nvarying vec4 vPos;\nvarying vec2 vUv;\n\nvoid main() {\n  // float ambient = 0.2;  \n  // float diffuse = dot(normalize(vNormal), normalize(-vLightDir));\n  // gl_FragColor = vec4((ambient + diffuse) * vColor.rgb, 1.0);\n\n  // float depth = vPos.z * 0.5 + 0.5;\n  // gl_FragColor = vec4(depth, depth, depth, 1.0);\n\n\n  if (iDepthPass == 1) {\n    if (vId == 2) discard;\n    \n    float depth = vPos.z * 0.5 + 0.5;\n    gl_FragColor = vec4(depth, depth, depth, 1.0);\n    \n  } else {\n    float ambient = 0.2;  \n    float diffuse = dot(normalize(vNormal), normalize(-vLightDir));\n    vec4 objColor = vec4((ambient + diffuse) * vColor.rgb, 1.0);\n\n    if (vId == 2) {\n      vec3 depth = texture(iDepthBuffer, vUv).rrr;\n      gl_FragColor = vec4(depth, 1.0);\n    } else {\n      gl_FragColor = objColor;\n    }\n  }\n}",
                                "defaultVertexShader": "uniform vec2 iResolution;\nuniform int iDepthPass;\n\nattribute vec4 color;\nattribute int id;\n\nflat varying int vId;\nvarying vec3 vLightDir;\nvarying vec3 vNormal;\nvarying vec4 vColor;\nvarying vec2 vUv;\n\nmat4 getLightProjection() {\n  float left = -2.0;\n  float right = 2.0;\n  float top = 2.0;\n  float bottom = -2.0;\n  float far = 8.0;\n  float near = 0.1;\n\n  mat4 lightProjection; \n  return lightProjection;\n}\n\nvoid main() {\n  \n  vec3 lightDir = normalize(vec3(-0.5, -0.8, 0.0));\n  vec3 lightPos = vec3(1.5, 2.4, 0.0);\n\n  mat4 lightView = viewMatrix;\n  \n  gl_Position = projectionMatrix * lightView * modelMatrix * vec4(position, 1.0);\n\n  vId = id;\n  vLightDir = lightDir;\n  vNormal = mat3(modelMatrix) * normal;\n  vColor = color;\n  vUv = uv;\n}\n",
                                "defaultFragmentShader": "uniform sampler2D iDepthBuffer;\nuniform int iDepthPass;\n\nflat varying int vId;\nvarying vec3 vLightDir;\nvarying vec3 vNormal;\nvarying vec4 vColor;\nvarying vec2 vUv;\n\nvoid main() {\n  float ambient = 0.2;  \n  float diffuse = dot(normalize(vNormal), normalize(-vLightDir));\n  \n  gl_FragColor = vec4((ambient + diffuse) * vColor.rgb, 1.0);\n}",
                                "vertexCodeEditable": true,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":0,\"y\":0.75,\"z\":3.5},\"rotation\":{\"x\":-0.4,\"y\":0,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":45,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":-1,\"z\":0},\"rotation\":{\"x\":-1.57,\"y\":0,\"z\":0},\"scale\":{\"x\":8,\"y\":8,\"z\":1},\"geometry\":1,\"colorRGBA\":\"4080A0\",\"color\":4227232},{\"position\":{\"x\":0,\"y\":-0.25,\"z\":0},\"rotation\":{\"x\":0,\"y\":0.5,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":\"2\",\"colorRGBA\":\"008080\",\"color\":32896},{\"position\":{\"x\":-0.5,\"y\":0,\"z\":2.4},\"rotation\":{\"x\":-0.4,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":0.5,\"z\":1},\"geometry\":1,\"colorRGBA\":\"000000\",\"color\":0}],\"backgroundRGBA\":\"EEEEEE\",\"background\":15658734}",
                                "description": "A **render pass** refers to a separate rendering stages that captures specific information about a scene. Instead of rendering the entire scene in one step, we break it down into individual passes, each targeting a specific aspect (such as depth, color and etc). The result of these passes are full-screen textures that we can feed into the shader programs of the following passes to create effects like shadows.\n\n<br>\n\nWhen it comes to shadows, we typically use two render passes:\n1. **Shadow Pass**. This pass specifically renders the scene from the perspective of the light source. It collects information about the depth (distance) from the light source to each fragment (pixel) of the scene.\n2. **Main pass**. We render the scene from the perspective of the main camera. Using the shadow map, we determine which fragments are affected by shadows and apply appropriate shading during compositing.\n\n### Task\n\nIn our current implementation, we use a single shader program for two render passes. To determine which pass the program is currently executing, we rely on the uniform variable `iDepthPass`. If `iDepthPass` equals `1`, it indicates that the depth pass is being executed:\n\n```\nif (iDepthPass == 1) \n    gl_FragColor = lightSceneDepth;\nelse\n    gl_FragColor = mainSceneColor;\n```\n\nDuring the depth pass, your task is to render the scene depth from the light source point of view using orthogonal projection. In the main pass, you'll have access to the depth buffer via the `iDepthBuffer` texture. \n\n<br>\n\nYou can notice a black plane on the screen with an `vId` of `2`. During the main pass, render the resulting depth texture over this plane.",
                                "hints": [],
                                "restrictions": [],
                                "order": 3,
                                "cost": 5,
                                "threshold": 98,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "uniform vec2 iResolution;\nuniform int iDepthPass;\n\nattribute vec4 color;\nattribute int id;\n\nflat varying int vId;\nvarying vec3 vLightDir;\nvarying vec3 vNormal;\nvarying vec4 vColor;\nvarying vec2 vUv;\n\nmat4 getLightProjection() {\n  float left = -2.0;\n  float right = 2.0;\n  float top = 2.0;\n  float bottom = -2.0;\n  float far = 8.0;\n  float near = 0.1;\n\n  mat4 lightProjection; \n  return lightProjection;\n}\n\nvoid main() {\n  \n  vec3 lightDir = normalize(vec3(-0.5, -0.8, 0.0));\n  vec3 lightPos = vec3(1.5, 2.4, 0.0);\n\n  mat4 lightView = viewMatrix;\n  \n  gl_Position = projectionMatrix * lightView * modelMatrix * vec4(position, 1.0);\n\n  vId = id;\n  vLightDir = lightDir;\n  vNormal = mat3(modelMatrix) * normal;\n  vColor = color;\n  vUv = uv;\n}\n",
                            "fragmentShader": "uniform sampler2D iDepthBuffer;\nuniform int iDepthPass;\n\nflat varying int vId;\nvarying vec3 vLightDir;\nvarying vec3 vNormal;\nvarying vec4 vColor;\nvarying vec2 vUv;\n\nvoid main() {\n  float ambient = 0.2;  \n  float diffuse = dot(normalize(vNormal), normalize(-vLightDir));\n  \n  gl_FragColor = vec4((ambient + diffuse) * vColor.rgb, 1.0);\n}",
                            "defaultVertexShader": "uniform vec2 iResolution;\nuniform int iDepthPass;\n\nattribute vec4 color;\nattribute int id;\n\nflat varying int vId;\nvarying vec3 vLightDir;\nvarying vec3 vNormal;\nvarying vec4 vColor;\nvarying vec2 vUv;\n\nmat4 getLightProjection() {\n  float left = -2.0;\n  float right = 2.0;\n  float top = 2.0;\n  float bottom = -2.0;\n  float far = 8.0;\n  float near = 0.1;\n\n  mat4 lightProjection; \n  return lightProjection;\n}\n\nvoid main() {\n  \n  vec3 lightDir = normalize(vec3(-0.5, -0.8, 0.0));\n  vec3 lightPos = vec3(1.5, 2.4, 0.0);\n\n  mat4 lightView = viewMatrix;\n  \n  gl_Position = projectionMatrix * lightView * modelMatrix * vec4(position, 1.0);\n\n  vId = id;\n  vLightDir = lightDir;\n  vNormal = mat3(modelMatrix) * normal;\n  vColor = color;\n  vUv = uv;\n}\n",
                            "defaultFragmentShader": "uniform sampler2D iDepthBuffer;\nuniform int iDepthPass;\n\nflat varying int vId;\nvarying vec3 vLightDir;\nvarying vec3 vNormal;\nvarying vec4 vColor;\nvarying vec2 vUv;\n\nvoid main() {\n  float ambient = 0.2;  \n  float diffuse = dot(normalize(vNormal), normalize(-vLightDir));\n  \n  gl_FragColor = vec4((ambient + diffuse) * vColor.rgb, 1.0);\n}",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 168,
                        "slug": "shadow-map-shadow",
                        "moduleId": 12,
                        "name": "Shadow Map - Shadow",
                        "order": 4,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": true,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 168,
                                "slug": "shadow-map-shadow",
                                "moduleId": 12,
                                "name": "Shadow Map - Shadow",
                                "vertexShader": "uniform vec2 iResolution;\nuniform int iDepthPass;\n\nattribute vec4 color;\n\nvarying vec3 vLightDir;\nvarying vec3 vNormal;\nvarying vec4 vColor;\nvarying vec4 vPos;\nvarying vec4 vPosLight;\n\nmat4 getLightProjection() {\n  float ratio = iResolution.x / iResolution.y;\n  float size = 4.0;\n  float left = -size * ratio;\n  float right = size * ratio;\n  float top = size;\n  float bottom = -size;\n  float far = 8.0;\n  float near = 0.1;\n  \n  mat4 lightProjection;\n  \n  lightProjection[0][0] = 2.0 / (right - left);\n  lightProjection[1][0] = 0.0;\n  lightProjection[2][0] = 0.0;\n  lightProjection[3][0] = -(right + left) / (right - left);\n\n  lightProjection[0][1] = 0.0;\n  lightProjection[1][1] = 2.0 / (top - bottom);\n  lightProjection[2][1] = 0.0;\n  lightProjection[3][1] = -(top + bottom) / (top - bottom);\n\n  lightProjection[0][2] = 0.0;\n  lightProjection[1][2] = 0.0;\n  lightProjection[2][2] = -2.0 / (far - near);\n  lightProjection[3][2] = -(far + near) / (far - near);\n\n  lightProjection[0][3] = 0.0;\n  lightProjection[1][3] = 0.0;\n  lightProjection[2][3] = 0.0;\n  lightProjection[3][3] = 1.0;\n\n  return lightProjection;\n}\n\nvoid main() {\n  vec3 lightDir = normalize(vec3(-0.5, -0.8, 0.0));\n  vec3 lightPos = vec3(1.5, 2.4, 0.0);\n\n  vec3 front = -lightDir;\n  vec3 up = vec3(0.0, 1.0, 0.0);\n  vec3 right = normalize(cross(up, front));\n  vec3 fixedUp = normalize(cross(front, right));\n\n  // column major\n  mat4 lightView;\n  \n  // row 0 = dot(right, vertex_pos)\n  lightView[0][0] = right.x;\n  lightView[1][0] = right.y;\n  lightView[2][0] = right.z;\n  lightView[3][0] = -dot(lightPos, right);\n\n  // row 1 = dot(fixedUp, vertex_pos)\n  lightView[0][1] = fixedUp.x;\n  lightView[1][1] = fixedUp.y;\n  lightView[2][1] = fixedUp.z;\n  lightView[3][1] = -dot(lightPos, fixedUp);\n\n  // row 2 = dot(-front, vertex_pos)\n  lightView[0][2] = front.x;\n  lightView[1][2] = front.y;\n  lightView[2][2] = front.z;\n  lightView[3][2] = -dot(lightPos, front);\n\n  //row 3\n  lightView[0][3] = 0.0;\n  lightView[1][3] = 0.0;\n  lightView[2][3] = 0.0;\n  lightView[3][3] = 1.0;\n\n  mat4 lightProjView = getLightProjection() * lightView;\n  mat4 cameraProjView = projectionMatrix * viewMatrix;\n  mat4 projView = (iDepthPass == 1) ? lightProjView : cameraProjView;\n\n  vec4 worldPos = modelMatrix * vec4(position, 1.0);\n  vec4 pos = projView * worldPos;\n  gl_Position = pos;\n\n  vLightDir = lightDir;\n  vNormal = mat3(modelMatrix) * normal;\n  vColor = color;\n  vPos = pos;\n  vPosLight = lightProjView * worldPos;\n}\n",
                                "fragmentShader": "uniform sampler2D iDepthBuffer;\nuniform int iDepthPass;\n\nvarying vec3 vLightDir;\nvarying vec3 vNormal;\nvarying vec4 vColor;\nvarying vec4 vPos;\nvarying vec4 vPosLight;\n\nvoid main() {\n  if (iDepthPass == 1) {\n  \n    float depth = vPos.z * 0.5 + 0.5;\n    gl_FragColor = vec4(depth, depth, depth, 1.0);\n  \n  } else {\n\n    vec3 lightCoords = vPosLight.xyz * 0.5 + 0.5;\n    float bufferDepth = texture(iDepthBuffer, lightCoords.xy).r;\n    float fragDepth = lightCoords.z;\n    float shadow = fragDepth > bufferDepth ? 1.0 : 0.0;\n    \n    float ambient = 0.2;  \n    float diffuse = dot(normalize(vNormal), normalize(-vLightDir));\n    vec3  color = (ambient + (1.0 - shadow) * diffuse) * vColor.rgb;\n    \n    gl_FragColor = vec4(color, 1.0);\n  }\n}",
                                "defaultVertexShader": "uniform vec2 iResolution;\nuniform int iDepthPass;\n\nattribute vec4 color;\n\nvarying vec3 vLightDir;\nvarying vec3 vNormal;\nvarying vec4 vColor;\n\nmat4 getLightProjection() {\n  float left = -4.0;\n  float right = 4.0;\n  float top = 4.0;\n  float bottom = -4.0;\n  float far = 8.0;\n  float near = 0.1;\n\n  mat4 lightProjection; \n  return lightProjection;\n}\n\nvoid main() {\n  \n  vec3 lightDir = normalize(vec3(-0.5, -0.8, 0.0));\n  vec3 lightPos = vec3(1.5, 2.4, 0.0);\n\n  mat4 lightView = viewMatrix;\n  \n  gl_Position = projectionMatrix * lightView * modelMatrix * vec4(position, 1.0);\n\n  vLightDir = lightDir;\n  vNormal = mat3(modelMatrix) * normal;\n  vColor = color;\n}\n",
                                "defaultFragmentShader": "uniform sampler2D iDepthBuffer;\nuniform int iDepthPass;\n\nvarying vec3 vLightDir;\nvarying vec3 vNormal;\nvarying vec4 vColor;\n\nvoid main() {\n  float ambient = 0.2;  \n  float diffuse = dot(normalize(vNormal), normalize(-vLightDir));\n  \n  gl_FragColor = vec4((ambient + diffuse) * vColor.rgb, 1.0);\n}",
                                "vertexCodeEditable": true,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":0,\"y\":0.75,\"z\":3.5},\"rotation\":{\"x\":-0.4,\"y\":0,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":45,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":-1,\"z\":0},\"rotation\":{\"x\":-1.57,\"y\":0,\"z\":0},\"scale\":{\"x\":8,\"y\":8,\"z\":1},\"geometry\":1,\"colorRGBA\":\"4080A0\",\"color\":4227232},{\"position\":{\"x\":0,\"y\":-0.25,\"z\":0},\"rotation\":{\"x\":0,\"y\":0.5,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":\"2\",\"colorRGBA\":\"008080\",\"color\":32896}],\"backgroundRGBA\":\"EEEEEE\",\"background\":15658734}",
                                "description": "Once we have built the shadow map, we render the scene as normal from the perspective of the main camera. For each fragment **P** rendered, we also compute its depth from the light source, denoted by **Light(P)**. \n\n<br>\n\n![](/files/shadow-map-shadow.png)\n\n<br>\n\nAdditionally, using the projected coordinates of the fragment **P** from the light point of view, we sample the shadow map along the line of sight from the light source to pixel **P**. This allows us to obtain the depth value **Light(P0)** stored in the shadow map. **Light(P0)** represents the depth of the pixel closest to the light along the line of sight from the light’s position to **P**.\n\n<br>\n\n![](/files/shadow-map-light-projection-plane.png)\n\n<br>\n\nWe determine whether a pixel **P** is in shadow by comparing **Light(P)** and **Light(P0)**. Then, a pixel is in shadow if **Light(P)** **>** **Light(P0)**, and it is not in shadow if **Light(P)** **≤** **Light(P0)**.\n\n### Task\nGenerate a shadow map for the light source using orthogonal projection during the depth pass. When forming the projection matrix, consider the aspect ratio of the screen.\n\n<br>\n\nIn the main pass, draw the scene from the perspective of the main camera. Using the shadow map, determine which fragments are not visible to the light source. If a fragment is in shadow, do not apply diffuse light to it.\n",
                                "hints": [],
                                "restrictions": [],
                                "order": 4,
                                "cost": 5,
                                "threshold": 98,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "uniform vec2 iResolution;\nuniform int iDepthPass;\n\nattribute vec4 color;\n\nvarying vec3 vLightDir;\nvarying vec3 vNormal;\nvarying vec4 vColor;\n\nmat4 getLightProjection() {\n  float left = -4.0;\n  float right = 4.0;\n  float top = 4.0;\n  float bottom = -4.0;\n  float far = 8.0;\n  float near = 0.1;\n\n  mat4 lightProjection; \n  return lightProjection;\n}\n\nvoid main() {\n  \n  vec3 lightDir = normalize(vec3(-0.5, -0.8, 0.0));\n  vec3 lightPos = vec3(1.5, 2.4, 0.0);\n\n  mat4 lightView = viewMatrix;\n  \n  gl_Position = projectionMatrix * lightView * modelMatrix * vec4(position, 1.0);\n\n  vLightDir = lightDir;\n  vNormal = mat3(modelMatrix) * normal;\n  vColor = color;\n}\n",
                            "fragmentShader": "uniform sampler2D iDepthBuffer;\nuniform int iDepthPass;\n\nvarying vec3 vLightDir;\nvarying vec3 vNormal;\nvarying vec4 vColor;\n\nvoid main() {\n  float ambient = 0.2;  \n  float diffuse = dot(normalize(vNormal), normalize(-vLightDir));\n  \n  gl_FragColor = vec4((ambient + diffuse) * vColor.rgb, 1.0);\n}",
                            "defaultVertexShader": "uniform vec2 iResolution;\nuniform int iDepthPass;\n\nattribute vec4 color;\n\nvarying vec3 vLightDir;\nvarying vec3 vNormal;\nvarying vec4 vColor;\n\nmat4 getLightProjection() {\n  float left = -4.0;\n  float right = 4.0;\n  float top = 4.0;\n  float bottom = -4.0;\n  float far = 8.0;\n  float near = 0.1;\n\n  mat4 lightProjection; \n  return lightProjection;\n}\n\nvoid main() {\n  \n  vec3 lightDir = normalize(vec3(-0.5, -0.8, 0.0));\n  vec3 lightPos = vec3(1.5, 2.4, 0.0);\n\n  mat4 lightView = viewMatrix;\n  \n  gl_Position = projectionMatrix * lightView * modelMatrix * vec4(position, 1.0);\n\n  vLightDir = lightDir;\n  vNormal = mat3(modelMatrix) * normal;\n  vColor = color;\n}\n",
                            "defaultFragmentShader": "uniform sampler2D iDepthBuffer;\nuniform int iDepthPass;\n\nvarying vec3 vLightDir;\nvarying vec3 vNormal;\nvarying vec4 vColor;\n\nvoid main() {\n  float ambient = 0.2;  \n  float diffuse = dot(normalize(vNormal), normalize(-vLightDir));\n  \n  gl_FragColor = vec4((ambient + diffuse) * vColor.rgb, 1.0);\n}",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 169,
                        "slug": "shadow-map-bias",
                        "moduleId": 12,
                        "name": "Shadow Map - Bias",
                        "order": 5,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": true,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 169,
                                "slug": "shadow-map-bias",
                                "moduleId": 12,
                                "name": "Shadow Map - Bias",
                                "vertexShader": "uniform vec2 iResolution;\nuniform int iDepthPass;\n\nattribute vec4 color;\n\nvarying vec3 vLightDir;\nvarying vec3 vNormal;\nvarying vec4 vColor;\nvarying vec4 vPos;\nvarying vec4 vPosLight;\n\nmat4 getLightProjection() {\n  float ratio = iResolution.x / iResolution.y;\n  float size = 4.0;\n  float left = -size * ratio;\n  float right = size * ratio;\n  float top = size;\n  float bottom = -size;\n  float far = 8.0;\n  float near = 0.1;\n  \n  mat4 lightProjection;\n  \n  lightProjection[0][0] = 2.0 / (right - left);\n  lightProjection[1][0] = 0.0;\n  lightProjection[2][0] = 0.0;\n  lightProjection[3][0] = -(right + left) / (right - left);\n\n  lightProjection[0][1] = 0.0;\n  lightProjection[1][1] = 2.0 / (top - bottom);\n  lightProjection[2][1] = 0.0;\n  lightProjection[3][1] = -(top + bottom) / (top - bottom);\n\n  lightProjection[0][2] = 0.0;\n  lightProjection[1][2] = 0.0;\n  lightProjection[2][2] = -2.0 / (far - near);\n  lightProjection[3][2] = -(far + near) / (far - near);\n\n  lightProjection[0][3] = 0.0;\n  lightProjection[1][3] = 0.0;\n  lightProjection[2][3] = 0.0;\n  lightProjection[3][3] = 1.0;\n\n  return lightProjection;\n}\n\nvoid main() {\n  vec3 lightDir = normalize(vec3(-0.5, -0.8, 0.0));\n  vec3 lightPos = vec3(1.5, 2.4, 0.0);\n\n  vec3 front = -lightDir;\n  vec3 up = vec3(0.0, 1.0, 0.0);\n  vec3 right = normalize(cross(up, front));\n  vec3 fixedUp = normalize(cross(front, right));\n\n  // column major\n  mat4 lightView;\n  \n  // row 0 = dot(right, vertex_pos)\n  lightView[0][0] = right.x;\n  lightView[1][0] = right.y;\n  lightView[2][0] = right.z;\n  lightView[3][0] = -dot(lightPos, right);\n\n  // row 1 = dot(fixedUp, vertex_pos)\n  lightView[0][1] = fixedUp.x;\n  lightView[1][1] = fixedUp.y;\n  lightView[2][1] = fixedUp.z;\n  lightView[3][1] = -dot(lightPos, fixedUp);\n\n  // row 2 = dot(-front, vertex_pos)\n  lightView[0][2] = front.x;\n  lightView[1][2] = front.y;\n  lightView[2][2] = front.z;\n  lightView[3][2] = -dot(lightPos, front);\n\n  //row 3\n  lightView[0][3] = 0.0;\n  lightView[1][3] = 0.0;\n  lightView[2][3] = 0.0;\n  lightView[3][3] = 1.0;\n\n  mat4 lightProjView = getLightProjection() * lightView;\n  mat4 cameraProjView = projectionMatrix * viewMatrix;\n  mat4 projView = (iDepthPass == 1) ? lightProjView : cameraProjView;\n\n  vec4 worldPos = modelMatrix * vec4(position, 1.0);\n  vec4 pos = projView * worldPos;\n  gl_Position = pos;\n\n  vLightDir = lightDir;\n  vNormal = mat3(modelMatrix) * normal;\n  vColor = color;\n  vPos = pos;\n  vPosLight = lightProjView * worldPos;\n}\n",
                                "fragmentShader": "uniform sampler2D iDepthBuffer;\nuniform int iDepthPass;\n\nvarying vec3 vLightDir;\nvarying vec3 vNormal;\nvarying vec4 vColor;\nvarying vec4 vPos;\nvarying vec4 vPosLight;\n\nvoid main() {\n  if (iDepthPass == 1) {\n  \n    float depth = vPos.z * 0.5 + 0.5;\n    gl_FragColor = vec4(depth, depth, depth, 1.0);\n  \n  } else {\n\n    float bias = max(0.1 * (1.0 - dot(vNormal, normalize(-vLightDir))), 0.0);\n\n    vec3 lightCoords = vPosLight.xyz * 0.5 + 0.5;\n    float bufferDepth = texture(iDepthBuffer, lightCoords.xy).r;\n    float fragDepth = lightCoords.z;\n    float shadow = fragDepth - bias > bufferDepth ? 1.0 : 0.0;\n    \n    float ambient = 0.2;  \n    float diffuse = dot(normalize(vNormal), normalize(-vLightDir));\n    vec3  color = (ambient + (1.0 - shadow) * diffuse) * vColor.rgb;\n    \n    gl_FragColor = vec4(color, 1.0);\n  }\n}",
                                "defaultVertexShader": "uniform vec2 iResolution;\nuniform int iDepthPass;\n\nattribute vec4 color;\n\nvarying vec3 vLightDir;\nvarying vec3 vNormal;\nvarying vec4 vColor;\n\nmat4 getLightProjection() {\n  float left = -4.0;\n  float right = 4.0;\n  float top = 4.0;\n  float bottom = -4.0;\n  float far = 8.0;\n  float near = 0.1;\n\n  mat4 lightProjection; \n  return lightProjection;\n}\n\nvoid main() {\n  \n  vec3 lightDir = normalize(vec3(-0.5, -0.8, 0.0));\n  vec3 lightPos = vec3(1.5, 2.4, 0.0);\n\n  mat4 lightView = viewMatrix;\n  \n  gl_Position = projectionMatrix * lightView * modelMatrix * vec4(position, 1.0);\n\n  vLightDir = lightDir;\n  vNormal = mat3(modelMatrix) * normal;\n  vColor = color;\n}\n",
                                "defaultFragmentShader": "uniform sampler2D iDepthBuffer;\nuniform int iDepthPass;\n\nvarying vec3 vLightDir;\nvarying vec3 vNormal;\nvarying vec4 vColor;\n\nvoid main() {\n  float ambient = 0.2;  \n  float diffuse = dot(normalize(vNormal), normalize(-vLightDir));\n  \n  gl_FragColor = vec4((ambient + diffuse) * vColor.rgb, 1.0);\n}",
                                "vertexCodeEditable": true,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":0,\"y\":0.75,\"z\":3.5},\"rotation\":{\"x\":-0.4,\"y\":0,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":45,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":-1,\"z\":0},\"rotation\":{\"x\":-1.57,\"y\":0,\"z\":0},\"scale\":{\"x\":8,\"y\":8,\"z\":1},\"geometry\":1,\"colorRGBA\":\"4080A0\",\"color\":4227232},{\"position\":{\"x\":0,\"y\":-0.25,\"z\":0},\"rotation\":{\"x\":0,\"y\":0.5,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":\"2\",\"colorRGBA\":\"008080\",\"color\":32896}],\"backgroundRGBA\":\"EEEEEE\",\"background\":15658734}",
                                "description": "Unfortunately, the shadow map has a finite resolution and represents a discrete sampling of the scene’s depth from the light’s perspective. As a result, the texels in the shadow map may correspond to an area of the main scene. This leads to issues with aliasing, known as shadow acne.\n\n<br>\n\nLet’s consider a situation where there are no overlapping objects, only a flat surface and a single light source. In other words, there should be no shadows in the scene.\n\n<br>\n\n![](/files/shadow-map-bias-depth-area.png)\n\n<br>\n\nFragments **P0** and **P1** in the scene correspond to the same texel in the shadow map **depth1**. When determining the shading for fragment **P1**, we find that its computed depth value is greater than the depth value stored in the shadow map **depth1**. Consequently, we mistakenly decide that fragment **P1** should be shadowed.\n\n<br>\n\nTo solve this issue, we can apply a small depth **bias** value. There is no universally accepted bias value, and it needs to be adjusted for each scene individually.\n\n<br>\n\n![](/files/shadow-map-bias-naive.png)\n\n<br>\n\nAdditionally, we can notice that self-shadowing issues do not arise when the light falls directly perpendicular to the surface. \n\n<br>\n\n![](/files/shadow-map-bias-no-angle.png)\n\n<br>\n\nThe problem becomes more pronounced as angle moves from this ideal case.\n\n<br>\n\n![](/files/shadow-map-bias-angle-vary.png)\n\n<br>\n\nSo we can vary the bias value using the angle between the surface normal and the light direction.\n\n### Task\n\nYour program from the previous task uses a shadow map to determine whether a fragment is in shadow or not. However, you can notice some self-shadowing artifacts (shadow acne).\n\n<br>\n\nYour task is to introduce a bias adjustment in the shading pipeline. The bias value should vary based on the angle between the surface normal and the light direction from `0.0` to `0.1`;",
                                "hints": [],
                                "restrictions": [],
                                "order": 5,
                                "cost": 5,
                                "threshold": 98,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "uniform vec2 iResolution;\nuniform int iDepthPass;\n\nattribute vec4 color;\n\nvarying vec3 vLightDir;\nvarying vec3 vNormal;\nvarying vec4 vColor;\n\nmat4 getLightProjection() {\n  float left = -4.0;\n  float right = 4.0;\n  float top = 4.0;\n  float bottom = -4.0;\n  float far = 8.0;\n  float near = 0.1;\n\n  mat4 lightProjection; \n  return lightProjection;\n}\n\nvoid main() {\n  \n  vec3 lightDir = normalize(vec3(-0.5, -0.8, 0.0));\n  vec3 lightPos = vec3(1.5, 2.4, 0.0);\n\n  mat4 lightView = viewMatrix;\n  \n  gl_Position = projectionMatrix * lightView * modelMatrix * vec4(position, 1.0);\n\n  vLightDir = lightDir;\n  vNormal = mat3(modelMatrix) * normal;\n  vColor = color;\n}\n",
                            "fragmentShader": "uniform sampler2D iDepthBuffer;\nuniform int iDepthPass;\n\nvarying vec3 vLightDir;\nvarying vec3 vNormal;\nvarying vec4 vColor;\n\nvoid main() {\n  float ambient = 0.2;  \n  float diffuse = dot(normalize(vNormal), normalize(-vLightDir));\n  \n  gl_FragColor = vec4((ambient + diffuse) * vColor.rgb, 1.0);\n}",
                            "defaultVertexShader": "uniform vec2 iResolution;\nuniform int iDepthPass;\n\nattribute vec4 color;\n\nvarying vec3 vLightDir;\nvarying vec3 vNormal;\nvarying vec4 vColor;\n\nmat4 getLightProjection() {\n  float left = -4.0;\n  float right = 4.0;\n  float top = 4.0;\n  float bottom = -4.0;\n  float far = 8.0;\n  float near = 0.1;\n\n  mat4 lightProjection; \n  return lightProjection;\n}\n\nvoid main() {\n  \n  vec3 lightDir = normalize(vec3(-0.5, -0.8, 0.0));\n  vec3 lightPos = vec3(1.5, 2.4, 0.0);\n\n  mat4 lightView = viewMatrix;\n  \n  gl_Position = projectionMatrix * lightView * modelMatrix * vec4(position, 1.0);\n\n  vLightDir = lightDir;\n  vNormal = mat3(modelMatrix) * normal;\n  vColor = color;\n}\n",
                            "defaultFragmentShader": "uniform sampler2D iDepthBuffer;\nuniform int iDepthPass;\n\nvarying vec3 vLightDir;\nvarying vec3 vNormal;\nvarying vec4 vColor;\n\nvoid main() {\n  float ambient = 0.2;  \n  float diffuse = dot(normalize(vNormal), normalize(-vLightDir));\n  \n  gl_FragColor = vec4((ambient + diffuse) * vColor.rgb, 1.0);\n}",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 170,
                        "slug": "shadow-map-pcf",
                        "moduleId": 12,
                        "name": "Shadow Map - PCF",
                        "order": 6,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": true,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 170,
                                "slug": "shadow-map-pcf",
                                "moduleId": 12,
                                "name": "Shadow Map - PCF",
                                "vertexShader": "uniform vec2 iResolution;\nuniform int iDepthPass;\n\nattribute vec4 color;\n\nvarying vec3 vLightDir;\nvarying vec3 vNormal;\nvarying vec4 vColor;\nvarying vec4 vPos;\nvarying vec4 vPosLight;\n\nmat4 getLightProjection() {\n  float ratio = iResolution.x / iResolution.y;\n  float size = 4.0;\n  float left = -size * ratio;\n  float right = size * ratio;\n  float top = size;\n  float bottom = -size;\n  float far = 8.0;\n  float near = 0.1;\n  \n  mat4 lightProjection;\n  \n  lightProjection[0][0] = 2.0 / (right - left);\n  lightProjection[1][0] = 0.0;\n  lightProjection[2][0] = 0.0;\n  lightProjection[3][0] = -(right + left) / (right - left);\n\n  lightProjection[0][1] = 0.0;\n  lightProjection[1][1] = 2.0 / (top - bottom);\n  lightProjection[2][1] = 0.0;\n  lightProjection[3][1] = -(top + bottom) / (top - bottom);\n\n  lightProjection[0][2] = 0.0;\n  lightProjection[1][2] = 0.0;\n  lightProjection[2][2] = -2.0 / (far - near);\n  lightProjection[3][2] = -(far + near) / (far - near);\n\n  lightProjection[0][3] = 0.0;\n  lightProjection[1][3] = 0.0;\n  lightProjection[2][3] = 0.0;\n  lightProjection[3][3] = 1.0;\n\n  return lightProjection;\n}\n\nvoid main() {\n  vec3 lightDir = normalize(vec3(-0.5, -0.8, 0.0));\n  vec3 lightPos = vec3(1.5, 2.4, 0.0);\n\n  vec3 front = -lightDir;\n  vec3 up = vec3(0.0, 1.0, 0.0);\n  vec3 right = normalize(cross(up, front));\n  vec3 fixedUp = normalize(cross(front, right));\n\n  // column major\n  mat4 lightView;\n  \n  // row 0 = dot(right, vertex_pos)\n  lightView[0][0] = right.x;\n  lightView[1][0] = right.y;\n  lightView[2][0] = right.z;\n  lightView[3][0] = -dot(lightPos, right);\n\n  // row 1 = dot(fixedUp, vertex_pos)\n  lightView[0][1] = fixedUp.x;\n  lightView[1][1] = fixedUp.y;\n  lightView[2][1] = fixedUp.z;\n  lightView[3][1] = -dot(lightPos, fixedUp);\n\n  // row 2 = dot(-front, vertex_pos)\n  lightView[0][2] = front.x;\n  lightView[1][2] = front.y;\n  lightView[2][2] = front.z;\n  lightView[3][2] = -dot(lightPos, front);\n\n  //row 3\n  lightView[0][3] = 0.0;\n  lightView[1][3] = 0.0;\n  lightView[2][3] = 0.0;\n  lightView[3][3] = 1.0;\n\n  mat4 lightProjView = getLightProjection() * lightView;\n  mat4 cameraProjView = projectionMatrix * viewMatrix;\n  mat4 projView = (iDepthPass == 1) ? lightProjView : cameraProjView;\n\n  vec4 worldPos = modelMatrix * vec4(position, 1.0);\n  vec4 pos = projView * worldPos;\n  gl_Position = pos;\n\n  vLightDir = lightDir;\n  vNormal = mat3(modelMatrix) * normal;\n  vColor = color;\n  vPos = pos;\n  vPosLight = lightProjView * worldPos;\n}\n",
                                "fragmentShader": "uniform sampler2D iDepthBuffer;\nuniform int iDepthPass;\nuniform vec2 iDepthBufferSize;\n\nvarying vec3 vLightDir;\nvarying vec3 vNormal;\nvarying vec4 vColor;\nvarying vec4 vPos;\nvarying vec4 vPosLight;\n\nfloat getShadow() {\n  float bias = max(0.1 * (1.0 - dot(vNormal, normalize(-vLightDir))), 0.01);\n\n  vec3 lightCoords = vPosLight.xyz * 0.5 + 0.5;\n  float bufferDepth = texture(iDepthBuffer, lightCoords.xy).r;\n  float fragDepth = lightCoords.z;\n  \n  vec2 texelSize = 1.0 / iDepthBufferSize;\n\n  float shadow = 0.0;\n  for(int x = -2; x <= 2; ++x) {\n    for(int y = -2; y <= 2; ++y) {\n      vec2 buffCoords = lightCoords.xy + vec2(x, y) * texelSize;\n      float bufferDepth = texture(iDepthBuffer, buffCoords).r;\n      shadow += fragDepth - bias > bufferDepth ? 1.0 : 0.0;\n    }\n  }\n  return shadow / 25.0;\n}\n\nvoid main() {\n  if (iDepthPass == 1) {\n  \n    float depth = vPos.z * 0.5 + 0.5;\n    gl_FragColor = vec4(depth, depth, depth, 1.0);\n  \n  } else {\n    \n    float ambient = 0.2;  \n    float diffuse = dot(normalize(vNormal), normalize(-vLightDir));\n    vec3  color = (ambient + (1.0 - getShadow()) * diffuse) * vColor.rgb;\n    \n    gl_FragColor = vec4(color, 1.0);\n  }\n}",
                                "defaultVertexShader": "uniform vec2 iResolution;\nuniform int iDepthPass;\n\nattribute vec4 color;\n\nvarying vec3 vLightDir;\nvarying vec3 vNormal;\nvarying vec4 vColor;\n\nmat4 getLightProjection() {\n  float left = -4.0;\n  float right = 4.0;\n  float top = 4.0;\n  float bottom = -4.0;\n  float far = 8.0;\n  float near = 0.1;\n\n  mat4 lightProjection; \n  return lightProjection;\n}\n\nvoid main() {\n  \n  vec3 lightDir = normalize(vec3(-0.5, -0.8, 0.0));\n  vec3 lightPos = vec3(1.5, 2.4, 0.0);\n\n  mat4 lightView = viewMatrix;\n  \n  gl_Position = projectionMatrix * lightView * modelMatrix * vec4(position, 1.0);\n\n  vLightDir = lightDir;\n  vNormal = mat3(modelMatrix) * normal;\n  vColor = color;\n}\n",
                                "defaultFragmentShader": "uniform sampler2D iDepthBuffer;\nuniform int iDepthPass;\n\nvarying vec3 vLightDir;\nvarying vec3 vNormal;\nvarying vec4 vColor;\n\nvoid main() {\n  float ambient = 0.2;  \n  float diffuse = dot(normalize(vNormal), normalize(-vLightDir));\n  \n  gl_FragColor = vec4((ambient + diffuse) * vColor.rgb, 1.0);\n}",
                                "vertexCodeEditable": true,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.4,\"y\":-0.4,\"z\":1.5},\"rotation\":{\"x\":-0.4,\"y\":0,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":45,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":-1,\"z\":0},\"rotation\":{\"x\":-1.57,\"y\":0,\"z\":0},\"scale\":{\"x\":8,\"y\":8,\"z\":1},\"geometry\":1,\"colorRGBA\":\"4080A0\",\"color\":4227232},{\"position\":{\"x\":0,\"y\":-0.25,\"z\":0},\"rotation\":{\"x\":0,\"y\":0.5,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":\"2\",\"colorRGBA\":\"008080\",\"color\":32896}],\"backgroundRGBA\":\"EEEEEE\",\"background\":15658734}",
                                "description": "You may have noticed that our shadow appears pixelated with sharp transitions from shadowed to illuminated areas. While applying blurring to the shadow map could smooth out the results, it would alter depth values and potentially introduce errors in fragment shading. Instead, we’ll focus on smoothing the shadow test results themselves, rather than the shadow map.\n\n<br>\n\nRather than directly using the depth value **s** from the shadow map, we will additionally read **n** neighboring depth values **s0...sn** using offset texture coordinates.\n\n<br>\n\n![](/files/shadow-map-pcf.png)\n\n<br>\n\nThen we calculate the average number of samples whose depth is less than the calculated fragment depth **f**:\n\n```\nshadow = ((s < f) + (s0 < f) + ... + (sn < f)) / (n + 1)\n```\n\nThe area around the pixel from which we sample the shadow map is called **PCF window**. The larger this area, the blurrier the result will be.\n\n### Task\n\nYour program from the previous task uses a shadow map to determine whether a fragment is in shadow or not. However, you can notice that our shadow appears pixelated.\n\n<br>\n\nYour task is to add a basic PCF filter to the shadow calculation so that the shadow borders become a bit blurrier. PCF window size is 5x5.",
                                "hints": [],
                                "restrictions": [],
                                "order": 6,
                                "cost": 5,
                                "threshold": 98,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "uniform vec2 iResolution;\nuniform int iDepthPass;\n\nattribute vec4 color;\n\nvarying vec3 vLightDir;\nvarying vec3 vNormal;\nvarying vec4 vColor;\n\nmat4 getLightProjection() {\n  float left = -4.0;\n  float right = 4.0;\n  float top = 4.0;\n  float bottom = -4.0;\n  float far = 8.0;\n  float near = 0.1;\n\n  mat4 lightProjection; \n  return lightProjection;\n}\n\nvoid main() {\n  \n  vec3 lightDir = normalize(vec3(-0.5, -0.8, 0.0));\n  vec3 lightPos = vec3(1.5, 2.4, 0.0);\n\n  mat4 lightView = viewMatrix;\n  \n  gl_Position = projectionMatrix * lightView * modelMatrix * vec4(position, 1.0);\n\n  vLightDir = lightDir;\n  vNormal = mat3(modelMatrix) * normal;\n  vColor = color;\n}\n",
                            "fragmentShader": "uniform sampler2D iDepthBuffer;\nuniform int iDepthPass;\n\nvarying vec3 vLightDir;\nvarying vec3 vNormal;\nvarying vec4 vColor;\n\nvoid main() {\n  float ambient = 0.2;  \n  float diffuse = dot(normalize(vNormal), normalize(-vLightDir));\n  \n  gl_FragColor = vec4((ambient + diffuse) * vColor.rgb, 1.0);\n}",
                            "defaultVertexShader": "uniform vec2 iResolution;\nuniform int iDepthPass;\n\nattribute vec4 color;\n\nvarying vec3 vLightDir;\nvarying vec3 vNormal;\nvarying vec4 vColor;\n\nmat4 getLightProjection() {\n  float left = -4.0;\n  float right = 4.0;\n  float top = 4.0;\n  float bottom = -4.0;\n  float far = 8.0;\n  float near = 0.1;\n\n  mat4 lightProjection; \n  return lightProjection;\n}\n\nvoid main() {\n  \n  vec3 lightDir = normalize(vec3(-0.5, -0.8, 0.0));\n  vec3 lightPos = vec3(1.5, 2.4, 0.0);\n\n  mat4 lightView = viewMatrix;\n  \n  gl_Position = projectionMatrix * lightView * modelMatrix * vec4(position, 1.0);\n\n  vLightDir = lightDir;\n  vNormal = mat3(modelMatrix) * normal;\n  vColor = color;\n}\n",
                            "defaultFragmentShader": "uniform sampler2D iDepthBuffer;\nuniform int iDepthPass;\n\nvarying vec3 vLightDir;\nvarying vec3 vNormal;\nvarying vec4 vColor;\n\nvoid main() {\n  float ambient = 0.2;  \n  float diffuse = dot(normalize(vNormal), normalize(-vLightDir));\n  \n  gl_FragColor = vec4((ambient + diffuse) * vColor.rgb, 1.0);\n}",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 171,
                        "slug": "shadow-map-random-offset",
                        "moduleId": 12,
                        "name": "Shadow Map - Random Offset",
                        "order": 7,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": true,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 171,
                                "slug": "shadow-map-random-offset",
                                "moduleId": 12,
                                "name": "Shadow Map - Random Offset",
                                "vertexShader": "uniform vec2 iResolution;\nuniform int iDepthPass;\n\nattribute vec4 color;\n\nvarying vec3 vLightDir;\nvarying vec3 vNormal;\nvarying vec4 vColor;\nvarying vec4 vPos;\nvarying vec4 vPosLight;\n\nmat4 getLightProjection() {\n  float ratio = iResolution.x / iResolution.y;\n  float size = 4.0;\n  float left = -size * ratio;\n  float right = size * ratio;\n  float top = size;\n  float bottom = -size;\n  float far = 8.0;\n  float near = 0.1;\n  \n  mat4 lightProjection;\n  \n  lightProjection[0][0] = 2.0 / (right - left);\n  lightProjection[1][0] = 0.0;\n  lightProjection[2][0] = 0.0;\n  lightProjection[3][0] = -(right + left) / (right - left);\n\n  lightProjection[0][1] = 0.0;\n  lightProjection[1][1] = 2.0 / (top - bottom);\n  lightProjection[2][1] = 0.0;\n  lightProjection[3][1] = -(top + bottom) / (top - bottom);\n\n  lightProjection[0][2] = 0.0;\n  lightProjection[1][2] = 0.0;\n  lightProjection[2][2] = -2.0 / (far - near);\n  lightProjection[3][2] = -(far + near) / (far - near);\n\n  lightProjection[0][3] = 0.0;\n  lightProjection[1][3] = 0.0;\n  lightProjection[2][3] = 0.0;\n  lightProjection[3][3] = 1.0;\n\n  return lightProjection;\n}\n\nvoid main() {\n  vec3 lightDir = normalize(vec3(-0.5, -0.8, 0.0));\n  vec3 lightPos = vec3(1.5, 2.4, 0.0);\n\n  vec3 front = -lightDir;\n  vec3 up = vec3(0.0, 1.0, 0.0);\n  vec3 right = normalize(cross(up, front));\n  vec3 fixedUp = normalize(cross(front, right));\n\n  // column major\n  mat4 lightView;\n  \n  // row 0 = dot(right, vertex_pos)\n  lightView[0][0] = right.x;\n  lightView[1][0] = right.y;\n  lightView[2][0] = right.z;\n  lightView[3][0] = -dot(lightPos, right);\n\n  // row 1 = dot(fixedUp, vertex_pos)\n  lightView[0][1] = fixedUp.x;\n  lightView[1][1] = fixedUp.y;\n  lightView[2][1] = fixedUp.z;\n  lightView[3][1] = -dot(lightPos, fixedUp);\n\n  // row 2 = dot(-front, vertex_pos)\n  lightView[0][2] = front.x;\n  lightView[1][2] = front.y;\n  lightView[2][2] = front.z;\n  lightView[3][2] = -dot(lightPos, front);\n\n  //row 3\n  lightView[0][3] = 0.0;\n  lightView[1][3] = 0.0;\n  lightView[2][3] = 0.0;\n  lightView[3][3] = 1.0;\n\n  mat4 lightProjView = getLightProjection() * lightView;\n  mat4 cameraProjView = projectionMatrix * viewMatrix;\n  mat4 projView = (iDepthPass == 1) ? lightProjView : cameraProjView;\n\n  vec4 worldPos = modelMatrix * vec4(position, 1.0);\n  vec4 pos = projView * worldPos;\n  gl_Position = pos;\n\n  vLightDir = lightDir;\n  vNormal = mat3(modelMatrix) * normal;\n  vColor = color;\n  vPos = pos;\n  vPosLight = lightProjView * worldPos;\n}\n",
                                "fragmentShader": "uniform sampler2D iDepthBuffer;\nuniform int iDepthPass;\nuniform vec2 iDepthBufferSize;\n\nvarying vec3 vLightDir;\nvarying vec3 vNormal;\nvarying vec4 vColor;\nvarying vec4 vPos;\nvarying vec4 vPosLight;\n\nfloat random(vec2 point) {\n  const float SEED = 1234.5678;\n  float d = dot(point, vec2(SEED, SEED));\n  float r = fract(sin(d) * SEED);\n  r = r * 2.0 - 1.0; \n  return r;\n}\n\nfloat getShadow() {\n  float bias = max(0.1 * (1.0 - dot(vNormal, normalize(-vLightDir))), 0.01);\n\n  vec3 lightCoords = vPosLight.xyz * 0.5 + 0.5;\n  float fragDepth = lightCoords.z;\n  \n  vec2 texelSize = 1.0 / iDepthBufferSize;\n\n  float shadow = 0.0;\n  for(int x = -2; x <= 2; ++x) {\n    for(int y = -2; y <= 2; ++y) {\n      vec2 buffCoords = lightCoords.xy + vec2(x, y) * texelSize;\n      buffCoords += random(buffCoords) * texelSize * 0.5;\n      float bufferDepth = texture(iDepthBuffer, buffCoords).r;\n      shadow += fragDepth - bias > bufferDepth ? 1.0 : 0.0;\n    }\n  }\n  return shadow / 25.0;\n}\n\nvoid main() {\n  if (iDepthPass == 1) {\n  \n    float depth = vPos.z * 0.5 + 0.5;\n    gl_FragColor = vec4(depth, depth, depth, 1.0);\n  \n  } else {\n    \n    float ambient = 0.2;  \n    float diffuse = dot(normalize(vNormal), normalize(-vLightDir));\n    vec3  color = (ambient + (1.0 - getShadow()) * diffuse) * vColor.rgb;\n    \n    gl_FragColor = vec4(color, 1.0);\n  }\n}",
                                "defaultVertexShader": "uniform vec2 iResolution;\nuniform int iDepthPass;\n\nattribute vec4 color;\n\nvarying vec3 vLightDir;\nvarying vec3 vNormal;\nvarying vec4 vColor;\n\nmat4 getLightProjection() {\n  float left = -4.0;\n  float right = 4.0;\n  float top = 4.0;\n  float bottom = -4.0;\n  float far = 8.0;\n  float near = 0.1;\n\n  mat4 lightProjection; \n  return lightProjection;\n}\n\nvoid main() {\n  \n  vec3 lightDir = normalize(vec3(-0.5, -0.8, 0.0));\n  vec3 lightPos = vec3(1.5, 2.4, 0.0);\n\n  mat4 lightView = viewMatrix;\n  \n  gl_Position = projectionMatrix * lightView * modelMatrix * vec4(position, 1.0);\n\n  vLightDir = lightDir;\n  vNormal = mat3(modelMatrix) * normal;\n  vColor = color;\n}\n",
                                "defaultFragmentShader": "uniform sampler2D iDepthBuffer;\nuniform int iDepthPass;\n\nvarying vec3 vLightDir;\nvarying vec3 vNormal;\nvarying vec4 vColor;\n\nfloat random(vec2 point) {\n  const float SEED = 1234.5678;\n  float d = dot(point, vec2(SEED, SEED));\n  float r = fract(sin(d) * SEED);\n  r = r * 2.0 - 1.0; \n  return r;\n}\n\nvoid main() {\n  float ambient = 0.2;  \n  float diffuse = dot(normalize(vNormal), normalize(-vLightDir));\n  \n  gl_FragColor = vec4((ambient + diffuse) * vColor.rgb, 1.0);\n}",
                                "vertexCodeEditable": true,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.4,\"y\":-0.4,\"z\":1.5},\"rotation\":{\"x\":-0.4,\"y\":0,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":45,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":-1,\"z\":0},\"rotation\":{\"x\":-1.57,\"y\":0,\"z\":0},\"scale\":{\"x\":8,\"y\":8,\"z\":1},\"geometry\":1,\"colorRGBA\":\"4080A0\",\"color\":4227232},{\"position\":{\"x\":0,\"y\":-0.25,\"z\":0},\"rotation\":{\"x\":0,\"y\":0.5,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":\"2\",\"colorRGBA\":\"008080\",\"color\":32896}],\"backgroundRGBA\":\"EEEEEE\",\"background\":15658734}",
                                "description": "PCF aims to reduce the blocky appearance of shadows by considering multiple samples within a filter kernel. However, even with a regular grid of samples, aliasing artifacts can still occur due to the discrete nature of the shadow map. To mitigate these artifacts, a common approach is to introduce a small random offset to the sample positions.\n\n<br>\n\n![](/files/shadow-map-randomness.png)\n\n<br>\n\nThis randomness breaks up the regular pattern and helps reduce aliasing without using too many shadow-map samples.\n\n### Task\n\nYour program from the previous task uses a shadow map to determine whether a fragment is in shadow or not. However, you can notice that our shadow still appears blocky.\n\n<br>\n\nYour task is to modify the 5x5 PCF filter to introduce a small random offset `[-texelSize / 2; texelSize / 2]` in the texture coordinates when sampling the shadow map. You should use the given `random` function and the texture coordinates as an argument.",
                                "hints": [],
                                "restrictions": [],
                                "order": 7,
                                "cost": 5,
                                "threshold": 98,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "uniform vec2 iResolution;\nuniform int iDepthPass;\n\nattribute vec4 color;\n\nvarying vec3 vLightDir;\nvarying vec3 vNormal;\nvarying vec4 vColor;\n\nmat4 getLightProjection() {\n  float left = -4.0;\n  float right = 4.0;\n  float top = 4.0;\n  float bottom = -4.0;\n  float far = 8.0;\n  float near = 0.1;\n\n  mat4 lightProjection; \n  return lightProjection;\n}\n\nvoid main() {\n  \n  vec3 lightDir = normalize(vec3(-0.5, -0.8, 0.0));\n  vec3 lightPos = vec3(1.5, 2.4, 0.0);\n\n  mat4 lightView = viewMatrix;\n  \n  gl_Position = projectionMatrix * lightView * modelMatrix * vec4(position, 1.0);\n\n  vLightDir = lightDir;\n  vNormal = mat3(modelMatrix) * normal;\n  vColor = color;\n}\n",
                            "fragmentShader": "uniform sampler2D iDepthBuffer;\nuniform int iDepthPass;\n\nvarying vec3 vLightDir;\nvarying vec3 vNormal;\nvarying vec4 vColor;\n\nfloat random(vec2 point) {\n  const float SEED = 1234.5678;\n  float d = dot(point, vec2(SEED, SEED));\n  float r = fract(sin(d) * SEED);\n  r = r * 2.0 - 1.0; \n  return r;\n}\n\nvoid main() {\n  float ambient = 0.2;  \n  float diffuse = dot(normalize(vNormal), normalize(-vLightDir));\n  \n  gl_FragColor = vec4((ambient + diffuse) * vColor.rgb, 1.0);\n}",
                            "defaultVertexShader": "uniform vec2 iResolution;\nuniform int iDepthPass;\n\nattribute vec4 color;\n\nvarying vec3 vLightDir;\nvarying vec3 vNormal;\nvarying vec4 vColor;\n\nmat4 getLightProjection() {\n  float left = -4.0;\n  float right = 4.0;\n  float top = 4.0;\n  float bottom = -4.0;\n  float far = 8.0;\n  float near = 0.1;\n\n  mat4 lightProjection; \n  return lightProjection;\n}\n\nvoid main() {\n  \n  vec3 lightDir = normalize(vec3(-0.5, -0.8, 0.0));\n  vec3 lightPos = vec3(1.5, 2.4, 0.0);\n\n  mat4 lightView = viewMatrix;\n  \n  gl_Position = projectionMatrix * lightView * modelMatrix * vec4(position, 1.0);\n\n  vLightDir = lightDir;\n  vNormal = mat3(modelMatrix) * normal;\n  vColor = color;\n}\n",
                            "defaultFragmentShader": "uniform sampler2D iDepthBuffer;\nuniform int iDepthPass;\n\nvarying vec3 vLightDir;\nvarying vec3 vNormal;\nvarying vec4 vColor;\n\nfloat random(vec2 point) {\n  const float SEED = 1234.5678;\n  float d = dot(point, vec2(SEED, SEED));\n  float r = fract(sin(d) * SEED);\n  r = r * 2.0 - 1.0; \n  return r;\n}\n\nvoid main() {\n  float ambient = 0.2;  \n  float diffuse = dot(normalize(vNormal), normalize(-vLightDir));\n  \n  gl_FragColor = vec4((ambient + diffuse) * vColor.rgb, 1.0);\n}",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    }
                ],
                "cover": true,
                "pageHeaderImage": true,
                "fullDesc": "This module is designed for developers who want to master the art of shadow creation in computer graphics. You will learn how to create and use shadow maps to generate realistic shadows, and explore supporting techniques to enhance shadow quality. Each topic includes theoretical material and a practical task that can be completed directly on the website.",
                "skillsDesc": "how to construct view and projection matrices for accurate 3D rendering.<br>what a render pass is and how it is used in the graphics pipeline.<br>how to create shadow maps and use them to generate shadows  in 3D scenes.<br>the role of the depth buffer in managing object visibility based on distance.<br>algorithms for improving shadow quality, such as bias, PCF (Percentage Closer Filtering), dithering, and depth buffer techniques.",
                "importanceDesc": "Creating realistic shadows is crucial for adding depth and realism to 3D scenes. Understanding how to generate and optimize shadows allows developers to create scenes with accurate light and shadow distribution, making objects appear more three-dimensional and lifelike. ",
                "certifiable": false,
                "images": [
                    "img-1.png",
                    "img-2.png",
                    "img-3.png"
                ]
            }
        },
        {
            "id": 3,
            "slug": "signed-distance-field",
            "name": "Signed Distance Field",
            "description": "Study the distance functions for rendering smooth and detailed shapes, plus the formulas for combining them together for building more complex shapes.",
            "tasks": 16,
            "acceptedTasks": 0,
            "isOpen": false,
            "order": 5,
            "locked": false,
            "cover": true,
            "child": {
                "id": 3,
                "slug": "signed-distance-field",
                "name": "Signed Distance Field",
                "description": "Study the distance functions for rendering smooth and detailed shapes, plus the formulas for combining them together for building more complex shapes.",
                "order": 5,
                "createdBy": {
                    "id": 3,
                    "name": "Alexander"
                },
                "locked": false,
                "tasks": [
                    {
                        "id": 128,
                        "slug": "sdf-circle",
                        "moduleId": 3,
                        "name": "SDF Circle",
                        "order": 1,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": 0,
                        "premium": false,
                        "child": {
                            "task": {
                                "id": 128,
                                "slug": "sdf-circle",
                                "moduleId": 3,
                                "name": "SDF Circle",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\n\nconst vec3 shapeColor      = vec3(1.0, 0.3, 0.3);\nconst vec3 backgroundColor = vec3(0.12);\n\nfloat sdfCircle(vec2 center, float r, vec2 pos) {\n  return distance(center, pos) - r;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy;\n\n  float t = sdfCircle(iResolution * 0.5, iResolution.y * 0.4, uv);\n  t = clamp(t, 0.0, 1.0);\n  \n  gl_FragColor = vec4(mix(shapeColor, backgroundColor, t), 1.0);\n}",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\n\nconst vec3 shapeColor      = vec3(1.0, 0.3, 0.3);\nconst vec3 backgroundColor = vec3(0.12);\n\nfloat sdfCircle(vec2 center, float r, vec2 pos) {\n  return 1.0;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy;\n\n  float t = sdfCircle(iResolution * 0.5, iResolution.y * 0.4, uv);\n  t = clamp(t, 0.0, 1.0);\n  \n  gl_FragColor = vec4(mix(shapeColor, backgroundColor, t), 1.0);\n}",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1,\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "A signed distance field (SDF) is a mathematical representation of a shape that is commonly used in computer graphics for rendering. It is a function that takes a point in space and returns the distance to the nearest point on the surface of the shape, with a sign indicating whether the point is inside or outside the shape:\n\n1. If the value is negative, the point is inside the shape. \n2. If the value is zero, the point is on the surface of the shape.\n3. If the value is positive, the point is outside the shape.\n\nThe simplest SDF function is for a circle. The SDF circle function takes in a 2D point **(x, y)** and a radius **R**, and returns the signed distance to the nearest point on the surface of the circle.\n\n<br>\n\nHere you can find different intresting sdf functions: [SDF functions](https://iquilezles.org/articles/distfunctions2d/).\n\n### Task\nImplement the SDF circle function to render a circle in the center of the screen.",
                                "hints": [],
                                "restrictions": [],
                                "order": 1,
                                "cost": 5,
                                "threshold": 95,
                                "likes": 2,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": false
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\n\nconst vec3 shapeColor      = vec3(1.0, 0.3, 0.3);\nconst vec3 backgroundColor = vec3(0.12);\n\nfloat sdfCircle(vec2 center, float r, vec2 pos) {\n  return 1.0;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy;\n\n  float t = sdfCircle(iResolution * 0.5, iResolution.y * 0.4, uv);\n  t = clamp(t, 0.0, 1.0);\n  \n  gl_FragColor = vec4(mix(shapeColor, backgroundColor, t), 1.0);\n}",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\n\nconst vec3 shapeColor      = vec3(1.0, 0.3, 0.3);\nconst vec3 backgroundColor = vec3(0.12);\n\nfloat sdfCircle(vec2 center, float r, vec2 pos) {\n  return 1.0;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy;\n\n  float t = sdfCircle(iResolution * 0.5, iResolution.y * 0.4, uv);\n  t = clamp(t, 0.0, 1.0);\n  \n  gl_FragColor = vec4(mix(shapeColor, backgroundColor, t), 1.0);\n}",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 129,
                        "slug": "sdf-translate",
                        "moduleId": 3,
                        "name": "SDF Translate",
                        "order": 2,
                        "cost": 10,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": true,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 129,
                                "slug": "sdf-translate",
                                "moduleId": 3,
                                "name": "SDF Translate",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nconst vec3 shapeColor      = vec3(1.0, 0.3, 0.3);\nconst vec3 backgroundColor = vec3(0.12);\n\nfloat sdfCircle(vec2 center, float r, vec2 pos) {\n  return distance(center, pos) - r;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy;\n\n  float radius = iResolution.y * 0.4;\n  float speed = radius * 2.0;\n  float start = -radius;\n  float deltaX = mod(iTime * speed, iResolution.x + radius * 2.0);\n  \n  vec2 center = vec2(start + deltaX, iResolution.y * 0.5);\n  \n  float t = sdfCircle(center, radius, uv);\n  t = clamp(t, 0.0, 1.0);\n  \n  gl_FragColor = vec4(mix(shapeColor, backgroundColor, t), 1.0);\n}",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nconst vec3 shapeColor      = vec3(1.0, 0.3, 0.3);\nconst vec3 backgroundColor = vec3(0.12);\n\nfloat sdfCircle(vec2 center, float r, vec2 pos) {\n  return distance(center, pos) - r;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy;\n\n  float radius = iResolution.y * 0.4;\n  float speed = radius * 2.0;\n  \n  vec2 center = iResolution * 0.5;\n  \n  float t = sdfCircle(center, radius, uv);\n  t = clamp(t, 0.0, 1.0);\n\n  gl_FragColor = vec4(mix(shapeColor, backgroundColor, t), 1.0);\n}",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"object\":{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1},\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "To translate an SDF shape in space, you can simply add a displacement to the SDF shape's anchor (center) point or to the position of the point being evaluated in the SDF function. \n\n<br>\n\nFor example, let's say you have an SDF function for a sphere centered at the origin (0, 0). To translate this sphere 2 units to the right you can use one of the following methods:\n\n1. Add a displacement vector to the position of the sphere's center. So after the displacement the center  will be located at (2, 0).\n\n2. Subtract the displacement vector from the position of the point being evaluated in the SDF function. So if you were evaluating the point (3, 0), you would instead evaluate the value (1, 0).\n\n### Task\nAdd an SDF circle moving animation.",
                                "hints": [],
                                "restrictions": [],
                                "order": 2,
                                "cost": 10,
                                "threshold": 95,
                                "likes": 1,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": true,
                                "animationSteps": 10,
                                "animationStepTime": 500,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nconst vec3 shapeColor      = vec3(1.0, 0.3, 0.3);\nconst vec3 backgroundColor = vec3(0.12);\n\nfloat sdfCircle(vec2 center, float r, vec2 pos) {\n  return distance(center, pos) - r;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy;\n\n  float radius = iResolution.y * 0.4;\n  float speed = radius * 2.0;\n  \n  vec2 center = iResolution * 0.5;\n  \n  float t = sdfCircle(center, radius, uv);\n  t = clamp(t, 0.0, 1.0);\n\n  gl_FragColor = vec4(mix(shapeColor, backgroundColor, t), 1.0);\n}",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nconst vec3 shapeColor      = vec3(1.0, 0.3, 0.3);\nconst vec3 backgroundColor = vec3(0.12);\n\nfloat sdfCircle(vec2 center, float r, vec2 pos) {\n  return distance(center, pos) - r;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy;\n\n  float radius = iResolution.y * 0.4;\n  float speed = radius * 2.0;\n  \n  vec2 center = iResolution * 0.5;\n  \n  float t = sdfCircle(center, radius, uv);\n  t = clamp(t, 0.0, 1.0);\n\n  gl_FragColor = vec4(mix(shapeColor, backgroundColor, t), 1.0);\n}",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 130,
                        "slug": "sdf-union",
                        "moduleId": 3,
                        "name": "SDF Union",
                        "order": 3,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": true,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 130,
                                "slug": "sdf-union",
                                "moduleId": 3,
                                "name": "SDF Union",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\n\nconst vec3 shapeColor      = vec3(1.0, 0.3, 0.3);\nconst vec3 backgroundColor = vec3(0.12);\n\nfloat sdfCircle(vec2 center, float r, vec2 pos) {\n  return distance(center, pos) - r;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy;\n  \n  vec2 center1 = iResolution * vec2(0.4, 0.5);\n  vec2 center2 = iResolution * vec2(0.6, 0.5);\n\n  float r1 = iResolution.y * 0.4;\n  float r2 = iResolution.y * 0.4;\n\n  float c1 = sdfCircle(center1, r1, uv);\n  float c2 = sdfCircle(center2, r2, uv);\n  \n  float t = min(c1, c2);\n  t = clamp(t, 0.0, 1.0);\n  \n  gl_FragColor = vec4(mix(shapeColor, backgroundColor, t), 1.0);\n}",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\n\nconst vec3 shapeColor      = vec3(1.0, 0.3, 0.3);\nconst vec3 backgroundColor = vec3(0.12);\n\nfloat sdfCircle(vec2 center, float r, vec2 pos) {\n  return distance(center, pos) - r;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy;\n  \n  vec2 center1 = iResolution * vec2(0.4, 0.5);\n  vec2 center2 = iResolution * vec2(0.6, 0.5);\n\n  float r1 = iResolution.y * 0.4;\n  float r2 = iResolution.y * 0.4;\n\n  float c1 = sdfCircle(center1, r1, uv);\n  float c2 = sdfCircle(center2, r2, uv);\n\n  vec3 color1 = vec3(0.38, 0.12, 0.93);\n  vec3 color2 = vec3(0.12);\n  \n  float t = 1.0; // union result\n  t = clamp(t, 0.0, 1.0);\n  \n  gl_FragColor = vec4(mix(shapeColor, backgroundColor, t), 1.0);\n}",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"object\":{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1},\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "The union of two SDF shapes is a new shape that includes all points that are inside either of the original shapes. To use union, you can simply evaluate both SDF functions at a given point and take the minimum of the two distances.\n\n### Task\nRender the union of two circles given via the sdf function on the screen.",
                                "hints": [],
                                "restrictions": [],
                                "order": 3,
                                "cost": 5,
                                "threshold": 95,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\n\nconst vec3 shapeColor      = vec3(1.0, 0.3, 0.3);\nconst vec3 backgroundColor = vec3(0.12);\n\nfloat sdfCircle(vec2 center, float r, vec2 pos) {\n  return distance(center, pos) - r;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy;\n  \n  vec2 center1 = iResolution * vec2(0.4, 0.5);\n  vec2 center2 = iResolution * vec2(0.6, 0.5);\n\n  float r1 = iResolution.y * 0.4;\n  float r2 = iResolution.y * 0.4;\n\n  float c1 = sdfCircle(center1, r1, uv);\n  float c2 = sdfCircle(center2, r2, uv);\n\n  vec3 color1 = vec3(0.38, 0.12, 0.93);\n  vec3 color2 = vec3(0.12);\n  \n  float t = 1.0; // union result\n  t = clamp(t, 0.0, 1.0);\n  \n  gl_FragColor = vec4(mix(shapeColor, backgroundColor, t), 1.0);\n}",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\n\nconst vec3 shapeColor      = vec3(1.0, 0.3, 0.3);\nconst vec3 backgroundColor = vec3(0.12);\n\nfloat sdfCircle(vec2 center, float r, vec2 pos) {\n  return distance(center, pos) - r;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy;\n  \n  vec2 center1 = iResolution * vec2(0.4, 0.5);\n  vec2 center2 = iResolution * vec2(0.6, 0.5);\n\n  float r1 = iResolution.y * 0.4;\n  float r2 = iResolution.y * 0.4;\n\n  float c1 = sdfCircle(center1, r1, uv);\n  float c2 = sdfCircle(center2, r2, uv);\n\n  vec3 color1 = vec3(0.38, 0.12, 0.93);\n  vec3 color2 = vec3(0.12);\n  \n  float t = 1.0; // union result\n  t = clamp(t, 0.0, 1.0);\n  \n  gl_FragColor = vec4(mix(shapeColor, backgroundColor, t), 1.0);\n}",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 131,
                        "slug": "sdf-intersection",
                        "moduleId": 3,
                        "name": "SDF Intersection",
                        "order": 4,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": true,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 131,
                                "slug": "sdf-intersection",
                                "moduleId": 3,
                                "name": "SDF Intersection",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\n\nconst vec3 shapeColor      = vec3(1.0, 0.3, 0.3);\nconst vec3 backgroundColor = vec3(0.12);\n\nfloat sdfCircle(vec2 center, float r, vec2 pos) {\n  return distance(center, pos) - r;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy;\n  \n  vec2 center1 = iResolution * vec2(0.4, 0.5);\n  vec2 center2 = iResolution * vec2(0.6, 0.5);\n\n  float r1 = iResolution.y * 0.4;\n  float r2 = iResolution.y * 0.4;\n\n  float c1 = sdfCircle(center1, r1, uv);\n  float c2 = sdfCircle(center2, r2, uv);\n\n  float t = max(c1, c2);\n  t = clamp(t, 0.0, 1.0);\n  \n  gl_FragColor = vec4(mix(shapeColor, backgroundColor, t), 1.0);\n}",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\n\nconst vec3 shapeColor      = vec3(1.0, 0.3, 0.3);\nconst vec3 backgroundColor = vec3(0.12);\n\nfloat sdfCircle(vec2 center, float r, vec2 pos) {\n  return distance(center, pos) - r;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy;\n  \n  vec2 center1 = iResolution * vec2(0.4, 0.5);\n  vec2 center2 = iResolution * vec2(0.6, 0.5);\n\n  float r1 = iResolution.y * 0.4;\n  float r2 = iResolution.y * 0.4;\n\n  float c1 = sdfCircle(center1, r1, uv);\n  float c2 = sdfCircle(center2, r2, uv);\n\n  float t = 1.0; // intersection result\n  t = clamp(t, 0.0, 1.0);\n  \n  gl_FragColor = vec4(mix(shapeColor, backgroundColor, t), 1.0);\n}",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"object\":{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1},\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "The intersection of two SDF shapes is a new shape that includes only the points that are inside both of the original shapes. To use intersection, you can evaluate both SDF functions at a given point and take the maximum of the two distances.\n\n### Task\nRender the intersection of two circles given via the sdf function on the screen.",
                                "hints": [],
                                "restrictions": [],
                                "order": 4,
                                "cost": 5,
                                "threshold": 98,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\n\nconst vec3 shapeColor      = vec3(1.0, 0.3, 0.3);\nconst vec3 backgroundColor = vec3(0.12);\n\nfloat sdfCircle(vec2 center, float r, vec2 pos) {\n  return distance(center, pos) - r;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy;\n  \n  vec2 center1 = iResolution * vec2(0.4, 0.5);\n  vec2 center2 = iResolution * vec2(0.6, 0.5);\n\n  float r1 = iResolution.y * 0.4;\n  float r2 = iResolution.y * 0.4;\n\n  float c1 = sdfCircle(center1, r1, uv);\n  float c2 = sdfCircle(center2, r2, uv);\n\n  float t = 1.0; // intersection result\n  t = clamp(t, 0.0, 1.0);\n  \n  gl_FragColor = vec4(mix(shapeColor, backgroundColor, t), 1.0);\n}",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\n\nconst vec3 shapeColor      = vec3(1.0, 0.3, 0.3);\nconst vec3 backgroundColor = vec3(0.12);\n\nfloat sdfCircle(vec2 center, float r, vec2 pos) {\n  return distance(center, pos) - r;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy;\n  \n  vec2 center1 = iResolution * vec2(0.4, 0.5);\n  vec2 center2 = iResolution * vec2(0.6, 0.5);\n\n  float r1 = iResolution.y * 0.4;\n  float r2 = iResolution.y * 0.4;\n\n  float c1 = sdfCircle(center1, r1, uv);\n  float c2 = sdfCircle(center2, r2, uv);\n\n  float t = 1.0; // intersection result\n  t = clamp(t, 0.0, 1.0);\n  \n  gl_FragColor = vec4(mix(shapeColor, backgroundColor, t), 1.0);\n}",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 132,
                        "slug": "sdf-subtraction",
                        "moduleId": 3,
                        "name": "SDF Subtraction",
                        "order": 5,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": true,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 132,
                                "slug": "sdf-subtraction",
                                "moduleId": 3,
                                "name": "SDF Subtraction",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\n\nconst vec3 shapeColor      = vec3(1.0, 0.3, 0.3);\nconst vec3 backgroundColor = vec3(0.12);\n\nfloat sdfCircle(vec2 center, float r, vec2 pos) {\n  return distance(center, pos) - r;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy;\n  \n  vec2 center1 = iResolution * vec2(0.4, 0.5);\n  vec2 center2 = iResolution * vec2(0.6, 0.5);\n\n  float r1 = iResolution.y * 0.4;\n  float r2 = iResolution.y * 0.4;\n\n  float c1 = sdfCircle(center1, r1, uv);\n  float c2 = sdfCircle(center2, r2, uv);\n\n  float t = max(c1, -c2);\n  t = clamp(t, 0.0, 1.0);\n  \n  gl_FragColor = vec4(mix(shapeColor, backgroundColor, t), 1.0);\n}",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\n\nconst vec3 shapeColor      = vec3(1.0, 0.3, 0.3);\nconst vec3 backgroundColor = vec3(0.12);\n\nfloat sdfCircle(vec2 center, float r, vec2 pos) {\n  return distance(center, pos) - r;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy;\n  \n  vec2 center1 = iResolution * vec2(0.4, 0.5);\n  vec2 center2 = iResolution * vec2(0.6, 0.5);\n\n  float r1 = iResolution.y * 0.4;\n  float r2 = iResolution.y * 0.4;\n\n  float c1 = sdfCircle(center1, r1, uv);\n  float c2 = sdfCircle(center2, r2, uv);\n\n  float t = 1.0; // subtraction result\n  t = clamp(t, 0.0, 1.0);\n  \n  gl_FragColor = vec4(mix(shapeColor, backgroundColor, t), 1.0);\n}",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"object\":{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1},\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "The subtraction of two SDF shapes is a new shape that includes only the points that are inside the first shape but not inside the second shape. To use subtraction, you can evaluate both SDF functions at a given point and subtract one distance from the other.\n\n### Task\nRender the result of subtracting the second circle from the first one.",
                                "hints": [],
                                "restrictions": [],
                                "order": 5,
                                "cost": 5,
                                "threshold": 98,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\n\nconst vec3 shapeColor      = vec3(1.0, 0.3, 0.3);\nconst vec3 backgroundColor = vec3(0.12);\n\nfloat sdfCircle(vec2 center, float r, vec2 pos) {\n  return distance(center, pos) - r;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy;\n  \n  vec2 center1 = iResolution * vec2(0.4, 0.5);\n  vec2 center2 = iResolution * vec2(0.6, 0.5);\n\n  float r1 = iResolution.y * 0.4;\n  float r2 = iResolution.y * 0.4;\n\n  float c1 = sdfCircle(center1, r1, uv);\n  float c2 = sdfCircle(center2, r2, uv);\n\n  float t = 1.0; // subtraction result\n  t = clamp(t, 0.0, 1.0);\n  \n  gl_FragColor = vec4(mix(shapeColor, backgroundColor, t), 1.0);\n}",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\n\nconst vec3 shapeColor      = vec3(1.0, 0.3, 0.3);\nconst vec3 backgroundColor = vec3(0.12);\n\nfloat sdfCircle(vec2 center, float r, vec2 pos) {\n  return distance(center, pos) - r;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy;\n  \n  vec2 center1 = iResolution * vec2(0.4, 0.5);\n  vec2 center2 = iResolution * vec2(0.6, 0.5);\n\n  float r1 = iResolution.y * 0.4;\n  float r2 = iResolution.y * 0.4;\n\n  float c1 = sdfCircle(center1, r1, uv);\n  float c2 = sdfCircle(center2, r2, uv);\n\n  float t = 1.0; // subtraction result\n  t = clamp(t, 0.0, 1.0);\n  \n  gl_FragColor = vec4(mix(shapeColor, backgroundColor, t), 1.0);\n}",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 133,
                        "slug": "sdf-symmetric-difference-xor",
                        "moduleId": 3,
                        "name": "SDF Symmetric difference - XOR",
                        "order": 6,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": true,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 133,
                                "slug": "sdf-symmetric-difference-xor",
                                "moduleId": 3,
                                "name": "SDF Symmetric difference - XOR",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\n\nconst vec3 shapeColor      = vec3(1.0, 0.3, 0.3);\nconst vec3 backgroundColor = vec3(0.12);\n\nfloat sdfCircle(vec2 center, float r, vec2 pos) {\n  return distance(center, pos) - r;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy;\n  \n  vec2 center1 = iResolution * vec2(0.4, 0.5);\n  vec2 center2 = iResolution * vec2(0.6, 0.5);\n\n  float r1 = iResolution.y * 0.4;\n  float r2 = iResolution.y * 0.4;\n\n  float c1 = sdfCircle(center1, r1, uv);\n  float c2 = sdfCircle(center2, r2, uv);\n\n  float t = c1 * c2;\n  t = clamp(t, 0.0, 1.0);\n  \n  gl_FragColor = vec4(mix(shapeColor, backgroundColor, t), 1.0);\n}",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\n\nconst vec3 shapeColor      = vec3(0.38, 0.12, 0.93);\nconst vec3 backgroundColor = vec3(0.12);\n\nfloat sdfCircle(vec2 center, float r, vec2 pos) {\n  return distance(center, pos) - r;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy;\n  \n  vec2 center1 = iResolution * vec2(0.4, 0.5);\n  vec2 center2 = iResolution * vec2(0.6, 0.5);\n\n  float r1 = iResolution.y * 0.4;\n  float r2 = iResolution.y * 0.4;\n\n  float c1 = sdfCircle(center1, r1, uv);\n  float c2 = sdfCircle(center2, r2, uv);\n\n  float t = 1.0; // xor result\n  t = clamp(t, 0.0, 1.0);\n  \n  gl_FragColor = vec4(mix(shapeColor, backgroundColor, t), 1.0);\n}",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"object\":{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1},\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "The symmetric difference (XOR) of two SDF shapes is a new shape that includes only the points that are inside one of the original shapes but not both. To use XOR, you can evaluate both SDF functions at a given point and take the absolute value of their difference.\n\n### Task\nRender the symmetric difference (XOR) of two circles.",
                                "hints": [],
                                "restrictions": [],
                                "order": 6,
                                "cost": 5,
                                "threshold": 98,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\n\nconst vec3 shapeColor      = vec3(0.38, 0.12, 0.93);\nconst vec3 backgroundColor = vec3(0.12);\n\nfloat sdfCircle(vec2 center, float r, vec2 pos) {\n  return distance(center, pos) - r;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy;\n  \n  vec2 center1 = iResolution * vec2(0.4, 0.5);\n  vec2 center2 = iResolution * vec2(0.6, 0.5);\n\n  float r1 = iResolution.y * 0.4;\n  float r2 = iResolution.y * 0.4;\n\n  float c1 = sdfCircle(center1, r1, uv);\n  float c2 = sdfCircle(center2, r2, uv);\n\n  float t = 1.0; // xor result\n  t = clamp(t, 0.0, 1.0);\n  \n  gl_FragColor = vec4(mix(shapeColor, backgroundColor, t), 1.0);\n}",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\n\nconst vec3 shapeColor      = vec3(0.38, 0.12, 0.93);\nconst vec3 backgroundColor = vec3(0.12);\n\nfloat sdfCircle(vec2 center, float r, vec2 pos) {\n  return distance(center, pos) - r;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy;\n  \n  vec2 center1 = iResolution * vec2(0.4, 0.5);\n  vec2 center2 = iResolution * vec2(0.6, 0.5);\n\n  float r1 = iResolution.y * 0.4;\n  float r2 = iResolution.y * 0.4;\n\n  float c1 = sdfCircle(center1, r1, uv);\n  float c2 = sdfCircle(center2, r2, uv);\n\n  float t = 1.0; // xor result\n  t = clamp(t, 0.0, 1.0);\n  \n  gl_FragColor = vec4(mix(shapeColor, backgroundColor, t), 1.0);\n}",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 134,
                        "slug": "sdf-combination",
                        "moduleId": 3,
                        "name": "SDF Combination",
                        "order": 7,
                        "cost": 10,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": true,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 134,
                                "slug": "sdf-combination",
                                "moduleId": 3,
                                "name": "SDF Combination",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\n\nconst vec3 shapeColor      = vec3(1.0, 0.3, 0.3);\nconst vec3 backgroundColor = vec3(0.12);\n\nfloat sdfCircle(vec2 center, float r, vec2 pos) {\n  return distance(center, pos) - r;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy;\n  \n  float r  = iResolution.y * 0.2;\n  \n  vec2 center1 = iResolution * vec2(0.5, 0.4) + vec2(+r, +r);\n  vec2 center2 = iResolution * vec2(0.5, 0.4) + vec2(-r, +r);\n  vec2 center3 = iResolution * vec2(0.5, 0.4) + vec2(-r, -r);\n  vec2 center4 = iResolution * vec2(0.5, 0.4) + vec2(+r, -r);\n  vec2 center5 = iResolution * vec2(0.5, 0.4);\n  \n  float c1 = sdfCircle(center1, r, uv);\n  float c2 = sdfCircle(center2, r, uv);\n  float c3 = sdfCircle(center3, r, uv);\n  float c4 = sdfCircle(center4, r, uv);\n  float c5 = sdfCircle(center5, r, uv);\n\n  float t0 = min(min(c1, c2), c5);\n  float t1 = min(c3, c4);\n  float t2 = min(-t0, t1);\n\n  float t = clamp(-t2, 0.0, 1.0);  \n    \n  gl_FragColor = vec4(mix(shapeColor, backgroundColor, t), 1.0);\n}",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\n\nconst vec3 shapeColor      = vec3(1.0, 0.3, 0.3);\nconst vec3 backgroundColor = vec3(0.12);\n\nfloat sdfCircle(vec2 center, float r, vec2 pos) {\n  return distance(center, pos) - r;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy;\n  \n  float r  = iResolution.y * 0.2;\n  \n  vec2 center1 = iResolution * vec2(0.5, 0.4) + vec2(+r, +r);\n  vec2 center2 = iResolution * vec2(0.5, 0.4) + vec2(-r, +r);\n  vec2 center3 = iResolution * vec2(0.5, 0.4) + vec2(-r, -r);\n  vec2 center4 = iResolution * vec2(0.5, 0.4) + vec2(+r, -r);\n  vec2 center5 = iResolution * vec2(0.5, 0.4);\n  \n  float c1 = sdfCircle(center1, r, uv);\n  float c2 = sdfCircle(center2, r, uv);\n  float c3 = sdfCircle(center3, r, uv);\n  float c4 = sdfCircle(center4, r, uv);\n  float c5 = sdfCircle(center5, r, uv);\n\n  float t = 1.0; // aggregation result\n  t = clamp(t, 0.0, 1.0); \n    \n  gl_FragColor = vec4(mix(shapeColor, backgroundColor, t), 1.0);\n}",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"object\":{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1},\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "### Task\nUsing the learned operations on sdf shapes, try to combine several circles to get a more complex shape.",
                                "hints": [],
                                "restrictions": [],
                                "order": 7,
                                "cost": 10,
                                "threshold": 98,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\n\nconst vec3 shapeColor      = vec3(1.0, 0.3, 0.3);\nconst vec3 backgroundColor = vec3(0.12);\n\nfloat sdfCircle(vec2 center, float r, vec2 pos) {\n  return distance(center, pos) - r;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy;\n  \n  float r  = iResolution.y * 0.2;\n  \n  vec2 center1 = iResolution * vec2(0.5, 0.4) + vec2(+r, +r);\n  vec2 center2 = iResolution * vec2(0.5, 0.4) + vec2(-r, +r);\n  vec2 center3 = iResolution * vec2(0.5, 0.4) + vec2(-r, -r);\n  vec2 center4 = iResolution * vec2(0.5, 0.4) + vec2(+r, -r);\n  vec2 center5 = iResolution * vec2(0.5, 0.4);\n  \n  float c1 = sdfCircle(center1, r, uv);\n  float c2 = sdfCircle(center2, r, uv);\n  float c3 = sdfCircle(center3, r, uv);\n  float c4 = sdfCircle(center4, r, uv);\n  float c5 = sdfCircle(center5, r, uv);\n\n  float t = 1.0; // aggregation result\n  t = clamp(t, 0.0, 1.0); \n    \n  gl_FragColor = vec4(mix(shapeColor, backgroundColor, t), 1.0);\n}",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\n\nconst vec3 shapeColor      = vec3(1.0, 0.3, 0.3);\nconst vec3 backgroundColor = vec3(0.12);\n\nfloat sdfCircle(vec2 center, float r, vec2 pos) {\n  return distance(center, pos) - r;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy;\n  \n  float r  = iResolution.y * 0.2;\n  \n  vec2 center1 = iResolution * vec2(0.5, 0.4) + vec2(+r, +r);\n  vec2 center2 = iResolution * vec2(0.5, 0.4) + vec2(-r, +r);\n  vec2 center3 = iResolution * vec2(0.5, 0.4) + vec2(-r, -r);\n  vec2 center4 = iResolution * vec2(0.5, 0.4) + vec2(+r, -r);\n  vec2 center5 = iResolution * vec2(0.5, 0.4);\n  \n  float c1 = sdfCircle(center1, r, uv);\n  float c2 = sdfCircle(center2, r, uv);\n  float c3 = sdfCircle(center3, r, uv);\n  float c4 = sdfCircle(center4, r, uv);\n  float c5 = sdfCircle(center5, r, uv);\n\n  float t = 1.0; // aggregation result\n  t = clamp(t, 0.0, 1.0); \n    \n  gl_FragColor = vec4(mix(shapeColor, backgroundColor, t), 1.0);\n}",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 136,
                        "slug": "sdf-interpolation",
                        "moduleId": 3,
                        "name": "SDF Interpolation",
                        "order": 8,
                        "cost": 10,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": true,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 136,
                                "slug": "sdf-interpolation",
                                "moduleId": 3,
                                "name": "SDF Interpolation",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nconst vec3 shapeColor      = vec3(1.0, 0.3, 0.3);\nconst vec3 backgroundColor = vec3(0.12);\n\nfloat sdfCircle(vec2 center, float r, vec2 pos) {\n  return distance(center, pos) - r;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy;\n  \n  float r  = iResolution.y * 0.25;\n  \n  vec2 center1 = iResolution * vec2(0.5, 0.4) + vec2(+r, +r);\n  vec2 center2 = iResolution * vec2(0.5, 0.4) + vec2(-r, +r);\n  vec2 center3 = iResolution * vec2(0.5, 0.4) + vec2(-r, -r);\n  vec2 center4 = iResolution * vec2(0.5, 0.4) + vec2(+r, -r);\n  vec2 center5 = iResolution * vec2(0.5, 0.4);\n  \n  float c1 = sdfCircle(center1, r, uv);\n  float c2 = sdfCircle(center2, r, uv);\n  float c3 = sdfCircle(center3, r, uv);\n  float c4 = sdfCircle(center4, r, uv);\n  float c5 = sdfCircle(center5, r, uv);\n\n  float t0 = min(min(c1, c2), c5);\n  float t1 = min(c3, c4);\n  float t2 = min(-t0, t1);\n  float t3 = mix(-t2, c5, 0.35);\n  float t  = clamp(t3, 0.0, 1.0);  \n    \n  gl_FragColor = vec4(mix(shapeColor, backgroundColor, t), 1.0);\n}",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\n\nconst vec3 shapeColor      = vec3(1.0, 0.3, 0.3);\nconst vec3 backgroundColor = vec3(0.12);\n\nfloat sdfCircle(vec2 center, float r, vec2 pos) {\n  return distance(center, pos) - r;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy;\n  \n  float r  = iResolution.y * 0.25;\n  \n  vec2 center1 = iResolution * vec2(0.5, 0.4) + vec2(+r, +r);\n  vec2 center2 = iResolution * vec2(0.5, 0.4) + vec2(-r, +r);\n  vec2 center3 = iResolution * vec2(0.5, 0.4) + vec2(-r, -r);\n  vec2 center4 = iResolution * vec2(0.5, 0.4) + vec2(+r, -r);\n  vec2 center5 = iResolution * vec2(0.5, 0.4);\n  \n  float c1 = sdfCircle(center1, r, uv);\n  float c2 = sdfCircle(center2, r, uv);\n  float c3 = sdfCircle(center3, r, uv);\n  float c4 = sdfCircle(center4, r, uv);\n  float c5 = sdfCircle(center5, r, uv);\n\n  float t0 = min(min(c1, c2), c5);\n  float t1 = min(c3, c4);\n  float t2 = min(-t0, t1);\n  float t  = clamp(-t2, 0.0, 1.0);  \n    \n  gl_FragColor = vec4(mix(shapeColor, backgroundColor, t), 1.0);\n}",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"object\":{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1},\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "Interpolation can be used to smoothly change one SDF shape to another by blending the two shapes together gradually. Here are the steps to do this:\n\n1. Choose the two SDF shapes that you want to interpolate between.\n\n2. Determine the amount of interpolation that you want to apply. This can be a value between 0 and 1, where 0 represents the first shape and 1 represents the second shape.\n\n3. Calculate the blended SDF by interpolating between the two shapes. This can be done by using a weighted average of the two SDFs, where the weight is determined by the interpolation value. For example, if the interpolation value is 0.5, then the blended SDF would be the average of the two SDFs.\n\n### Task\nUse interpolation to smooth out sharp edges of the shape. The interpolation value is 0.35.",
                                "hints": [],
                                "restrictions": [],
                                "order": 8,
                                "cost": 10,
                                "threshold": 99,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\n\nconst vec3 shapeColor      = vec3(1.0, 0.3, 0.3);\nconst vec3 backgroundColor = vec3(0.12);\n\nfloat sdfCircle(vec2 center, float r, vec2 pos) {\n  return distance(center, pos) - r;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy;\n  \n  float r  = iResolution.y * 0.25;\n  \n  vec2 center1 = iResolution * vec2(0.5, 0.4) + vec2(+r, +r);\n  vec2 center2 = iResolution * vec2(0.5, 0.4) + vec2(-r, +r);\n  vec2 center3 = iResolution * vec2(0.5, 0.4) + vec2(-r, -r);\n  vec2 center4 = iResolution * vec2(0.5, 0.4) + vec2(+r, -r);\n  vec2 center5 = iResolution * vec2(0.5, 0.4);\n  \n  float c1 = sdfCircle(center1, r, uv);\n  float c2 = sdfCircle(center2, r, uv);\n  float c3 = sdfCircle(center3, r, uv);\n  float c4 = sdfCircle(center4, r, uv);\n  float c5 = sdfCircle(center5, r, uv);\n\n  float t0 = min(min(c1, c2), c5);\n  float t1 = min(c3, c4);\n  float t2 = min(-t0, t1);\n  float t  = clamp(-t2, 0.0, 1.0);  \n    \n  gl_FragColor = vec4(mix(shapeColor, backgroundColor, t), 1.0);\n}",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\n\nconst vec3 shapeColor      = vec3(1.0, 0.3, 0.3);\nconst vec3 backgroundColor = vec3(0.12);\n\nfloat sdfCircle(vec2 center, float r, vec2 pos) {\n  return distance(center, pos) - r;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy;\n  \n  float r  = iResolution.y * 0.25;\n  \n  vec2 center1 = iResolution * vec2(0.5, 0.4) + vec2(+r, +r);\n  vec2 center2 = iResolution * vec2(0.5, 0.4) + vec2(-r, +r);\n  vec2 center3 = iResolution * vec2(0.5, 0.4) + vec2(-r, -r);\n  vec2 center4 = iResolution * vec2(0.5, 0.4) + vec2(+r, -r);\n  vec2 center5 = iResolution * vec2(0.5, 0.4);\n  \n  float c1 = sdfCircle(center1, r, uv);\n  float c2 = sdfCircle(center2, r, uv);\n  float c3 = sdfCircle(center3, r, uv);\n  float c4 = sdfCircle(center4, r, uv);\n  float c5 = sdfCircle(center5, r, uv);\n\n  float t0 = min(min(c1, c2), c5);\n  float t1 = min(c3, c4);\n  float t2 = min(-t0, t1);\n  float t  = clamp(-t2, 0.0, 1.0);  \n    \n  gl_FragColor = vec4(mix(shapeColor, backgroundColor, t), 1.0);\n}",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 137,
                        "slug": "sdf-rotation",
                        "moduleId": 3,
                        "name": "SDF Rotation",
                        "order": 9,
                        "cost": 10,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": true,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 137,
                                "slug": "sdf-rotation",
                                "moduleId": 3,
                                "name": "SDF Rotation",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nconst vec3 shapeColor      = vec3(1.0, 0.3, 0.3);\nconst vec3 backgroundColor = vec3(0.12);\n\nfloat sdfCircle(vec2 center, float r, vec2 pos) {\n  return distance(center, pos) - r;\n}\n\nfloat drawPental(vec2 uv) {\n  float r  = iResolution.y * 0.3;\n\n  vec2 center0 = iResolution * vec2(0.0, 0.0);\n  \n  vec2 center1 = iResolution * vec2(-0.03, 0.0) + vec2(+r, +r);\n  vec2 center2 = iResolution * vec2(+0.03, 0.0) + vec2(-r, +r);\n\n  float c0 = sdfCircle(center0, r * 0.3, uv);\n  \n  float c1 = sdfCircle(center1, r, uv);\n  float c2 = sdfCircle(center2, r, uv);\n\n  return min(max(c1, c2), c0);\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy;\n\n  // make 0 the center\n  uv.x -= iResolution.x * 0.5;\n  uv.y -= iResolution.y * 0.5;\n\n  float t = 1.0;\n  int steps = 20;\n  for (int i = 0; i < steps; i++) {\n    float maxangle = 6.28 / float(steps) * float(i);\n    float angle = maxangle;//clamp((sin(iTime) * 0.5 + 0.5)* 6.28, 0.0, maxangle);\n    \n    float x = uv.x * cos(angle) - uv.y * sin(angle);\n    float y = uv.x * sin(angle) + uv.y * cos(angle);\n\n    float ti = drawPental(vec2(x, y));\n    t = min(t, ti);\n  }\n  t = clamp(t, 0.0, 1.0);\n  \n  gl_FragColor = vec4(mix(shapeColor, backgroundColor, t), 1.0);\n}",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nconst vec3 shapeColor      = vec3(1.0, 0.3, 0.3);\nconst vec3 backgroundColor = vec3(0.12);\n\nfloat sdfCircle(vec2 center, float r, vec2 pos) {\n  return distance(center, pos) - r;\n}\n\nfloat drawPental(vec2 uv) {\n  float r  = iResolution.y * 0.3;\n\n  vec2 center0 = iResolution * vec2(0.0, 0.0);\n  \n  vec2 center1 = iResolution * vec2(-0.03, 0.0) + vec2(+r, +r);\n  vec2 center2 = iResolution * vec2(+0.03, 0.0) + vec2(-r, +r);\n\n  float c0 = sdfCircle(center0, r * 0.3, uv);\n  \n  float c1 = sdfCircle(center1, r, uv);\n  float c2 = sdfCircle(center2, r, uv);\n\n  return min(max(c1, c2), c0);\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy;\n\n  // make 0 the center\n  uv.x -= iResolution.x * 0.5;\n  uv.y -= iResolution.y * 0.5;\n\n  float t = 1.0;\n  int steps = 20;\n  for (int i = 0; i < steps; i++) {\n    float ti = drawPental(uv);\n    t = min(t, ti);\n  }\n  t = clamp(t, 0.0, 1.0);\n  \n  gl_FragColor = vec4(mix(shapeColor, backgroundColor, t), 1.0);\n}",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"object\":{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1},\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "To rotate an SDF shape, you can follow these steps:\n\n1. Determine the rotation angle.\n\n2. Create a 2x2 rotation matrix using the angle of rotation:\n```\n   |cos(theta) -sin(theta)|\n   |sin(theta)  cos(theta)|\n```\nwhere `theta` is the angle of rotation.\n\n3. Apply the rotation matrix to the coordinates.\n\n4. Use the rotated coordinates to draw a new SDF shape.\n\n\n### Task\nRotate each petal around the center of the screen to create an image of flower.",
                                "hints": [],
                                "restrictions": [],
                                "order": 9,
                                "cost": 10,
                                "threshold": 99,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nconst vec3 shapeColor      = vec3(1.0, 0.3, 0.3);\nconst vec3 backgroundColor = vec3(0.12);\n\nfloat sdfCircle(vec2 center, float r, vec2 pos) {\n  return distance(center, pos) - r;\n}\n\nfloat drawPental(vec2 uv) {\n  float r  = iResolution.y * 0.3;\n\n  vec2 center0 = iResolution * vec2(0.0, 0.0);\n  \n  vec2 center1 = iResolution * vec2(-0.03, 0.0) + vec2(+r, +r);\n  vec2 center2 = iResolution * vec2(+0.03, 0.0) + vec2(-r, +r);\n\n  float c0 = sdfCircle(center0, r * 0.3, uv);\n  \n  float c1 = sdfCircle(center1, r, uv);\n  float c2 = sdfCircle(center2, r, uv);\n\n  return min(max(c1, c2), c0);\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy;\n\n  // make 0 the center\n  uv.x -= iResolution.x * 0.5;\n  uv.y -= iResolution.y * 0.5;\n\n  float t = 1.0;\n  int steps = 20;\n  for (int i = 0; i < steps; i++) {\n    float ti = drawPental(uv);\n    t = min(t, ti);\n  }\n  t = clamp(t, 0.0, 1.0);\n  \n  gl_FragColor = vec4(mix(shapeColor, backgroundColor, t), 1.0);\n}",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nconst vec3 shapeColor      = vec3(1.0, 0.3, 0.3);\nconst vec3 backgroundColor = vec3(0.12);\n\nfloat sdfCircle(vec2 center, float r, vec2 pos) {\n  return distance(center, pos) - r;\n}\n\nfloat drawPental(vec2 uv) {\n  float r  = iResolution.y * 0.3;\n\n  vec2 center0 = iResolution * vec2(0.0, 0.0);\n  \n  vec2 center1 = iResolution * vec2(-0.03, 0.0) + vec2(+r, +r);\n  vec2 center2 = iResolution * vec2(+0.03, 0.0) + vec2(-r, +r);\n\n  float c0 = sdfCircle(center0, r * 0.3, uv);\n  \n  float c1 = sdfCircle(center1, r, uv);\n  float c2 = sdfCircle(center2, r, uv);\n\n  return min(max(c1, c2), c0);\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy;\n\n  // make 0 the center\n  uv.x -= iResolution.x * 0.5;\n  uv.y -= iResolution.y * 0.5;\n\n  float t = 1.0;\n  int steps = 20;\n  for (int i = 0; i < steps; i++) {\n    float ti = drawPental(uv);\n    t = min(t, ti);\n  }\n  t = clamp(t, 0.0, 1.0);\n  \n  gl_FragColor = vec4(mix(shapeColor, backgroundColor, t), 1.0);\n}",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 138,
                        "slug": "sdf-rotation-2",
                        "moduleId": 3,
                        "name": "SDF Rotation 2",
                        "order": 10,
                        "cost": 10,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": true,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 138,
                                "slug": "sdf-rotation-2",
                                "moduleId": 3,
                                "name": "SDF Rotation 2",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nconst vec3 shapeColor      = vec3(1.0, 0.3, 0.3);\nconst vec3 backgroundColor = vec3(0.12);\n\nfloat sdfCircle(vec2 center, float r, vec2 pos) {\n  return distance(center, pos) - r;\n}\n\nfloat drawPental(vec2 uv) {\n  float r  = iResolution.y * 0.3;\n\n  vec2 center0 = iResolution * vec2(0.0, 0.0);\n  \n  vec2 center1 = iResolution * vec2(-0.03, 0.0) + vec2(+r, +r);\n  vec2 center2 = iResolution * vec2(+0.03, 0.0) + vec2(-r, +r);\n\n  float c0 = sdfCircle(center0, r * 0.3, uv);\n  \n  float c1 = sdfCircle(center1, r, uv);\n  float c2 = sdfCircle(center2, r, uv);\n\n  return min(max(c1, c2), c0);\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy;\n\n  // make 0 the center\n  uv.x -= iResolution.x * 0.5;\n  uv.y -= iResolution.y * 0.5;\n\n  float t = 1.0;\n  int steps = 20;\n  for (int i = 0; i < steps; i++) {\n    float maxangle = 6.28 / float(steps) * float(i);\n    float angle = clamp((sin(iTime) * 0.5 + 0.5)* 6.28, 0.0, maxangle);\n    \n    float x = uv.x * cos(angle) - uv.y * sin(angle);\n    float y = uv.x * sin(angle) + uv.y * cos(angle);\n\n    float ti = drawPental(vec2(x, y));\n    t = min(t, ti);\n  }\n  t = clamp(t, 0.0, 1.0);\n  \n  gl_FragColor = vec4(mix(shapeColor, backgroundColor, t), 1.0);\n}",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nconst vec3 shapeColor      = vec3(1.0, 0.3, 0.3);\nconst vec3 backgroundColor = vec3(0.12);\n\nfloat sdfCircle(vec2 center, float r, vec2 pos) {\n  return distance(center, pos) - r;\n}\n\nfloat drawPental(vec2 uv) {\n  float r  = iResolution.y * 0.3;\n\n  vec2 center0 = iResolution * vec2(0.0, 0.0);\n  \n  vec2 center1 = iResolution * vec2(-0.03, 0.0) + vec2(+r, +r);\n  vec2 center2 = iResolution * vec2(+0.03, 0.0) + vec2(-r, +r);\n\n  float c0 = sdfCircle(center0, r * 0.3, uv);\n  \n  float c1 = sdfCircle(center1, r, uv);\n  float c2 = sdfCircle(center2, r, uv);\n\n  return min(max(c1, c2), c0);\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy;\n\n  // make 0 the center\n  uv.x -= iResolution.x * 0.5;\n  uv.y -= iResolution.y * 0.5;\n\n  float t = 1.0;\n  int steps = 20;\n  for (int i = 0; i < steps; i++) {\n    float angle = 6.28 / float(steps) * float(i);\n\n    // use sin(iTime)\n    \n    float x = uv.x * cos(angle) - uv.y * sin(angle);\n    float y = uv.x * sin(angle) + uv.y * cos(angle);\n\n    float ti = drawPental(vec2(x, y));\n    t = min(t, ti);\n  }\n  t = clamp(t, 0.0, 1.0);\n  \n  gl_FragColor = vec4(mix(shapeColor, backgroundColor, t), 1.0);\n}",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"object\":{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1},\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "### Task\nImplement the animation of a flower opening in a circular manner.",
                                "hints": [],
                                "restrictions": [],
                                "order": 10,
                                "cost": 10,
                                "threshold": 99,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": true,
                                "animationSteps": 12,
                                "animationStepTime": 500,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nconst vec3 shapeColor      = vec3(1.0, 0.3, 0.3);\nconst vec3 backgroundColor = vec3(0.12);\n\nfloat sdfCircle(vec2 center, float r, vec2 pos) {\n  return distance(center, pos) - r;\n}\n\nfloat drawPental(vec2 uv) {\n  float r  = iResolution.y * 0.3;\n\n  vec2 center0 = iResolution * vec2(0.0, 0.0);\n  \n  vec2 center1 = iResolution * vec2(-0.03, 0.0) + vec2(+r, +r);\n  vec2 center2 = iResolution * vec2(+0.03, 0.0) + vec2(-r, +r);\n\n  float c0 = sdfCircle(center0, r * 0.3, uv);\n  \n  float c1 = sdfCircle(center1, r, uv);\n  float c2 = sdfCircle(center2, r, uv);\n\n  return min(max(c1, c2), c0);\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy;\n\n  // make 0 the center\n  uv.x -= iResolution.x * 0.5;\n  uv.y -= iResolution.y * 0.5;\n\n  float t = 1.0;\n  int steps = 20;\n  for (int i = 0; i < steps; i++) {\n    float angle = 6.28 / float(steps) * float(i);\n\n    // use sin(iTime)\n    \n    float x = uv.x * cos(angle) - uv.y * sin(angle);\n    float y = uv.x * sin(angle) + uv.y * cos(angle);\n\n    float ti = drawPental(vec2(x, y));\n    t = min(t, ti);\n  }\n  t = clamp(t, 0.0, 1.0);\n  \n  gl_FragColor = vec4(mix(shapeColor, backgroundColor, t), 1.0);\n}",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nconst vec3 shapeColor      = vec3(1.0, 0.3, 0.3);\nconst vec3 backgroundColor = vec3(0.12);\n\nfloat sdfCircle(vec2 center, float r, vec2 pos) {\n  return distance(center, pos) - r;\n}\n\nfloat drawPental(vec2 uv) {\n  float r  = iResolution.y * 0.3;\n\n  vec2 center0 = iResolution * vec2(0.0, 0.0);\n  \n  vec2 center1 = iResolution * vec2(-0.03, 0.0) + vec2(+r, +r);\n  vec2 center2 = iResolution * vec2(+0.03, 0.0) + vec2(-r, +r);\n\n  float c0 = sdfCircle(center0, r * 0.3, uv);\n  \n  float c1 = sdfCircle(center1, r, uv);\n  float c2 = sdfCircle(center2, r, uv);\n\n  return min(max(c1, c2), c0);\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy;\n\n  // make 0 the center\n  uv.x -= iResolution.x * 0.5;\n  uv.y -= iResolution.y * 0.5;\n\n  float t = 1.0;\n  int steps = 20;\n  for (int i = 0; i < steps; i++) {\n    float angle = 6.28 / float(steps) * float(i);\n\n    // use sin(iTime)\n    \n    float x = uv.x * cos(angle) - uv.y * sin(angle);\n    float y = uv.x * sin(angle) + uv.y * cos(angle);\n\n    float ti = drawPental(vec2(x, y));\n    t = min(t, ti);\n  }\n  t = clamp(t, 0.0, 1.0);\n  \n  gl_FragColor = vec4(mix(shapeColor, backgroundColor, t), 1.0);\n}",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 135,
                        "slug": "sdf-soft-minmax",
                        "moduleId": 3,
                        "name": "SDF Soft MinMax",
                        "order": 11,
                        "cost": 10,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": true,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 135,
                                "slug": "sdf-soft-minmax",
                                "moduleId": 3,
                                "name": "SDF Soft MinMax",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nconst vec3 shapeColor      = vec3(1.0, 0.3, 0.3);\nconst vec3 backgroundColor = vec3(0.12);\n\nfloat sdfCircle(vec2 center, float r, vec2 pos) {\n  return distance(center, pos) - r;\n}\n\nfloat softMax(float a, float b, float k) {\n  return log(exp(k * a) + exp(k * b)) / k;\n}\n\nfloat softMin(float a, float b, float k) {\n  return -softMax(-a, -b, k);\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy;\n\n  float dx = cos(iTime) * 0.5 + 0.5;\n  dx *= 0.3;\n  \n  vec2 center1 = iResolution * vec2(0.2 + dx, 0.5);\n  vec2 center2 = iResolution * vec2(0.8 - dx, 0.5);\n\n  float r1 = iResolution.x * 0.15;\n  float r2 = iResolution.x * 0.15;\n\n  float c1 = sdfCircle(center1, r1, uv);\n  float c2 = sdfCircle(center2, r2, uv);\n\n  float t = softMin(c1, c2, 0.025);\n  t = clamp(t, 0.0, 1.0);\n  \n  gl_FragColor = vec4(mix(shapeColor, backgroundColor, t), 1.0);\n}",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nconst vec3 shapeColor      = vec3(1.0, 0.3, 0.3);\nconst vec3 backgroundColor = vec3(0.12);\n\nfloat sdfCircle(vec2 center, float r, vec2 pos) {\n  return distance(center, pos) - r;\n}\n\nfloat softMax(float a, float b, float k) {\n  return log(exp(k * a) + exp(k * b)) / k;\n}\n\nfloat softMin(float a, float b, float k) {\n  return min(a, b);\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy;\n\n  float dx = cos(iTime) * 0.5 + 0.5;\n  dx *= 0.3;\n  \n  vec2 center1 = iResolution * vec2(0.2 + dx, 0.5);\n  vec2 center2 = iResolution * vec2(0.8 - dx, 0.5);\n\n  float r1 = iResolution.x * 0.15;\n  float r2 = iResolution.x * 0.15;\n\n  float c1 = sdfCircle(center1, r1, uv);\n  float c2 = sdfCircle(center2, r2, uv);\n\n  float t = softMin(c1, c2, 0.025);\n  t = clamp(t, 0.0, 1.0);\n  \n  gl_FragColor = vec4(mix(shapeColor, backgroundColor, t), 1.0);\n}",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"object\":{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1},\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "Previously studied implementations of such operators as union and intersection are greate, but the resulting shape is no longer a smooth surface. To get a smoother result, we can use more complex implementation of the combination operators. So we're going to use [smooth maximum function](https://en.wikipedia.org/wiki/Smooth_maximum).\n\n```\nsmoothMax(s1, s2, k) = log(exp(s1 * k) + exp(s2 * k)) / k\n```\nWhere `k` is smooth factor.\n\n### Task\nSee how the `softMax` function works and try to implement `softMin` based on it to get a smooth union of two circles.",
                                "hints": [],
                                "restrictions": [],
                                "order": 11,
                                "cost": 10,
                                "threshold": 99,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": true,
                                "animationSteps": 12,
                                "animationStepTime": 250,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nconst vec3 shapeColor      = vec3(1.0, 0.3, 0.3);\nconst vec3 backgroundColor = vec3(0.12);\n\nfloat sdfCircle(vec2 center, float r, vec2 pos) {\n  return distance(center, pos) - r;\n}\n\nfloat softMax(float a, float b, float k) {\n  return log(exp(k * a) + exp(k * b)) / k;\n}\n\nfloat softMin(float a, float b, float k) {\n  return min(a, b);\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy;\n\n  float dx = cos(iTime) * 0.5 + 0.5;\n  dx *= 0.3;\n  \n  vec2 center1 = iResolution * vec2(0.2 + dx, 0.5);\n  vec2 center2 = iResolution * vec2(0.8 - dx, 0.5);\n\n  float r1 = iResolution.x * 0.15;\n  float r2 = iResolution.x * 0.15;\n\n  float c1 = sdfCircle(center1, r1, uv);\n  float c2 = sdfCircle(center2, r2, uv);\n\n  float t = softMin(c1, c2, 0.025);\n  t = clamp(t, 0.0, 1.0);\n  \n  gl_FragColor = vec4(mix(shapeColor, backgroundColor, t), 1.0);\n}",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nconst vec3 shapeColor      = vec3(1.0, 0.3, 0.3);\nconst vec3 backgroundColor = vec3(0.12);\n\nfloat sdfCircle(vec2 center, float r, vec2 pos) {\n  return distance(center, pos) - r;\n}\n\nfloat softMax(float a, float b, float k) {\n  return log(exp(k * a) + exp(k * b)) / k;\n}\n\nfloat softMin(float a, float b, float k) {\n  return min(a, b);\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy;\n\n  float dx = cos(iTime) * 0.5 + 0.5;\n  dx *= 0.3;\n  \n  vec2 center1 = iResolution * vec2(0.2 + dx, 0.5);\n  vec2 center2 = iResolution * vec2(0.8 - dx, 0.5);\n\n  float r1 = iResolution.x * 0.15;\n  float r2 = iResolution.x * 0.15;\n\n  float c1 = sdfCircle(center1, r1, uv);\n  float c2 = sdfCircle(center2, r2, uv);\n\n  float t = softMin(c1, c2, 0.025);\n  t = clamp(t, 0.0, 1.0);\n  \n  gl_FragColor = vec4(mix(shapeColor, backgroundColor, t), 1.0);\n}",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 141,
                        "slug": "sdf-cat-ears",
                        "moduleId": 3,
                        "name": "SDF Cat - Ears",
                        "order": 12,
                        "cost": 10,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": true,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 141,
                                "slug": "sdf-cat-ears",
                                "moduleId": 3,
                                "name": "SDF Cat - Ears",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nconst vec3 shapeColor      = vec3(1.0, 0.3, 0.3);\nconst vec3 backgroundColor = vec3(0.12);\n\nfloat sdfCircle(vec2 center, float r, vec2 pos) {\n  return distance(center, pos) - r;\n}\n\nfloat sdfBox(vec2 center, vec2 size, vec2 pos) {\n    vec2 d = abs(pos - center) - size;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\nfloat softMax(float a, float b, float k) {\n  return log(exp(k * a) + exp(k * b)) / k;\n}\n\nfloat softMin(float a, float b, float k) {\n  return -softMax(-a, -b, k);\n}\n\nfloat drawPental(vec2 uv, float r) {\n  vec2 center1 = vec2(-25.0, 0.0) + vec2(+r, +r);\n  vec2 center2 = vec2(+25.0, 0.0) + vec2(-r, +r);\n  \n  float c1 = sdfCircle(center1, r, uv);\n  float c2 = sdfCircle(center2, r, uv);\n\n  return max(c1, c2);\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy;\n\n  // make 0 the center\n  uv.x -= iResolution.x * 0.5;\n  uv.y -= iResolution.y * 0.5;\n\n  float head = sdfCircle(vec2(0.0, 0.0), 60.0 + sin(iTime) * 1.0, uv);\n\n  float angle = 3.14 * 0.2 - (sin(iTime) * 0.1);\n  float x = uv.x * cos(angle) - (uv.y) * sin(angle);\n  float y = uv.x * sin(angle) + (uv.y) * cos(angle);\n  float earOuter1 = drawPental(vec2(x, y), 60.0);\n\n  angle = 3.14 * 0.2 - (sin(iTime) * 0.1);\n  x = uv.x * cos(angle) - (uv.y) * sin(angle);\n  y = uv.x * sin(angle) + (uv.y) * cos(angle);\n  float earInner1 = drawPental(vec2(x, y + 5.0), 60.0);\n\n  angle = 3.14 * -0.2 + (sin(iTime) * 0.1);\n  x = uv.x * cos(angle) - (uv.y) * sin(angle);\n  y = uv.x * sin(angle) + (uv.y) * cos(angle);\n  float earOuter2 = drawPental(vec2(x, y), 60.0);\n\n  angle = 3.14 * -0.2 + (sin(iTime) * 0.1);\n  x = (uv.x) * cos(angle) - (uv.y) * sin(angle);\n  y = (uv.x) * sin(angle) + (uv.y) * cos(angle);\n  float earInner2 = drawPental(vec2(x, y + 5.0), 60.0);\n\n  float ear1 = max(earOuter1, -earInner1);\n  float ear2 = max(earOuter2, -earInner2);\n\n  float u1 = softMin(head, min(ear1, ear2), 0.25);\n  \n  float t = clamp(u1, 0.0, 1.0);\n  \n  gl_FragColor = vec4(mix(shapeColor, backgroundColor, t), 1.0);\n}",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nconst vec3 shapeColor      = vec3(1.0, 0.3, 0.3);\nconst vec3 backgroundColor = vec3(0.12);\n\nfloat sdfCircle(vec2 center, float r, vec2 pos) {\n  return distance(center, pos) - r;\n}\n\nfloat sdfBox(vec2 center, vec2 size, vec2 pos) {\n    vec2 d = abs(pos - center) - size;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\nfloat softMax(float a, float b, float k) {\n  return log(exp(k * a) + exp(k * b)) / k;\n}\n\nfloat softMin(float a, float b, float k) {\n  return -softMax(-a, -b, k);\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy;\n\n  // make 0 the center\n  uv.x -= iResolution.x * 0.5;\n  uv.y -= iResolution.y * 0.5;\n\n  float u = 1.0; // cat; \n    \n  float t = clamp(u, 0.0, 1.0);\n  \n  gl_FragColor = vec4(mix(shapeColor, backgroundColor, t), 1.0);\n}",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1,\"model\":null,\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "To complete this task you need to recall lessons about SDF rotation, union and subtraction.\n\n### Task\nOver the course of several tasks, we will try to draw the face of a cat. In this task try to draw the shape of the head and ears with animation.\n\n<br>\n\nHead is a circle with an initial radius of 60px. The head radius increases over time to 61 and decreases to 59 pixels.\n\n<br>\n\nEar is the intersection of circles with a radius of 60 pixels and a distance between centers of 70 pixels. The inner part of the ear is 5 pixels below the top of the outer part. The initial angle of the right ear is 0.628, the left ear is -0.628. Over time, the ear rotates an additional 0.1 radian relative to the initial position in one direction and the other.",
                                "hints": [],
                                "restrictions": [],
                                "order": 12,
                                "cost": 10,
                                "threshold": 99,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": true,
                                "animationSteps": 10,
                                "animationStepTime": 500,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nconst vec3 shapeColor      = vec3(1.0, 0.3, 0.3);\nconst vec3 backgroundColor = vec3(0.12);\n\nfloat sdfCircle(vec2 center, float r, vec2 pos) {\n  return distance(center, pos) - r;\n}\n\nfloat sdfBox(vec2 center, vec2 size, vec2 pos) {\n    vec2 d = abs(pos - center) - size;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\nfloat softMax(float a, float b, float k) {\n  return log(exp(k * a) + exp(k * b)) / k;\n}\n\nfloat softMin(float a, float b, float k) {\n  return -softMax(-a, -b, k);\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy;\n\n  // make 0 the center\n  uv.x -= iResolution.x * 0.5;\n  uv.y -= iResolution.y * 0.5;\n\n  float u = 1.0; // cat; \n    \n  float t = clamp(u, 0.0, 1.0);\n  \n  gl_FragColor = vec4(mix(shapeColor, backgroundColor, t), 1.0);\n}",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nconst vec3 shapeColor      = vec3(1.0, 0.3, 0.3);\nconst vec3 backgroundColor = vec3(0.12);\n\nfloat sdfCircle(vec2 center, float r, vec2 pos) {\n  return distance(center, pos) - r;\n}\n\nfloat sdfBox(vec2 center, vec2 size, vec2 pos) {\n    vec2 d = abs(pos - center) - size;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\nfloat softMax(float a, float b, float k) {\n  return log(exp(k * a) + exp(k * b)) / k;\n}\n\nfloat softMin(float a, float b, float k) {\n  return -softMax(-a, -b, k);\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy;\n\n  // make 0 the center\n  uv.x -= iResolution.x * 0.5;\n  uv.y -= iResolution.y * 0.5;\n\n  float u = 1.0; // cat; \n    \n  float t = clamp(u, 0.0, 1.0);\n  \n  gl_FragColor = vec4(mix(shapeColor, backgroundColor, t), 1.0);\n}",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 142,
                        "slug": "sdf-cat-whiskers",
                        "moduleId": 3,
                        "name": "SDF Cat - Whiskers",
                        "order": 13,
                        "cost": 10,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": true,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 142,
                                "slug": "sdf-cat-whiskers",
                                "moduleId": 3,
                                "name": "SDF Cat - Whiskers",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nconst vec3 shapeColor      = vec3(1.0, 0.3, 0.3);\nconst vec3 backgroundColor = vec3(0.12);\n\nfloat sdfCircle(vec2 center, float r, vec2 pos) {\n  return distance(center, pos) - r;\n}\n\nfloat sdfBox(vec2 center, vec2 size, vec2 pos) {\n    vec2 d = abs(pos - center) - size;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\nfloat softMax(float a, float b, float k) {\n  return log(exp(k * a) + exp(k * b)) / k;\n}\n\nfloat softMin(float a, float b, float k) {\n  return -softMax(-a, -b, k);\n}\n\nfloat drawPental(vec2 uv, float r) {\n  vec2 center1 = vec2(-25.0, 0.0) + vec2(+r, +r);\n  vec2 center2 = vec2(+25.0, 0.0) + vec2(-r, +r);\n  \n  float c1 = sdfCircle(center1, r, uv);\n  float c2 = sdfCircle(center2, r, uv);\n\n  return max(c1, c2);\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy;\n\n  // make 0 the center\n  uv.x -= iResolution.x * 0.5;\n  uv.y -= iResolution.y * 0.5;\n\n  float head = sdfCircle(vec2(0.0, 0.0), 60.0 + sin(iTime) * 1.0, uv);\n\n  float angle = 3.14 * 0.2 - (sin(iTime) * 0.1);\n  float x = uv.x * cos(angle) - (uv.y) * sin(angle);\n  float y = uv.x * sin(angle) + (uv.y) * cos(angle);\n  float earOuter1 = drawPental(vec2(x, y), 60.0);\n\n  angle = 3.14 * 0.2 - (sin(iTime) * 0.1);\n  x = uv.x * cos(angle) - (uv.y) * sin(angle);\n  y = uv.x * sin(angle) + (uv.y) * cos(angle);\n  float earInner1 = drawPental(vec2(x, y + 5.0), 60.0);\n\n  angle = 3.14 * -0.2 + (sin(iTime) * 0.1);\n  x = uv.x * cos(angle) - (uv.y) * sin(angle);\n  y = uv.x * sin(angle) + (uv.y) * cos(angle);\n  float earOuter2 = drawPental(vec2(x, y), 60.0);\n\n  angle = 3.14 * -0.2 + (sin(iTime) * 0.1);\n  x = (uv.x) * cos(angle) - (uv.y) * sin(angle);\n  y = (uv.x) * sin(angle) + (uv.y) * cos(angle);\n  float earInner2 = drawPental(vec2(x, y + 5.0), 60.0);\n\n  float ear1 = max(earOuter1, -earInner1);\n  float ear2 = max(earOuter2, -earInner2);\n\n  angle = 3.14 * -0.1 + (sin(iTime) * 0.1);\n  x = (uv.x) * cos(angle) - (uv.y) * sin(angle);\n  y = (uv.x) * sin(angle) + (uv.y) * cos(angle);\n  float whiskers1 = sdfBox(vec2(-60.0, -10.0), vec2(35.0, 1.0), vec2(x, y));\n\n  angle = 3.14 * -0.2 + (sin(iTime) * 0.1);\n  x = (uv.x) * cos(angle) - (uv.y) * sin(angle);\n  y = (uv.x) * sin(angle) + (uv.y) * cos(angle);\n  float whiskers2 = sdfBox(vec2(-60.0, -10.0), vec2(35.0, 1.0), vec2(x, y));\n\n  angle = 3.14 * 0.2 - (sin(iTime) * 0.1);\n  x = (uv.x) * cos(angle) - (uv.y) * sin(angle);\n  y = (uv.x) * sin(angle) + (uv.y) * cos(angle);\n  float whiskers3 = sdfBox(vec2(60.0, -10.0), vec2(35.0, 1.0), vec2(x, y));\n\n  angle = 3.14 * 0.1 - (sin(iTime) * 0.1);\n  x = (uv.x) * cos(angle) - (uv.y) * sin(angle);\n  y = (uv.x) * sin(angle) + (uv.y) * cos(angle);\n  float whiskers4 = sdfBox(vec2(60.0, -10.0), vec2(35.0, 1.0), vec2(x, y));\n\n  float u1 = softMin(head, min(ear1, ear2), 0.25);\n  float u2 = min(max(-whiskers1, u1), max(whiskers1, -u1));\n  float u3 = min(max(-whiskers2, u2), max(whiskers2, -u2));\n  float u4 = min(max(-whiskers3, u3), max(whiskers3, -u3));\n  float u5 = min(max(-whiskers4, u4), max(whiskers4, -u4));\n  \n  float t = clamp(u5, 0.0, 1.0);\n  \n  gl_FragColor = vec4(mix(shapeColor, backgroundColor, t), 1.0);\n}",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nconst vec3 shapeColor      = vec3(1.0, 0.3, 0.3);\nconst vec3 backgroundColor = vec3(0.12);\n\nfloat sdfCircle(vec2 center, float r, vec2 pos) {\n  return distance(center, pos) - r;\n}\n\nfloat sdfBox(vec2 center, vec2 size, vec2 pos) {\n    vec2 d = abs(pos - center) - size;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\nfloat softMax(float a, float b, float k) {\n  return log(exp(k * a) + exp(k * b)) / k;\n}\n\nfloat softMin(float a, float b, float k) {\n  return -softMax(-a, -b, k);\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy;\n\n  // make 0 the center\n  uv.x -= iResolution.x * 0.5;\n  uv.y -= iResolution.y * 0.5;\n\n  float u = 1.0; // cat; \n    \n  float t = clamp(u, 0.0, 1.0);\n  \n  gl_FragColor = vec4(mix(shapeColor, backgroundColor, t), 1.0);\n}",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1,\"model\":null,\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "To complete this task you need to recall lessons about SDF rotation, union and subtraction.\n\n### Task\nTake your code from the previous lesson where we drew the cat's ears. In this task you need to add a cat's whiskers.\n\n<br>\n\nOne cat whisker is 35 pixels long, 1 pixel wide. The initial angle of the upper whisker is 0.314, the lower one is 0.628. Over time, whiskers rotate an additional 0.1 radian relative to the initial position in one direction and the other.\n\n<br>\n\nTranslate left whiskers by -60 on the X-axis and -10 pixels on the Y-axis, right whiskers by 60 and -10 pixels accordingly.\n\n<br>\n\nNote that you are given the implementation of an SDF box.",
                                "hints": [],
                                "restrictions": [],
                                "order": 13,
                                "cost": 10,
                                "threshold": 99,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": true,
                                "animationSteps": 10,
                                "animationStepTime": 500,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nconst vec3 shapeColor      = vec3(1.0, 0.3, 0.3);\nconst vec3 backgroundColor = vec3(0.12);\n\nfloat sdfCircle(vec2 center, float r, vec2 pos) {\n  return distance(center, pos) - r;\n}\n\nfloat sdfBox(vec2 center, vec2 size, vec2 pos) {\n    vec2 d = abs(pos - center) - size;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\nfloat softMax(float a, float b, float k) {\n  return log(exp(k * a) + exp(k * b)) / k;\n}\n\nfloat softMin(float a, float b, float k) {\n  return -softMax(-a, -b, k);\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy;\n\n  // make 0 the center\n  uv.x -= iResolution.x * 0.5;\n  uv.y -= iResolution.y * 0.5;\n\n  float u = 1.0; // cat; \n    \n  float t = clamp(u, 0.0, 1.0);\n  \n  gl_FragColor = vec4(mix(shapeColor, backgroundColor, t), 1.0);\n}",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nconst vec3 shapeColor      = vec3(1.0, 0.3, 0.3);\nconst vec3 backgroundColor = vec3(0.12);\n\nfloat sdfCircle(vec2 center, float r, vec2 pos) {\n  return distance(center, pos) - r;\n}\n\nfloat sdfBox(vec2 center, vec2 size, vec2 pos) {\n    vec2 d = abs(pos - center) - size;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\nfloat softMax(float a, float b, float k) {\n  return log(exp(k * a) + exp(k * b)) / k;\n}\n\nfloat softMin(float a, float b, float k) {\n  return -softMax(-a, -b, k);\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy;\n\n  // make 0 the center\n  uv.x -= iResolution.x * 0.5;\n  uv.y -= iResolution.y * 0.5;\n\n  float u = 1.0; // cat; \n    \n  float t = clamp(u, 0.0, 1.0);\n  \n  gl_FragColor = vec4(mix(shapeColor, backgroundColor, t), 1.0);\n}",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 143,
                        "slug": "sdf-cat-nose-and-cheeks",
                        "moduleId": 3,
                        "name": "SDF Cat - Nose and Cheeks",
                        "order": 14,
                        "cost": 10,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": true,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 143,
                                "slug": "sdf-cat-nose-and-cheeks",
                                "moduleId": 3,
                                "name": "SDF Cat - Nose and Cheeks",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nconst vec3 shapeColor      = vec3(1.0, 0.3, 0.3);\nconst vec3 backgroundColor = vec3(0.12);\n\nfloat sdfCircle(vec2 center, float r, vec2 pos) {\n  return distance(center, pos) - r;\n}\n\nfloat sdfBox(vec2 center, vec2 size, vec2 pos) {\n    vec2 d = abs(pos - center) - size;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\nfloat softMax(float a, float b, float k) {\n  return log(exp(k * a) + exp(k * b)) / k;\n}\n\nfloat softMin(float a, float b, float k) {\n  return -softMax(-a, -b, k);\n}\n\nfloat drawPental(vec2 uv, float r) {\n  vec2 center1 = vec2(-25.0, 0.0) + vec2(+r, +r);\n  vec2 center2 = vec2(+25.0, 0.0) + vec2(-r, +r);\n  \n  float c1 = sdfCircle(center1, r, uv);\n  float c2 = sdfCircle(center2, r, uv);\n\n  return max(c1, c2);\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy;\n\n  // make 0 the center\n  uv.x -= iResolution.x * 0.5;\n  uv.y -= iResolution.y * 0.5;\n\n  float head = sdfCircle(vec2(0.0, 0.0), 60.0 + sin(iTime) * 1.0, uv);\n\n  float angle = 3.14 * 0.2 - (sin(iTime) * 0.1);\n  float x = uv.x * cos(angle) - (uv.y) * sin(angle);\n  float y = uv.x * sin(angle) + (uv.y) * cos(angle);\n  float earOuter1 = drawPental(vec2(x, y), 60.0);\n\n  angle = 3.14 * 0.2 - (sin(iTime) * 0.1);\n  x = uv.x * cos(angle) - (uv.y) * sin(angle);\n  y = uv.x * sin(angle) + (uv.y) * cos(angle);\n  float earInner1 = drawPental(vec2(x, y + 5.0), 60.0);\n\n  angle = 3.14 * -0.2 + (sin(iTime) * 0.1);\n  x = uv.x * cos(angle) - (uv.y) * sin(angle);\n  y = uv.x * sin(angle) + (uv.y) * cos(angle);\n  float earOuter2 = drawPental(vec2(x, y), 60.0);\n\n  angle = 3.14 * -0.2 + (sin(iTime) * 0.1);\n  x = (uv.x) * cos(angle) - (uv.y) * sin(angle);\n  y = (uv.x) * sin(angle) + (uv.y) * cos(angle);\n  float earInner2 = drawPental(vec2(x, y + 5.0), 60.0);\n\n  float ear1 = max(earOuter1, -earInner1);\n  float ear2 = max(earOuter2, -earInner2);\n\n  angle = 3.14 * -0.1 + (sin(iTime) * 0.1);\n  x = (uv.x) * cos(angle) - (uv.y) * sin(angle);\n  y = (uv.x) * sin(angle) + (uv.y) * cos(angle);\n  float whiskers1 = sdfBox(vec2(-60.0, -10.0), vec2(35.0, 1.0), vec2(x, y));\n\n  angle = 3.14 * -0.2 + (sin(iTime) * 0.1);\n  x = (uv.x) * cos(angle) - (uv.y) * sin(angle);\n  y = (uv.x) * sin(angle) + (uv.y) * cos(angle);\n  float whiskers2 = sdfBox(vec2(-60.0, -10.0), vec2(35.0, 1.0), vec2(x, y));\n\n  angle = 3.14 * 0.2 - (sin(iTime) * 0.1);\n  x = (uv.x) * cos(angle) - (uv.y) * sin(angle);\n  y = (uv.x) * sin(angle) + (uv.y) * cos(angle);\n  float whiskers3 = sdfBox(vec2(60.0, -10.0), vec2(35.0, 1.0), vec2(x, y));\n\n  angle = 3.14 * 0.1 - (sin(iTime) * 0.1);\n  x = (uv.x) * cos(angle) - (uv.y) * sin(angle);\n  y = (uv.x) * sin(angle) + (uv.y) * cos(angle);\n  float whiskers4 = sdfBox(vec2(60.0, -10.0), vec2(35.0, 1.0), vec2(x, y));\n\n  float nose1 = sdfCircle(vec2(-10.0, -14.0 + sin(iTime) * 2.0), 11.0, uv);\n  float nose2 = sdfCircle(vec2(+10.0, -14.0 + sin(iTime) * 2.0), 11.0, uv);\n  float nose3 = sdfCircle(vec2(0.0, -7.0 + sin(iTime) * 2.0), 10.0, uv);\n\n  float cheek1 = sdfCircle(vec2(+12.0 + sin(iTime) * 2.0, -20.0 + sin(iTime) * 2.0), 15.0, uv);\n  float cheek2 = sdfCircle(vec2(+10.0 + sin(iTime) * 2.0, -18.0 + sin(iTime) * 2.0), 15.0, uv);\n\n  float cheek3 = sdfCircle(vec2(-12.0 - sin(iTime) * 2.0, -20.0 + sin(iTime) * 2.0), 15.0, uv);\n  float cheek4 = sdfCircle(vec2(-10.0 - sin(iTime) * 2.0, -18.0 + sin(iTime) * 2.0), 15.0, uv);\n\n  float u1 = softMin(head, min(ear1, ear2), 0.25);\n  float u2 = min(max(-whiskers1, u1), max(whiskers1, -u1));\n  float u3 = min(max(-whiskers2, u2), max(whiskers2, -u2));\n  float u4 = min(max(-whiskers3, u3), max(whiskers3, -u3));\n  float u5 = min(max(-whiskers4, u4), max(whiskers4, -u4));\n  float u6 = max(u5, -max(nose3, -min(nose1, nose2)));\n  float u7 = softMax(u6, -max(cheek1, -cheek2), 0.9);\n  float u8 = softMax(u7, -max(cheek3, -cheek4), 0.9);\n  \n  float t = clamp(u8, 0.0, 1.0);\n  \n  gl_FragColor = vec4(mix(shapeColor, backgroundColor, t), 1.0);\n}",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nconst vec3 shapeColor      = vec3(1.0, 0.3, 0.3);\nconst vec3 backgroundColor = vec3(0.12);\n\nfloat sdfCircle(vec2 center, float r, vec2 pos) {\n  return distance(center, pos) - r;\n}\n\nfloat sdfBox(vec2 center, vec2 size, vec2 pos) {\n    vec2 d = abs(pos - center) - size;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\nfloat softMax(float a, float b, float k) {\n  return log(exp(k * a) + exp(k * b)) / k;\n}\n\nfloat softMin(float a, float b, float k) {\n  return -softMax(-a, -b, k);\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy;\n\n  // make 0 the center\n  uv.x -= iResolution.x * 0.5;\n  uv.y -= iResolution.y * 0.5;\n\n  float u = 1.0; // cat; \n    \n  float t = clamp(u, 0.0, 1.0);\n  \n  gl_FragColor = vec4(mix(shapeColor, backgroundColor, t), 1.0);\n}",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1,\"model\":null,\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "To complete this task you need to recall lessons about SDF union and subtraction.\n\n### Task\nIn this task you need to add a cat's nose and cheeks.\n\n<br>\n\nThe outline of one cheek is made through the combintaion of two circles with a radius of 15 pixels, where the second circle is shifted by 2 pixels along the X and Y axis. The coordinates of the center of the outer circle are (12; -20). Also, the cheeks move over time up by 2 pixels and down relative to the initial position.\n\n<br>\n\nThe nose is a combination of three circles with centers at (-10; -14), (-10; -14) and (0; -7). And with radii 11, 11 and 10. The nose moves over time up 2 pixels and down relative to the initial position.",
                                "hints": [],
                                "restrictions": [],
                                "order": 14,
                                "cost": 10,
                                "threshold": 99,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": true,
                                "animationSteps": 10,
                                "animationStepTime": 500,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nconst vec3 shapeColor      = vec3(1.0, 0.3, 0.3);\nconst vec3 backgroundColor = vec3(0.12);\n\nfloat sdfCircle(vec2 center, float r, vec2 pos) {\n  return distance(center, pos) - r;\n}\n\nfloat sdfBox(vec2 center, vec2 size, vec2 pos) {\n    vec2 d = abs(pos - center) - size;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\nfloat softMax(float a, float b, float k) {\n  return log(exp(k * a) + exp(k * b)) / k;\n}\n\nfloat softMin(float a, float b, float k) {\n  return -softMax(-a, -b, k);\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy;\n\n  // make 0 the center\n  uv.x -= iResolution.x * 0.5;\n  uv.y -= iResolution.y * 0.5;\n\n  float u = 1.0; // cat; \n    \n  float t = clamp(u, 0.0, 1.0);\n  \n  gl_FragColor = vec4(mix(shapeColor, backgroundColor, t), 1.0);\n}",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nconst vec3 shapeColor      = vec3(1.0, 0.3, 0.3);\nconst vec3 backgroundColor = vec3(0.12);\n\nfloat sdfCircle(vec2 center, float r, vec2 pos) {\n  return distance(center, pos) - r;\n}\n\nfloat sdfBox(vec2 center, vec2 size, vec2 pos) {\n    vec2 d = abs(pos - center) - size;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\nfloat softMax(float a, float b, float k) {\n  return log(exp(k * a) + exp(k * b)) / k;\n}\n\nfloat softMin(float a, float b, float k) {\n  return -softMax(-a, -b, k);\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy;\n\n  // make 0 the center\n  uv.x -= iResolution.x * 0.5;\n  uv.y -= iResolution.y * 0.5;\n\n  float u = 1.0; // cat; \n    \n  float t = clamp(u, 0.0, 1.0);\n  \n  gl_FragColor = vec4(mix(shapeColor, backgroundColor, t), 1.0);\n}",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 140,
                        "slug": "sdf-cat-eyes",
                        "moduleId": 3,
                        "name": "SDF Cat - Eyes",
                        "order": 15,
                        "cost": 10,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": true,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 140,
                                "slug": "sdf-cat-eyes",
                                "moduleId": 3,
                                "name": "SDF Cat - Eyes",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nconst vec3 shapeColor      = vec3(1.0, 0.3, 0.3);\nconst vec3 backgroundColor = vec3(0.12);\n\nfloat sdfCircle(vec2 center, float r, vec2 pos) {\n  return distance(center, pos) - r;\n}\n\nfloat sdfBox(vec2 center, vec2 size, vec2 pos) {\n    vec2 d = abs(pos - center) - size;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\nfloat softMax(float a, float b, float k) {\n  return log(exp(k * a) + exp(k * b)) / k;\n}\n\nfloat softMin(float a, float b, float k) {\n  return -softMax(-a, -b, k);\n}\n\nfloat drawPental(vec2 uv, float r) {\n  vec2 center1 = vec2(-25.0, 0.0) + vec2(+r, +r);\n  vec2 center2 = vec2(+25.0, 0.0) + vec2(-r, +r);\n  \n  float c1 = sdfCircle(center1, r, uv);\n  float c2 = sdfCircle(center2, r, uv);\n\n  return max(c1, c2);\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy;\n\n  // make 0 the center\n  uv.x -= iResolution.x * 0.5;\n  uv.y -= iResolution.y * 0.5;\n\n  float head = sdfCircle(vec2(0.0, 0.0), 60.0 + sin(iTime) * 1.0, uv);\n\n  float angle = 3.14 * 0.2 - (sin(iTime) * 0.1);\n  float x = uv.x * cos(angle) - (uv.y) * sin(angle);\n  float y = uv.x * sin(angle) + (uv.y) * cos(angle);\n  float earOuter1 = drawPental(vec2(x, y), 60.0);\n\n  angle = 3.14 * 0.2 - (sin(iTime) * 0.1);\n  x = uv.x * cos(angle) - (uv.y) * sin(angle);\n  y = uv.x * sin(angle) + (uv.y) * cos(angle);\n  float earInner1 = drawPental(vec2(x, y + 5.0), 60.0);\n\n  angle = 3.14 * -0.2 + (sin(iTime) * 0.1);\n  x = uv.x * cos(angle) - (uv.y) * sin(angle);\n  y = uv.x * sin(angle) + (uv.y) * cos(angle);\n  float earOuter2 = drawPental(vec2(x, y), 60.0);\n\n  angle = 3.14 * -0.2 + (sin(iTime) * 0.1);\n  x = (uv.x) * cos(angle) - (uv.y) * sin(angle);\n  y = (uv.x) * sin(angle) + (uv.y) * cos(angle);\n  float earInner2 = drawPental(vec2(x, y + 5.0), 60.0);\n\n  float ear1 = max(earOuter1, -earInner1);\n  float ear2 = max(earOuter2, -earInner2);\n\n  angle = 3.14 * -0.1 + (sin(iTime) * 0.1);\n  x = (uv.x) * cos(angle) - (uv.y) * sin(angle);\n  y = (uv.x) * sin(angle) + (uv.y) * cos(angle);\n  float whiskers1 = sdfBox(vec2(-60.0, -10.0), vec2(35.0, 1.0), vec2(x, y));\n\n  angle = 3.14 * -0.2 + (sin(iTime) * 0.1);\n  x = (uv.x) * cos(angle) - (uv.y) * sin(angle);\n  y = (uv.x) * sin(angle) + (uv.y) * cos(angle);\n  float whiskers2 = sdfBox(vec2(-60.0, -10.0), vec2(35.0, 1.0), vec2(x, y));\n\n  angle = 3.14 * 0.2 - (sin(iTime) * 0.1);\n  x = (uv.x) * cos(angle) - (uv.y) * sin(angle);\n  y = (uv.x) * sin(angle) + (uv.y) * cos(angle);\n  float whiskers3 = sdfBox(vec2(60.0, -10.0), vec2(35.0, 1.0), vec2(x, y));\n\n  angle = 3.14 * 0.1 - (sin(iTime) * 0.1);\n  x = (uv.x) * cos(angle) - (uv.y) * sin(angle);\n  y = (uv.x) * sin(angle) + (uv.y) * cos(angle);\n  float whiskers4 = sdfBox(vec2(60.0, -10.0), vec2(35.0, 1.0), vec2(x, y));\n\n  float nose1 = sdfCircle(vec2(-10.0, -14.0 + sin(iTime) * 2.0), 11.0, uv);\n  float nose2 = sdfCircle(vec2(+10.0, -14.0 + sin(iTime) * 2.0), 11.0, uv);\n  float nose3 = sdfCircle(vec2(0.0, -7.0 + sin(iTime) * 2.0), 10.0, uv);\n\n  float cheek1 = sdfCircle(vec2(+12.0 + sin(iTime) * 2.0, -20.0 + sin(iTime) * 2.0), 15.0, uv);\n  float cheek2 = sdfCircle(vec2(+10.0 + sin(iTime) * 2.0, -18.0 + sin(iTime) * 2.0), 15.0, uv);\n\n  float cheek3 = sdfCircle(vec2(-12.0 - sin(iTime) * 2.0, -20.0 + sin(iTime) * 2.0), 15.0, uv);\n  float cheek4 = sdfCircle(vec2(-10.0 - sin(iTime) * 2.0, -18.0 + sin(iTime) * 2.0), 15.0, uv);\n\n  float eye1 = sdfCircle(vec2(-20.0, 20.0 + sin(iTime) * 2.0), 15.0, uv);\n  float eye2 = sdfCircle(vec2(-25.0, 25.0), 15.0, uv);\n\n  float eye3 = sdfCircle(vec2(20.0, 20.0 + sin(iTime) * 2.0), 15.0, uv);\n  float eye4 = sdfCircle(vec2(25.0, 25.0), 15.0, uv);\n\n  float pupil1 = sdfCircle(vec2(-10.0 - sin(iTime), 22.0), 15.0, uv);\n  float pupil2 = sdfCircle(vec2(-32.0 + sin(iTime), 22.0), 15.0, uv);\n\n  float pupil3 = sdfCircle(vec2(10.0 + sin(iTime), 22.0), 15.0, uv);\n  float pupil4 = sdfCircle(vec2(32.0 - sin(iTime), 22.0), 15.0, uv);\n\n  float u1 = softMin(head, min(ear1, ear2), 0.25);\n  float u2 = min(max(-whiskers1, u1), max(whiskers1, -u1));\n  float u3 = min(max(-whiskers2, u2), max(whiskers2, -u2));\n  float u4 = min(max(-whiskers3, u3), max(whiskers3, -u3));\n  float u5 = min(max(-whiskers4, u4), max(whiskers4, -u4));\n  float u6 = max(u5, -max(nose3, -min(nose1, nose2)));\n  float u7 = softMax(u6, -max(cheek1, -cheek2), 0.9);\n  float u8 = softMax(u7, -max(cheek3, -cheek4), 0.9);\n  float u9 = max(u8, -max(eye1, eye2));\n  float u10 = max(u9, -max(eye3, eye4));\n  float u11 = min(u10, max(pupil1, pupil2));\n  float u12 = min(u11, max(pupil3, pupil4));\n  \n  float t = clamp(u12, 0.0, 1.0);\n  \n  gl_FragColor = vec4(mix(shapeColor, backgroundColor, t), 1.0);\n}",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}",
                                "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nconst vec3 shapeColor      = vec3(1.0, 0.3, 0.3);\nconst vec3 backgroundColor = vec3(0.12);\n\nfloat sdfCircle(vec2 center, float r, vec2 pos) {\n  return distance(center, pos) - r;\n}\n\nfloat sdfBox(vec2 center, vec2 size, vec2 pos) {\n    vec2 d = abs(pos - center) - size;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\nfloat softMax(float a, float b, float k) {\n  return log(exp(k * a) + exp(k * b)) / k;\n}\n\nfloat softMin(float a, float b, float k) {\n  return -softMax(-a, -b, k);\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy;\n\n  // make 0 the center\n  uv.x -= iResolution.x * 0.5;\n  uv.y -= iResolution.y * 0.5;\n\n  float u = 1.0; // cat; \n    \n  float t = clamp(u, 0.0, 1.0);\n  \n  gl_FragColor = vec4(mix(shapeColor, backgroundColor, t), 1.0);\n}",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1,\"model\":null,\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "### Task\nWe're almost done. All that remains is to add the eyes with pupils.\n\n<br>\n\nCat's eye is a combination of two circles with a radius of 15 pixels. The center of the first circle is located at (20.0, 20.0), the second at (25.0, 25.0). Also the top one moves up 2 pixels and down relative to the initial position.\n\n<br>\n\nThe pupil is also a combination of two circles with a radius of 15 pixels. The center of the first circle is located at (10.0, 22.0), the second at (32.0, 22.0). The circles move closer by 2 pixels and move away over time.",
                                "hints": [],
                                "restrictions": [],
                                "order": 15,
                                "cost": 10,
                                "threshold": 99,
                                "likes": 1,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": true,
                                "animationSteps": 10,
                                "animationStepTime": 500,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}",
                            "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nconst vec3 shapeColor      = vec3(1.0, 0.3, 0.3);\nconst vec3 backgroundColor = vec3(0.12);\n\nfloat sdfCircle(vec2 center, float r, vec2 pos) {\n  return distance(center, pos) - r;\n}\n\nfloat sdfBox(vec2 center, vec2 size, vec2 pos) {\n    vec2 d = abs(pos - center) - size;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\nfloat softMax(float a, float b, float k) {\n  return log(exp(k * a) + exp(k * b)) / k;\n}\n\nfloat softMin(float a, float b, float k) {\n  return -softMax(-a, -b, k);\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy;\n\n  // make 0 the center\n  uv.x -= iResolution.x * 0.5;\n  uv.y -= iResolution.y * 0.5;\n\n  float u = 1.0; // cat; \n    \n  float t = clamp(u, 0.0, 1.0);\n  \n  gl_FragColor = vec4(mix(shapeColor, backgroundColor, t), 1.0);\n}",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}",
                            "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nconst vec3 shapeColor      = vec3(1.0, 0.3, 0.3);\nconst vec3 backgroundColor = vec3(0.12);\n\nfloat sdfCircle(vec2 center, float r, vec2 pos) {\n  return distance(center, pos) - r;\n}\n\nfloat sdfBox(vec2 center, vec2 size, vec2 pos) {\n    vec2 d = abs(pos - center) - size;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\nfloat softMax(float a, float b, float k) {\n  return log(exp(k * a) + exp(k * b)) / k;\n}\n\nfloat softMin(float a, float b, float k) {\n  return -softMax(-a, -b, k);\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy;\n\n  // make 0 the center\n  uv.x -= iResolution.x * 0.5;\n  uv.y -= iResolution.y * 0.5;\n\n  float u = 1.0; // cat; \n    \n  float t = clamp(u, 0.0, 1.0);\n  \n  gl_FragColor = vec4(mix(shapeColor, backgroundColor, t), 1.0);\n}",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 139,
                        "slug": "sdf-box-blur",
                        "moduleId": 3,
                        "name": "SDF Box Blur",
                        "order": 16,
                        "cost": 10,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": true,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 139,
                                "slug": "sdf-box-blur",
                                "moduleId": 3,
                                "name": "SDF Box Blur",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\n\nconst vec3 shapeColor      = vec3(1.0, 0.3, 0.3);\nconst vec3 backgroundColor = vec3(0.12);\n\nfloat sdfCircle(vec2 center, float r, vec2 pos) {\n  return distance(center, pos) - r;\n}\n\nfloat drawCircle(vec2 pos) {\n  float t = sdfCircle(iResolution * 0.5, iResolution.y * 0.4, pos);\n  return t;\n}\n\nfloat blurSDF(vec2 pos) {\n  float sum = 0.0;\n  \n  for (int i = -5; i <= 5; i++)\n  {\n    for (int j = -5; j <= 5; j++)\n    {\n      vec2 offset = vec2(float(i), float(j)) * 2.0;\n      float sdf = drawCircle(pos + offset);\n      sum += clamp(sdf, 0.0, 1.0);\n    }\n  }\n  \n  return sum / (121.0);\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy;\n\n  float t = blurSDF(uv);\n  t = clamp(t, 0.0, 1.0);\n  \n  gl_FragColor = vec4(mix(shapeColor, backgroundColor, t), 1.0);\n}",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\n\nconst vec3 shapeColor      = vec3(1.0, 0.3, 0.3);\nconst vec3 backgroundColor = vec3(0.12);\n\nfloat sdfCircle(vec2 center, float r, vec2 pos) {\n  return distance(center, pos) - r;\n}\n\nfloat drawCircle(vec2 pos) {\n  float t = sdfCircle(iResolution * 0.5, iResolution.y * 0.4, pos);\n  return t;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy;\n\n  float t = drawCircle(uv);\n  t = clamp(t, 0.0, 1.0);\n  \n  gl_FragColor = vec4(mix(shapeColor, backgroundColor, t), 1.0);\n}",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"object\":{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1},\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "Box blur is a simple image processing algorithm that can be used to smooth out an image by reducing the high-frequency noise and sharp edges. The algorithm works by averaging the color values of neighboring pixels within a window of a specified size.\n\n<br>\n\nHere are the steps to implement a box blur:\n\n1. Define the size of the blur window. For example, if you want to apply a 3x3 blur, the window size will be 3.\n\n2. Calculate the total number of pixels in the window by squaring the window size. In this example, the total number of pixels will be 9.\n\n3. For each pixel in the image, calculate the average color value of all the pixels within the window. To do this, add up the color values of all the pixels in the window and divide by the total number of pixels.\n\n### Task\nApply a box blur effect to the SDF shape using a window size of 11. \n\n<br>\n\nTo enhance the blur effect, when determining the position of an adjacent pixel in the window, multiply the offset relative to the current pixel by 2.",
                                "hints": [],
                                "restrictions": [],
                                "order": 16,
                                "cost": 10,
                                "threshold": 98,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\n\nconst vec3 shapeColor      = vec3(1.0, 0.3, 0.3);\nconst vec3 backgroundColor = vec3(0.12);\n\nfloat sdfCircle(vec2 center, float r, vec2 pos) {\n  return distance(center, pos) - r;\n}\n\nfloat drawCircle(vec2 pos) {\n  float t = sdfCircle(iResolution * 0.5, iResolution.y * 0.4, pos);\n  return t;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy;\n\n  float t = drawCircle(uv);\n  t = clamp(t, 0.0, 1.0);\n  \n  gl_FragColor = vec4(mix(shapeColor, backgroundColor, t), 1.0);\n}",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\n\nconst vec3 shapeColor      = vec3(1.0, 0.3, 0.3);\nconst vec3 backgroundColor = vec3(0.12);\n\nfloat sdfCircle(vec2 center, float r, vec2 pos) {\n  return distance(center, pos) - r;\n}\n\nfloat drawCircle(vec2 pos) {\n  float t = sdfCircle(iResolution * 0.5, iResolution.y * 0.4, pos);\n  return t;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy;\n\n  float t = drawCircle(uv);\n  t = clamp(t, 0.0, 1.0);\n  \n  gl_FragColor = vec4(mix(shapeColor, backgroundColor, t), 1.0);\n}",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    }
                ],
                "cover": true,
                "pageHeaderImage": true,
                "fullDesc": "This module is designed for developers who want to master the use of Signed Distance Fields (SDF) in computer graphics. You will study distance functions for rendering smooth and detailed shapes, and learn the formulas for combining these functions to build more complex shapes. Each topic includes theoretical material and practical tasks that can be completed directly on the website.",
                "skillsDesc": "the concept of Signed Distance Fields and their applications in computer graphics.<br>various distance functions for rendering smooth and detailed shapes.<br>the formulas for combining distance functions to create complex shapes.<br>how to apply these techniques to render high-quality and detailed graphics in 2D.",
                "importanceDesc": "Signed Distance Fields are crucial for creating smooth and detailed shapes in computer graphics. Understanding how to use distance functions allows developers to render shapes with high precision and flexibility. Knowledge of combining these functions enables the creation of complex and intricate designs, which is essential for advanced graphics applications such as games, simulations, and visual effects.",
                "certifiable": false,
                "images": [
                    "img-1.png",
                    "img-2.png",
                    "img-3.png",
                    "img-4.png"
                ]
            }
        },
        {
            "id": 8,
            "slug": "noise",
            "name": "Noise",
            "description": "Explore various noise algorithms and their applications in creating visual effects.",
            "tasks": 19,
            "acceptedTasks": 0,
            "isOpen": false,
            "order": 6,
            "locked": false,
            "cover": true,
            "child": {
                "id": 8,
                "slug": "noise",
                "name": "Noise",
                "description": "Explore various noise algorithms and their applications in creating visual effects.",
                "order": 6,
                "createdBy": {
                    "id": 3,
                    "name": "Alexander"
                },
                "locked": false,
                "tasks": [
                    {
                        "id": 78,
                        "slug": "random-1d",
                        "moduleId": 8,
                        "name": "Random 1D",
                        "order": 0,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": 0,
                        "premium": false,
                        "child": {
                            "task": {
                                "id": 78,
                                "slug": "random-1d",
                                "moduleId": 8,
                                "name": "Random 1D",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\n\nfloat random(float x) {\n   float r = fract(sin(x * 12.34) * 1234.5678);\n   return r * 2.0 - 1.0;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  float noiseValue = random(uv.x);\n  noiseValue = noiseValue * 0.5 + 0.5;\n\n  gl_FragColor = vec4(vec3(noiseValue), 1.0);\n}",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\n\nfloat random(float x) {\n   return 0.0;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  float noiseValue = random(uv.x);\n  noiseValue = noiseValue * 0.5 + 0.5;\n\n  gl_FragColor = vec4(vec3(noiseValue), 1.0);\n}\n",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1,\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "Using the `sin` and `fract` functions to generate pseudo-random values in shaders is based on their mathematical properties, which allow for creating sufficiently chaotic and unpredictable results.\n\n<br>\n\n### The sin Function\n\n<br>\n\nThe `sin` function has several important properties that make it useful for generating pseudo-random numbers:\n\n<br>\n\n**Sensitivity to Input Changes**: The `sin` function is highly sensitive to changes in its input. Even small variations in the input can lead to significant changes in the output. This sensitivity is crucial for generating chaotic and unpredictable values. For example, if you slightly change the input value, the output of the sine function can vary dramatically, which helps in creating a more random-like distribution of values.\n\n<br>\n\n**Periodicity**: The `sin` function is periodic, meaning it repeats at regular intervals. This property can be used to create repeating but complex patterns.\n\n<br>\n\n### The fract Function\n\n<br>\n\nThe `fract` function helps limit the values returned by the `sin` function to the range from `0.0` to `1.0`, which is convenient for use in shaders. Keep in mind that the result of `fract` is always positive:\n\n```\nif (x >= 0.0)\n  return x - floor(x)\nelse\n  return x - ceil(x)\n```\n\nAlthough `fract` limits the values, it does not destroy the randomness created by previous operations. This is because the fractional part of a number retains the chaotic and unpredictable nature embedded in the original value.\n\n<br>\n\n### Multipliers\n\n<br>\n\nThe large multiplier (e.g., 1234.5678) used after the `sin` function further amplifies the sensitivity to input changes. This large number ensures that even small differences in the input coordinates result in significantly different outputs after applying the `sin` function. This amplification is crucial for achieving a high degree of randomness.\n\n<br>\n\n### Example\n\n<br>\n\nLet’s consider an example function that uses `sin` and `fract` to generate pseudo-random numbers:\n\n```\nfloat random(float x) {\n    return fract(sin(x * 12.34) * 1234.5678);\n}\n```\n\n**Input Data**: The value `x`, which can be pixel coordinates or any other values.\n\n**Multipliers**: The constants `12.34` and `1234.5678` are chosen empirically to create more chaotic results.\n\n**The sin Function**: Applied to the result of the multiplication to create a chaotic value.\n\n**The fract Function**: Limits the result to the range from `0.0` to `1.0`.\n\n### Task\nIn a shader program, implement the `random` function that generates a pseudo-random value in the range of `[-1, 1]` for a given input using a sine wave. Use the value `12.34` as the multiplier for the sine argument and `1234.5678` as the multiplier for the sine output.",
                                "hints": [],
                                "restrictions": [],
                                "order": 0,
                                "cost": 5,
                                "threshold": 95,
                                "likes": 2,
                                "dislikes": 4,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": false
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\n\nfloat random(float x) {\n   return 0.0;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  float noiseValue = random(uv.x);\n  noiseValue = noiseValue * 0.5 + 0.5;\n\n  gl_FragColor = vec4(vec3(noiseValue), 1.0);\n}\n",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\n\nfloat random(float x) {\n   return 0.0;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  float noiseValue = random(uv.x);\n  noiseValue = noiseValue * 0.5 + 0.5;\n\n  gl_FragColor = vec4(vec3(noiseValue), 1.0);\n}\n",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 178,
                        "slug": "random-ranges",
                        "moduleId": 8,
                        "name": "Random Ranges",
                        "order": 1,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": 0,
                        "premium": false,
                        "child": {
                            "task": {
                                "id": 178,
                                "slug": "random-ranges",
                                "moduleId": 8,
                                "name": "Random Ranges",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\n// returns: [0.0, 1.0];\nfloat random(float x) {\n   float r = fract(sin(x * 12.34) * 1234.5678);\n   return r;\n}\n\nvoid main() {\n  vec2 ratio = vec2(iResolution.x / iResolution.y, 1.0);\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  uv *= ratio;\n\n  float time = iTime * 0.75;\n  int particlesCount = 10;\n  float spawnDelta = 1.0 / float(particlesCount);\n  float size0 = 0.4;\n  float size1 = 0.0;\n  vec2 dir0 = vec2(0.3, 1.0);\n  vec2 dir1 = vec2(-0.3, 1.0);\n  vec2 startPos = vec2(0.5, 0.1) * ratio;\n  vec3 color0 = vec3(1.0, 0.5, 0.0);\n  vec3 color1 = vec3(1.0, 0.0, 0.0);\n  \n  vec3 result = vec3(0.0);\n  for (int i = 0; i < particlesCount; i++) {\n    float progress = fract(time + float(i) * spawnDelta);\n    \n    float rand = random(float(i));\n    vec2  dir  = mix(dir0, dir1, rand);\n\n    vec2  pos = startPos + dir * progress;\n    float size  = mix(size0, size1, progress);\n    vec3  color = mix(color0, color1, progress);\n    \n    float t = 1.0 - smoothstep(0.0, size, distance(uv, pos));\n    result += color * t;\n  }\n\n  gl_FragColor = vec4(result, 1.0);\n}",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\n// returns: [0.0, 1.0];\nfloat random(float x) {\n   float r = fract(sin(x * 12.34) * 1234.5678);\n   return r;\n}\n\nvoid main() {\n  vec2 ratio = vec2(iResolution.x / iResolution.y, 1.0);\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  uv *= ratio;\n\n  float time = iTime * 0.75;\n  int particlesCount = 10;\n  float spawnDelta = 1.0 / float(particlesCount);\n  float size0 = 0.4;\n  float size1 = 0.0;\n  vec2 dir0 = vec2(0.3, 1.0);\n  vec2 dir1 = vec2(-0.3, 1.0);\n  vec3 color0 = vec3(1.0, 0.5, 0.0);\n  vec3 color1 = vec3(1.0, 0.0, 0.0);\n  \n  vec3 result = vec3(0.0);\n  for (int i = 0; i < particlesCount; i++) {\n    float progress = fract(time + float(i) * spawnDelta);\n\n    // change position\n    vec2 pos = vec2(0.5) * ratio;\n    \n    float size  = mix(size0, size1, progress);\n    vec3  color = mix(color0, color1, progress);\n    \n    float t = 1.0 - smoothstep(0.0, size, distance(uv, pos));\n    result += color * t;\n  }\n\n  gl_FragColor = vec4(result, 1.0);\n}",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1,\"colorRGBA\":\"FFFFFF\",\"color\":16777215}],\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "Interpolation can be used to generate random values within a specified range. The values within the range can be of different types, such as colors, directions, positions, or any other parameters. \n\n<br>\n\nTo generate a random value in the range `[V0, V1]`, we can use a random value that varies between 0 and 1 as the interpolation parameter:\n```\nV = mix(V0, V1, random());\n```\n\n### Task\n\nGiven code that generates particles every few milliseconds in the centre of the screen. \n\n<br>\n\nChange the code so that the particles appear at `(0.5, 0.1)` and move randomly between two directions (`dir0` and `dir1`). Use the sequence number of the particle to get a random parameter.",
                                "hints": [],
                                "restrictions": [],
                                "order": 1,
                                "cost": 5,
                                "threshold": 99,
                                "likes": 1,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": true,
                                "animationSteps": 10,
                                "animationStepTime": 100,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": false
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\n// returns: [0.0, 1.0];\nfloat random(float x) {\n   float r = fract(sin(x * 12.34) * 1234.5678);\n   return r;\n}\n\nvoid main() {\n  vec2 ratio = vec2(iResolution.x / iResolution.y, 1.0);\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  uv *= ratio;\n\n  float time = iTime * 0.75;\n  int particlesCount = 10;\n  float spawnDelta = 1.0 / float(particlesCount);\n  float size0 = 0.4;\n  float size1 = 0.0;\n  vec2 dir0 = vec2(0.3, 1.0);\n  vec2 dir1 = vec2(-0.3, 1.0);\n  vec3 color0 = vec3(1.0, 0.5, 0.0);\n  vec3 color1 = vec3(1.0, 0.0, 0.0);\n  \n  vec3 result = vec3(0.0);\n  for (int i = 0; i < particlesCount; i++) {\n    float progress = fract(time + float(i) * spawnDelta);\n\n    // change position\n    vec2 pos = vec2(0.5) * ratio;\n    \n    float size  = mix(size0, size1, progress);\n    vec3  color = mix(color0, color1, progress);\n    \n    float t = 1.0 - smoothstep(0.0, size, distance(uv, pos));\n    result += color * t;\n  }\n\n  gl_FragColor = vec4(result, 1.0);\n}",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\n// returns: [0.0, 1.0];\nfloat random(float x) {\n   float r = fract(sin(x * 12.34) * 1234.5678);\n   return r;\n}\n\nvoid main() {\n  vec2 ratio = vec2(iResolution.x / iResolution.y, 1.0);\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  uv *= ratio;\n\n  float time = iTime * 0.75;\n  int particlesCount = 10;\n  float spawnDelta = 1.0 / float(particlesCount);\n  float size0 = 0.4;\n  float size1 = 0.0;\n  vec2 dir0 = vec2(0.3, 1.0);\n  vec2 dir1 = vec2(-0.3, 1.0);\n  vec3 color0 = vec3(1.0, 0.5, 0.0);\n  vec3 color1 = vec3(1.0, 0.0, 0.0);\n  \n  vec3 result = vec3(0.0);\n  for (int i = 0; i < particlesCount; i++) {\n    float progress = fract(time + float(i) * spawnDelta);\n\n    // change position\n    vec2 pos = vec2(0.5) * ratio;\n    \n    float size  = mix(size0, size1, progress);\n    vec3  color = mix(color0, color1, progress);\n    \n    float t = 1.0 - smoothstep(0.0, size, distance(uv, pos));\n    result += color * t;\n  }\n\n  gl_FragColor = vec4(result, 1.0);\n}",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 79,
                        "slug": "random-2d",
                        "moduleId": 8,
                        "name": "Random 2D",
                        "order": 2,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 79,
                                "slug": "random-2d",
                                "moduleId": 8,
                                "name": "Random 2D",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\n\nfloat random(vec2 point){\n  float d = dot(point, vec2(12.34, 56.78));\n  float r = fract(sin(d) * 1234.5678);\n  r = r * 2.0 - 1.0; \n  return r;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  float noiseValue = random(uv);\n  noiseValue = noiseValue * 0.5 + 0.5;\n\n  gl_FragColor = vec4(vec3(noiseValue), 1.0);\n}",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "\nuniform vec2 iResolution;\n\nfloat random(vec2 point){\n  return 0.0;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  float noiseValue = random(uv);\n  noiseValue = noiseValue * 0.5 + 0.5;\n\n  gl_FragColor = vec4(vec3(noiseValue), 1.0);\n}\n",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1,\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "Using the `dot` product to create a single value from two input coordinates is a common technique in shader programming to generate pseudo-random values.\n\n<br>\n\n### Understanding the Dot Product\n\n<br>\n\nThe `dot` product of two vectors is a mathematical operation that takes two equal-length sequences of numbers (usually coordinate vectors) and returns a single number. The `dot` product of two vectors **A** and **B** is defined as:\n\n```\nA · B = ax * bx + ay * by\n```\n\nWhere **ax** and **ay** are the components of vector **A**, and **bx** and **by** are the components of vector **B**.\n\n<br>\n\n### Why Use the Dot Product for Random Values?\n\n<br>\n\nThe `dot` product is useful for generating pseudo-random values because it combines the input coordinates in a way that is sensitive to changes in those coordinates. This sensitivity helps create a more varied and unpredictable result, which is essential for randomness.\n\n<br>\n\n### Example\n\n```\nfloat random(vec2 point) {\n    return fract(sin(dot(point, vec2(12.34, 56.78))) * 1234.5678);\n}\n```\n\nThe `dot` product of the input coordinates with a vector of constants (e.g., `vec2(12.34, 56.78)`) helps to create a single value from two input coordinates.\n\n### Task\nYour task is to implement the `random` function that generates a random value in the range of [-1, 1] for a two-dimensional point by calculating its dot product with the constant vector `(12.34, 56.78)`. Then, you need to use `1234.5678` as the multiplier for the sine output and apply the `fract` function to limit the result to the range ([0, 1]).",
                                "hints": [],
                                "restrictions": [],
                                "order": 2,
                                "cost": 5,
                                "threshold": 95,
                                "likes": 1,
                                "dislikes": 2,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "\nuniform vec2 iResolution;\n\nfloat random(vec2 point){\n  return 0.0;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  float noiseValue = random(uv);\n  noiseValue = noiseValue * 0.5 + 0.5;\n\n  gl_FragColor = vec4(vec3(noiseValue), 1.0);\n}\n",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "\nuniform vec2 iResolution;\n\nfloat random(vec2 point){\n  return 0.0;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  float noiseValue = random(uv);\n  noiseValue = noiseValue * 0.5 + 0.5;\n\n  gl_FragColor = vec4(vec3(noiseValue), 1.0);\n}\n",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 179,
                        "slug": "random-detalization",
                        "moduleId": 8,
                        "name": "Random Detalization",
                        "order": 3,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 179,
                                "slug": "random-detalization",
                                "moduleId": 8,
                                "name": "Random Detalization",
                                "vertexShader": "uniform float iTime;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nmat4 getModel() {\n  float angle = iTime;\n  \n  vec4 r1 = vec4(cos(angle), 0.0, sin(angle), 0.0);\n  vec4 r2 = vec4(0.0, 1.0, 0.0, 0.0);\n  vec4 r3 = vec4(-sin(angle), 0.0, cos(angle), 0.0);\n  vec4 r4 = vec4(0.0, 0.0, 0.0, 1.0);\n  mat4 transform = transpose(mat4(r1, r2, r3, r4));\n  \n  return modelMatrix * transform;\n}\n\nvoid main() {\n  mat4 model = getModel();\n  \n  vUv = uv;\n  vPos = vec3(model * vec4(position, 1.0));\n  \n  vNormal = normalize(mat3(transpose(inverse(model))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * model * vec4(position, 1.0);\n}",
                                "fragmentShader": "uniform sampler2D iChannel0;\nuniform float iTime;\n\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nconst vec3 lightDir = normalize(vec3(-1.0, 1.0, 1.0));\n\nfloat random(vec2 point) {\n  float d = dot(point, vec2(12.34, 56.78));\n  float r = fract(sin(d) * 1234.5678);\n  return r;\n}\n\nvoid main() {\n  vec3 fragColor = texture2D(iChannel0, vUv).rgb;\n  vec3 fragNormal = normalize(vNormal);\n  \n  float progress = cos(iTime) * 0.6 + 0.5;\n  float quantizationStep = 0.1;\n  float hole = random(floor(vUv / quantizationStep) * quantizationStep);\n  hole = step(progress, hole);\n  fragColor = mix(fragColor, vec3(0.0), hole);\n  \n  float ambient = 0.5;\n  float diffuse = dot(fragNormal, lightDir);\n  \n  gl_FragColor = vec4((ambient + diffuse) * fragColor, 1.0);\n}",
                                "defaultVertexShader": "uniform float iTime;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nmat4 getModel() {\n  float angle = iTime;\n  \n  vec4 r1 = vec4(cos(angle), 0.0, sin(angle), 0.0);\n  vec4 r2 = vec4(0.0, 1.0, 0.0, 0.0);\n  vec4 r3 = vec4(-sin(angle), 0.0, cos(angle), 0.0);\n  vec4 r4 = vec4(0.0, 0.0, 0.0, 1.0);\n  mat4 transform = transpose(mat4(r1, r2, r3, r4));\n  \n  return modelMatrix * transform;\n}\n\nvoid main() {\n  mat4 model = getModel();\n  \n  vUv = uv;\n  vPos = vec3(model * vec4(position, 1.0));\n  \n  vNormal = normalize(mat3(transpose(inverse(model))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * model * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform sampler2D iChannel0;\nuniform float iTime;\n\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nconst vec3 lightDir = normalize(vec3(-1.0, 1.0, 1.0));\n\nfloat random(vec2 point) {\n  float d = dot(point, vec2(12.34, 56.78));\n  float r = fract(sin(d) * 1234.5678);\n  return r;\n}\n\nvoid main() {\n  vec3 fragColor = texture2D(iChannel0, vUv).rgb;\n  vec3 fragNormal = normalize(vNormal);\n  \n  float progress = cos(iTime) * 0.6 + 0.5;\n  float quantizationStep = 0.1;\n  \n  float ambient = 0.5;\n  float diffuse = dot(fragNormal, lightDir);\n  \n  gl_FragColor = vec4((ambient + diffuse) * fragColor, 1.0);\n}",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":\"0\",\"y\":\"0\",\"z\":\"2\"},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":\"45\",\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":\"1\",\"y\":1,\"z\":1},\"geometry\":\"2\",\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"backgroundRGBA\":\"000000\",\"background\":0}",
                                "description": "**Quantization** is the process of converting continuous values into discrete ones. In programming, this can mean rounding values (coordinates, colors) to the nearest discrete values. \n\n<br>\n\nWe can use quantization to make the noise coarser and less detailed:\n\n<br>\n\n**1**. **Define the Quantization Step**: Choose a *quantization step* that determines how coarse the rounding will be. For example, a step of 0.1 means coordinates will be rounded to the nearest value that is a multiple of 0.1.\n\n<br>\n\n**2**. **Quantize the Coordinates**: Apply quantization to the coordinates. This can be done using simple rounding. For example, if you have coordinates **(x, y)**, you can round them as follows:\n\n```\nquantizedCoords = floor(coords / step) * step;\n```\n\n**3**. **Generate Noise**: use the quantized coordinates to generate noise.\n\n### Task\nChange the code so the visibility of a fragment is determined based on a random value computed from the fragment’s texture coordinates. Use a `progress` variable as the threshold value. If the fragment is not visible, it should be colored black. Additionally, perform quantization on the texture coordinates with a quantization step of `0.1` before computing the random value.",
                                "hints": [],
                                "restrictions": [],
                                "order": 3,
                                "cost": 5,
                                "threshold": 99,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [
                                    {
                                        "index": 0
                                    }
                                ],
                                "animated": true,
                                "animationSteps": 15,
                                "animationStepTime": 500,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "uniform float iTime;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nmat4 getModel() {\n  float angle = iTime;\n  \n  vec4 r1 = vec4(cos(angle), 0.0, sin(angle), 0.0);\n  vec4 r2 = vec4(0.0, 1.0, 0.0, 0.0);\n  vec4 r3 = vec4(-sin(angle), 0.0, cos(angle), 0.0);\n  vec4 r4 = vec4(0.0, 0.0, 0.0, 1.0);\n  mat4 transform = transpose(mat4(r1, r2, r3, r4));\n  \n  return modelMatrix * transform;\n}\n\nvoid main() {\n  mat4 model = getModel();\n  \n  vUv = uv;\n  vPos = vec3(model * vec4(position, 1.0));\n  \n  vNormal = normalize(mat3(transpose(inverse(model))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * model * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform sampler2D iChannel0;\nuniform float iTime;\n\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nconst vec3 lightDir = normalize(vec3(-1.0, 1.0, 1.0));\n\nfloat random(vec2 point) {\n  float d = dot(point, vec2(12.34, 56.78));\n  float r = fract(sin(d) * 1234.5678);\n  return r;\n}\n\nvoid main() {\n  vec3 fragColor = texture2D(iChannel0, vUv).rgb;\n  vec3 fragNormal = normalize(vNormal);\n  \n  float progress = cos(iTime) * 0.6 + 0.5;\n  float quantizationStep = 0.1;\n  \n  float ambient = 0.5;\n  float diffuse = dot(fragNormal, lightDir);\n  \n  gl_FragColor = vec4((ambient + diffuse) * fragColor, 1.0);\n}",
                            "defaultVertexShader": "uniform float iTime;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nmat4 getModel() {\n  float angle = iTime;\n  \n  vec4 r1 = vec4(cos(angle), 0.0, sin(angle), 0.0);\n  vec4 r2 = vec4(0.0, 1.0, 0.0, 0.0);\n  vec4 r3 = vec4(-sin(angle), 0.0, cos(angle), 0.0);\n  vec4 r4 = vec4(0.0, 0.0, 0.0, 1.0);\n  mat4 transform = transpose(mat4(r1, r2, r3, r4));\n  \n  return modelMatrix * transform;\n}\n\nvoid main() {\n  mat4 model = getModel();\n  \n  vUv = uv;\n  vPos = vec3(model * vec4(position, 1.0));\n  \n  vNormal = normalize(mat3(transpose(inverse(model))) * normal);\n  \n  gl_Position = projectionMatrix * viewMatrix * model * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform sampler2D iChannel0;\nuniform float iTime;\n\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nconst vec3 lightDir = normalize(vec3(-1.0, 1.0, 1.0));\n\nfloat random(vec2 point) {\n  float d = dot(point, vec2(12.34, 56.78));\n  float r = fract(sin(d) * 1234.5678);\n  return r;\n}\n\nvoid main() {\n  vec3 fragColor = texture2D(iChannel0, vUv).rgb;\n  vec3 fragNormal = normalize(vNormal);\n  \n  float progress = cos(iTime) * 0.6 + 0.5;\n  float quantizationStep = 0.1;\n  \n  float ambient = 0.5;\n  float diffuse = dot(fragNormal, lightDir);\n  \n  gl_FragColor = vec4((ambient + diffuse) * fragColor, 1.0);\n}",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 71,
                        "slug": "bilinear-filtering",
                        "moduleId": 8,
                        "name": "Bilinear Filtering",
                        "order": 4,
                        "cost": 10,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 71,
                                "slug": "bilinear-filtering",
                                "moduleId": 8,
                                "name": "Bilinear Filtering",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\n\nvec3 points[4];\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  points[0] = vec3(1.0, 1.0, 0.0);\n  points[1] = vec3(1.0, 0.0, 0.0);\n  points[2] = vec3(0.0, 1.0, 0.0);\n  points[3] = vec3(0.0, 0.0, 1.0);\n  \n  ivec2 uv_i = ivec2(max(vec2(0.0), uv * 2.0 - 0.5));\n  vec2 uv_f = fract(max(vec2(0.0), uv * 2.0 - 0.5));\n  \n  ivec2 p1 = min(ivec2(1, 1), uv_i + ivec2(0, 0)); \n  ivec2 p2 = min(ivec2(1, 1), uv_i + ivec2(1, 0));\n  ivec2 p3 = min(ivec2(1, 1), uv_i + ivec2(0, 1));\n  ivec2 p4 = min(ivec2(1, 1), uv_i + ivec2(1, 1));\n  \n  int index1 = p1.x + p1.y * 2;\n  int index2 = p2.x + p2.y * 2;\n  int index3 = p3.x + p3.y * 2;\n  int index4 = p4.x + p4.y * 2;\n  \n  vec3 s1 = mix(points[index1], points[index2], uv_f.x);\n  vec3 s2 = mix(points[index3], points[index4], uv_f.x);\n  vec3 color = mix(s1, s2, uv_f.y);\n\n  gl_FragColor = vec4(color, 1.0);\n}",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\n\nvec3 points[4];\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  points[0] = vec3(1.0, 1.0, 0.0);\n  points[1] = vec3(1.0, 0.0, 0.0);\n  points[2] = vec3(0.0, 1.0, 0.0);\n  points[3] = vec3(0.0, 0.0, 1.0);\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1,\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "**Bilinear filtering** is a method for interpolating functions of two variables (e.g., *x* and *y*) on a 2D grid.\n\n<br>\n\nThe primary purpose of bilinear filtering is to estimate the value of a function at a given point within a grid, based on the known values at the grid’s surrounding points. This is particularly useful in scenarios where you need to resize images, apply texture mapping, or smooth data.\n\n<br>\n\n### How Bilinear Interpolation Works\n\n<br>\n\n**1.** **Identify the Surrounding Points**. Given a point *(x, y)* where you want to interpolate, identify the four surrounding points in the grid **Q0**, **Q1**, **Q2**, and **Q3**:\n\n<br>\n\n![](/files/bilinear-filtering-points.png)\n\n<br>\n\n**2.** **Linear Interpolation in the x-Direction**. Perform linear interpolation between **Q0** and **Q1** to find **R0**. Perform linear interpolation between **Q2** and **Q3** to find **R1**.\n\n<br>\n\n![](/files/bilinear-filtering-interpolation.png)\n\n<br>\n\n**3.** **Linear Interpolation in the y-Direction**. Perform linear interpolation between **R0** and **R1** to find the interpolated value **P**.\n\n### Task\nGiven an array of 4 colors, divide the screen into a 2x2 grid and assign each cell a color from the array. Apply bilinear interpolation to smooth the transitions between the colors.\n\n<br>\n\n![](/files/bilinear-filtering-task.png)\n\n<br>\n\n**Note** that the color intensity of each cell is highest at its center.",
                                "hints": [],
                                "restrictions": [],
                                "order": 4,
                                "cost": 10,
                                "threshold": 95,
                                "likes": 0,
                                "dislikes": 4,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\n\nvec3 points[4];\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  points[0] = vec3(1.0, 1.0, 0.0);\n  points[1] = vec3(1.0, 0.0, 0.0);\n  points[2] = vec3(0.0, 1.0, 0.0);\n  points[3] = vec3(0.0, 0.0, 1.0);\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\n\nvec3 points[4];\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  points[0] = vec3(1.0, 1.0, 0.0);\n  points[1] = vec3(1.0, 0.0, 0.0);\n  points[2] = vec3(0.0, 1.0, 0.0);\n  points[3] = vec3(0.0, 0.0, 1.0);\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 74,
                        "slug": "value-noise",
                        "moduleId": 8,
                        "name": "Value Noise",
                        "order": 5,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 74,
                                "slug": "value-noise",
                                "moduleId": 8,
                                "name": "Value Noise",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\n\nfloat random(vec2 point){\n  float d = dot(point, vec2(12.34, 56.78));\n  float r = fract(sin(d) * 1234.5678);\n  r = r * 2.0 - 1.0; \n  return r;\n}\n\nfloat noise(vec2 point) {\n  vec2 i = floor(point);\n  vec2 f = fract(point);\n  \n  vec2 u = smoothstep(0.0, 1.0, f);\n  \n  float r1 = random(i + vec2(0.0, 0.0));\n  float r2 = random(i + vec2(1.0, 0.0));\n  float r3 = random(i + vec2(0.0, 1.0));\n  float r4 = random(i + vec2(1.0, 1.0));\n  \n  return mix(mix(r1, r2, u.x), mix(r3, r4, u.x), u.y);\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  vec2 ratio = vec2(iResolution.x / iResolution.y, 1.0);\n  \n  float noiseValue = noise(vec2(uv * ratio * 5.0)) * 0.5 + 0.5;\n\n  gl_FragColor = vec4(vec3(noiseValue), 1.0);\n}",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\n\nfloat random(vec2 point){\n  float d = dot(point, vec2(12.34, 56.78));\n  float r = fract(sin(d) * 1234.5678);\n  r = r * 2.0 - 1.0; \n  return r;\n}\n\nfloat noise(vec2 point) {\n  return 0.0;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  vec2 ratio = vec2(iResolution.x / iResolution.y, 1.0);\n  \n  float noiseValue = noise(vec2(uv * ratio * 5.0)) * 0.5 + 0.5;\n\n  gl_FragColor = vec4(vec3(noiseValue), 1.0);\n}\n",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1,\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "When sampling the grid of random values, we can use bilinear filtering to interpolate between the nearest grid points and create a smoother, more continuous pattern.\n\n<br>\n\n### Value Noise Implementation \n\n<br>\n\n**1.** **Create a grid of random values**: To generate the values we can use a regular random function and an integer part of UV coordinates as an argument. We can control the size of the grid by multiplying the UV coordinates by a constant.\n\n```\ncellpos = floor(uv * size);\ncellval = random(cellpos);\n```\n\n**2.** **Getting random values from the grid**: Use the integer part of the coordinates to get the four closest random values from the grid.\n\n```\ncellval = random(cellpos + intoffset);\n```\n\n**3.** **Interpolate between values**: Use the fractional part of the coordinates to interpolate between the obtained values on the X and Y axis. *Be sure to apply smoothstep (Hermite interpolation) to get interpolation weight.*\n\n```\nweight = smoothstep(0.0, 1.0, fractionalPart);\n```\n\n<br>\n\n\n\n### Task\nImplement bilinear filtering in the `noise` function. Use `random` function to get the point color.",
                                "hints": [],
                                "restrictions": [],
                                "order": 5,
                                "cost": 5,
                                "threshold": 95,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\n\nfloat random(vec2 point){\n  float d = dot(point, vec2(12.34, 56.78));\n  float r = fract(sin(d) * 1234.5678);\n  r = r * 2.0 - 1.0; \n  return r;\n}\n\nfloat noise(vec2 point) {\n  return 0.0;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  vec2 ratio = vec2(iResolution.x / iResolution.y, 1.0);\n  \n  float noiseValue = noise(vec2(uv * ratio * 5.0)) * 0.5 + 0.5;\n\n  gl_FragColor = vec4(vec3(noiseValue), 1.0);\n}\n",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\n\nfloat random(vec2 point){\n  float d = dot(point, vec2(12.34, 56.78));\n  float r = fract(sin(d) * 1234.5678);\n  r = r * 2.0 - 1.0; \n  return r;\n}\n\nfloat noise(vec2 point) {\n  return 0.0;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  vec2 ratio = vec2(iResolution.x / iResolution.y, 1.0);\n  \n  float noiseValue = noise(vec2(uv * ratio * 5.0)) * 0.5 + 0.5;\n\n  gl_FragColor = vec4(vec3(noiseValue), 1.0);\n}\n",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 73,
                        "slug": "gradient-noise",
                        "moduleId": 8,
                        "name": "Gradient Noise",
                        "order": 6,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 73,
                                "slug": "gradient-noise",
                                "moduleId": 8,
                                "name": "Gradient Noise",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\n\nvec2 random2(vec2 point){\n  float d1 = dot(point, vec2(12.3, 32.1));\n  float d2 = dot(point, vec2(45.6, 65.4));\n  \n  point = vec2(d1, d2);\n  return fract(sin(point) * 78.9) * 2.0 - 1.0;\n}\n\nfloat noise(vec2 point) {\n  vec2 i = floor(point);\n  vec2 f = fract(point);\n\n  vec2 u = smoothstep(0.0, 1.0, f);\n  \n  float d1 = dot(random2(i + vec2(0.0, 0.0)), f - vec2(0.0, 0.0));\n  float d2 = dot(random2(i + vec2(1.0, 0.0)), f - vec2(1.0, 0.0));\n  float d3 = dot(random2(i + vec2(0.0, 1.0)), f - vec2(0.0, 1.0));\n  float d4 = dot(random2(i + vec2(1.0, 1.0)), f - vec2(1.0, 1.0));\n  return mix(mix(d1, d2, u.x), mix(d3, d4, u.x), u.y);\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  vec2 ratio = vec2(iResolution.x / iResolution.y, 1.0);\n  \n  float noiseValue = noise(vec2(uv * ratio * 5.0)) * 0.5 + 0.5;\n\n  gl_FragColor = vec4(vec3(noiseValue), 1.0);\n}",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "\nuniform vec2 iResolution;\n\nvec2 random2(vec2 point){\n  float d1 = dot(point, vec2(12.3, 32.1));\n  float d2 = dot(point, vec2(45.6, 65.4));\n  \n  point = vec2(d1, d2);\n  return fract(sin(point) * 78.9) * 2.0 - 1.0;\n}\n\nfloat noise(vec2 point) {\n  return 0.0;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  vec2 ratio = vec2(iResolution.x / iResolution.y, 1.0);\n  \n  float noiseValue = noise(vec2(uv * ratio * 5.0)) * 0.5 + 0.5;\n\n  gl_FragColor = vec4(vec3(noiseValue), 1.0);\n}\n",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"object\":{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1},\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "Algorithm:\n1. Generate random vectors for the current cell, the cell on the right, bottom and bottom right cells.\n2. Using the fractional part of the current position, determine the displacement vector for each of the four cells.\n3. In pairs, calculate the dot product of the cell's random vector and it's displacement vector.\n4. Using the bilinear interpolation algorithm, mix the four values. Pre-apply `smoothstep` (Hermite interpolation) to interpolation weight.\n\n### Task\nImplement the gradient noise algorithm in the `noise` function. Use `random2` function to get random vector.",
                                "hints": [],
                                "restrictions": [],
                                "order": 6,
                                "cost": 5,
                                "threshold": 95,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "\nuniform vec2 iResolution;\n\nvec2 random2(vec2 point){\n  float d1 = dot(point, vec2(12.3, 32.1));\n  float d2 = dot(point, vec2(45.6, 65.4));\n  \n  point = vec2(d1, d2);\n  return fract(sin(point) * 78.9) * 2.0 - 1.0;\n}\n\nfloat noise(vec2 point) {\n  return 0.0;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  vec2 ratio = vec2(iResolution.x / iResolution.y, 1.0);\n  \n  float noiseValue = noise(vec2(uv * ratio * 5.0)) * 0.5 + 0.5;\n\n  gl_FragColor = vec4(vec3(noiseValue), 1.0);\n}\n",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "\nuniform vec2 iResolution;\n\nvec2 random2(vec2 point){\n  float d1 = dot(point, vec2(12.3, 32.1));\n  float d2 = dot(point, vec2(45.6, 65.4));\n  \n  point = vec2(d1, d2);\n  return fract(sin(point) * 78.9) * 2.0 - 1.0;\n}\n\nfloat noise(vec2 point) {\n  return 0.0;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  vec2 ratio = vec2(iResolution.x / iResolution.y, 1.0);\n  \n  float noiseValue = noise(vec2(uv * ratio * 5.0)) * 0.5 + 0.5;\n\n  gl_FragColor = vec4(vec3(noiseValue), 1.0);\n}\n",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 76,
                        "slug": "gradient-noise-animation",
                        "moduleId": 8,
                        "name": "Gradient Noise Animation",
                        "order": 7,
                        "cost": 10,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 76,
                                "slug": "gradient-noise-animation",
                                "moduleId": 8,
                                "name": "Gradient Noise Animation",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nvec3 random3(vec3 st){\n  float d1 = dot(st, vec3(12.3, 32.1, 21.3));\n  float d2 = dot(st, vec3(45.6, 65.4, 54.6));\n  float d3 = dot(st, vec3(78.9, 98.7, 87.9));\n  \n  st = vec3(d1, d2, d3);\n  return fract(sin(st) * 14.7) * 2.0 - 1.0;\n}\n\nfloat noise(vec3 st) {\n  vec3 i = floor(st);\n  vec3 f = fract(st);\n\n  vec3 u = smoothstep(0.0, 1.0, f);\n  \n  float d1 = dot(random3(i + vec3(0.0, 0.0, 0.0)), f - vec3(0.0, 0.0, 0.0));\n  float d2 = dot(random3(i + vec3(1.0, 0.0, 0.0)), f - vec3(1.0, 0.0, 0.0));\n  float d3 = dot(random3(i + vec3(0.0, 1.0, 0.0)), f - vec3(0.0, 1.0, 0.0));\n  float d4 = dot(random3(i + vec3(1.0, 1.0, 0.0)), f - vec3(1.0, 1.0, 0.0));\n  \n  float d5 = dot(random3(i + vec3(0.0, 0.0, 1.0)), f - vec3(0.0, 0.0, 1.0));\n  float d6 = dot(random3(i + vec3(1.0, 0.0, 1.0)), f - vec3(1.0, 0.0, 1.0));\n  float d7 = dot(random3(i + vec3(0.0, 1.0, 1.0)), f - vec3(0.0, 1.0, 1.0));\n  float d8 = dot(random3(i + vec3(1.0, 1.0, 1.0)), f - vec3(1.0, 1.0, 1.0));\n  \n  float m1 = mix(mix(d1, d2, u.x), mix(d3, d4, u.x), u.y);\n  float m2 = mix(mix(d5, d6, u.x), mix(d7, d8, u.x), u.y);\n  \n  float result = mix(m1, m2, u.z);\n  result = result * 0.5 + 0.5;\n  \n  return result;\n}\n\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  vec2 ratio = vec2(iResolution.x / iResolution.y, 1.0);\n  \n  float noiseValue = noise(vec3(uv * ratio * 4.0, iTime * 0.5));\n    \n  gl_FragColor = vec4(vec3(noiseValue), 1.0);\n}",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nvec3 random3(vec3 st) {\n  float d1 = dot(st, vec3(12.3, 32.1, 21.3));\n  float d2 = dot(st, vec3(45.6, 65.4, 54.6));\n  float d3 = dot(st, vec3(78.9, 98.7, 87.9));\n  \n  st = vec3(d1, d2, d3);\n  return fract(sin(st) * 14.7) * 2.0 - 1.0;\n}\n\nfloat noise(vec3 st) {\n  return 0.0;\n}\n\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  vec2 ratio = vec2(iResolution.x / iResolution.y, 1.0);\n  \n  float noiseValue = noise(vec3(uv * ratio * 4.0, iTime * 0.5));\n    \n  gl_FragColor = vec4(vec3(noiseValue), 1.0);\n}\n",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"object\":{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1},\"backgroundRGBA\":\"FFFFFF\",\"background\":16777215}",
                                "description": "To animate gradient noise in 2D, we first need to generate it in 3D. This involves creating a cube in 3D space with noise values and slicing it parallel to the x-y plane by moving the slice along the z-axis over time. Then display this slice on the screen.\n\n<br>\n\nIn order to generate gradient noise in 3D we need to calculate the gradient noise for the current x-y slice and the adjacent slice at the z-coordinate. We then mix these two values using the fractional part of the z coordinate. Be sure to apply smoothstep (Hermite interpolation) to interpolation weight.\n\n### Task\nImplement the 3D gradient noise algorithm in the `noise` function. Use `random3` function to get random vector.\n\n",
                                "hints": [],
                                "restrictions": [],
                                "order": 7,
                                "cost": 10,
                                "threshold": 95,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": true,
                                "animationSteps": 5,
                                "animationStepTime": 1000,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nvec3 random3(vec3 st) {\n  float d1 = dot(st, vec3(12.3, 32.1, 21.3));\n  float d2 = dot(st, vec3(45.6, 65.4, 54.6));\n  float d3 = dot(st, vec3(78.9, 98.7, 87.9));\n  \n  st = vec3(d1, d2, d3);\n  return fract(sin(st) * 14.7) * 2.0 - 1.0;\n}\n\nfloat noise(vec3 st) {\n  return 0.0;\n}\n\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  vec2 ratio = vec2(iResolution.x / iResolution.y, 1.0);\n  \n  float noiseValue = noise(vec3(uv * ratio * 4.0, iTime * 0.5));\n    \n  gl_FragColor = vec4(vec3(noiseValue), 1.0);\n}\n",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nvec3 random3(vec3 st) {\n  float d1 = dot(st, vec3(12.3, 32.1, 21.3));\n  float d2 = dot(st, vec3(45.6, 65.4, 54.6));\n  float d3 = dot(st, vec3(78.9, 98.7, 87.9));\n  \n  st = vec3(d1, d2, d3);\n  return fract(sin(st) * 14.7) * 2.0 - 1.0;\n}\n\nfloat noise(vec3 st) {\n  return 0.0;\n}\n\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  vec2 ratio = vec2(iResolution.x / iResolution.y, 1.0);\n  \n  float noiseValue = noise(vec3(uv * ratio * 4.0, iTime * 0.5));\n    \n  gl_FragColor = vec4(vec3(noiseValue), 1.0);\n}\n",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 181,
                        "slug": "shape-distortion",
                        "moduleId": 8,
                        "name": "Shape Distortion",
                        "order": 8,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 181,
                                "slug": "shape-distortion",
                                "moduleId": 8,
                                "name": "Shape Distortion",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\nuniform sampler2D iChannel0;\n\nvec3 random3(vec3 st){\n  float d1 = dot(st, vec3(12.3, 32.1, 21.3));\n  float d2 = dot(st, vec3(45.6, 65.4, 54.6));\n  float d3 = dot(st, vec3(78.9, 98.7, 87.9));\n  \n  st = vec3(d1, d2, d3);\n  return fract(sin(st) * 14.7) * 2.0 - 1.0;\n}\n\nfloat noise(vec3 st) {\n  vec3 i = floor(st);\n  vec3 f = fract(st);\n\n  vec3 u = smoothstep(0.0, 1.0, f);\n  \n  float d1 = dot(random3(i + vec3(0.0, 0.0, 0.0)), f - vec3(0.0, 0.0, 0.0));\n  float d2 = dot(random3(i + vec3(1.0, 0.0, 0.0)), f - vec3(1.0, 0.0, 0.0));\n  float d3 = dot(random3(i + vec3(0.0, 1.0, 0.0)), f - vec3(0.0, 1.0, 0.0));\n  float d4 = dot(random3(i + vec3(1.0, 1.0, 0.0)), f - vec3(1.0, 1.0, 0.0));\n  \n  float d5 = dot(random3(i + vec3(0.0, 0.0, 1.0)), f - vec3(0.0, 0.0, 1.0));\n  float d6 = dot(random3(i + vec3(1.0, 0.0, 1.0)), f - vec3(1.0, 0.0, 1.0));\n  float d7 = dot(random3(i + vec3(0.0, 1.0, 1.0)), f - vec3(0.0, 1.0, 1.0));\n  float d8 = dot(random3(i + vec3(1.0, 1.0, 1.0)), f - vec3(1.0, 1.0, 1.0));\n  \n  float m1 = mix(mix(d1, d2, u.x), mix(d3, d4, u.x), u.y);\n  float m2 = mix(mix(d5, d6, u.x), mix(d7, d8, u.x), u.y);\n  \n  float result = mix(m1, m2, u.z);\n  result = result * 0.5 + 0.5;\n  \n  return result;\n}\n\nvoid main() {\n  vec2 aspect = vec2(iResolution.x / iResolution.y, 1.0);\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  uv *= aspect;\n  vec2 center = vec2(0.5) * aspect;\n  \n  float distortion = noise(vec3(uv * 5.0, iTime));\n\n  float proteinR = 0.2 + distortion * 0.4; \n  float yolkR    = 0.1 + distortion * 0.1;\n\n  float protein = 1.0 - step(0.0, distance(center, uv) - proteinR);\n  float yolk    = 1.0 - step(0.0, distance(center, uv) - yolkR);\n  \n  vec3 egg = vec3(1.0) * protein - vec3(0.0, 0.2, 1.0) * yolk;\n  \n  gl_FragColor = vec4(egg, 1.0);\n}\n",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\nuniform sampler2D iChannel0;\n\nvec3 random3(vec3 st){\n  float d1 = dot(st, vec3(12.3, 32.1, 21.3));\n  float d2 = dot(st, vec3(45.6, 65.4, 54.6));\n  float d3 = dot(st, vec3(78.9, 98.7, 87.9));\n  \n  st = vec3(d1, d2, d3);\n  return fract(sin(st) * 14.7) * 2.0 - 1.0;\n}\n\nfloat noise(vec3 st) {\n  vec3 i = floor(st);\n  vec3 f = fract(st);\n\n  vec3 u = smoothstep(0.0, 1.0, f);\n  \n  float d1 = dot(random3(i + vec3(0.0, 0.0, 0.0)), f - vec3(0.0, 0.0, 0.0));\n  float d2 = dot(random3(i + vec3(1.0, 0.0, 0.0)), f - vec3(1.0, 0.0, 0.0));\n  float d3 = dot(random3(i + vec3(0.0, 1.0, 0.0)), f - vec3(0.0, 1.0, 0.0));\n  float d4 = dot(random3(i + vec3(1.0, 1.0, 0.0)), f - vec3(1.0, 1.0, 0.0));\n  \n  float d5 = dot(random3(i + vec3(0.0, 0.0, 1.0)), f - vec3(0.0, 0.0, 1.0));\n  float d6 = dot(random3(i + vec3(1.0, 0.0, 1.0)), f - vec3(1.0, 0.0, 1.0));\n  float d7 = dot(random3(i + vec3(0.0, 1.0, 1.0)), f - vec3(0.0, 1.0, 1.0));\n  float d8 = dot(random3(i + vec3(1.0, 1.0, 1.0)), f - vec3(1.0, 1.0, 1.0));\n  \n  float m1 = mix(mix(d1, d2, u.x), mix(d3, d4, u.x), u.y);\n  float m2 = mix(mix(d5, d6, u.x), mix(d7, d8, u.x), u.y);\n  \n  float result = mix(m1, m2, u.z);\n  result = result * 0.5 + 0.5;\n  \n  return result;\n}\n\nvoid main() {\n  vec2 aspect = vec2(iResolution.x / iResolution.y, 1.0);\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  uv *= aspect;\n  vec2 center = vec2(0.5) * aspect;\n  \n  float distortion = noise(vec3(uv * 5.0, iTime));\n\n  float proteinR = 0.2; \n  float yolkR    = 0.1;\n\n  float protein = 1.0 - step(0.0, distance(center, uv) - proteinR);\n  float yolk    = 1.0 - step(0.0, distance(center, uv) - yolkR);\n  \n  vec3 egg = vec3(1.0) * protein - vec3(0.0, 0.2, 1.0) * yolk;\n  \n  gl_FragColor = vec4(egg, 1.0);\n}\n",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1,\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"backgroundRGBA\":\"FFFFFF\",\"background\":16777215}",
                                "description": "Signed Distance Fields (SDF) represent shapes where each point’s value indicates the distance to the nearest boundary of the shape. Here you can learn more about SDF: [Signed Distance Field Module](https://shader-learning.com/module-view/3).\n\n<br>\n\nWe can add noise to the SDF value to distort the shape’s boundaries. This can be done by adding the noise value to the result of the SDF function:\n\n```\ndistortedSDF = SDF + noise * strength;\n```\n\nBy changing the noise multiplier you can control the strength of the shape distortion.\n\n### Task\nTwo circles are given. You need to add to the white circle (squirrel) a distortion with strength of **0.4**, and to the yellow circle (yolk) a distortion with stength of **0.1**.",
                                "hints": [],
                                "restrictions": [],
                                "order": 8,
                                "cost": 5,
                                "threshold": 99,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": true,
                                "animationSteps": 10,
                                "animationStepTime": 100,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\nuniform sampler2D iChannel0;\n\nvec3 random3(vec3 st){\n  float d1 = dot(st, vec3(12.3, 32.1, 21.3));\n  float d2 = dot(st, vec3(45.6, 65.4, 54.6));\n  float d3 = dot(st, vec3(78.9, 98.7, 87.9));\n  \n  st = vec3(d1, d2, d3);\n  return fract(sin(st) * 14.7) * 2.0 - 1.0;\n}\n\nfloat noise(vec3 st) {\n  vec3 i = floor(st);\n  vec3 f = fract(st);\n\n  vec3 u = smoothstep(0.0, 1.0, f);\n  \n  float d1 = dot(random3(i + vec3(0.0, 0.0, 0.0)), f - vec3(0.0, 0.0, 0.0));\n  float d2 = dot(random3(i + vec3(1.0, 0.0, 0.0)), f - vec3(1.0, 0.0, 0.0));\n  float d3 = dot(random3(i + vec3(0.0, 1.0, 0.0)), f - vec3(0.0, 1.0, 0.0));\n  float d4 = dot(random3(i + vec3(1.0, 1.0, 0.0)), f - vec3(1.0, 1.0, 0.0));\n  \n  float d5 = dot(random3(i + vec3(0.0, 0.0, 1.0)), f - vec3(0.0, 0.0, 1.0));\n  float d6 = dot(random3(i + vec3(1.0, 0.0, 1.0)), f - vec3(1.0, 0.0, 1.0));\n  float d7 = dot(random3(i + vec3(0.0, 1.0, 1.0)), f - vec3(0.0, 1.0, 1.0));\n  float d8 = dot(random3(i + vec3(1.0, 1.0, 1.0)), f - vec3(1.0, 1.0, 1.0));\n  \n  float m1 = mix(mix(d1, d2, u.x), mix(d3, d4, u.x), u.y);\n  float m2 = mix(mix(d5, d6, u.x), mix(d7, d8, u.x), u.y);\n  \n  float result = mix(m1, m2, u.z);\n  result = result * 0.5 + 0.5;\n  \n  return result;\n}\n\nvoid main() {\n  vec2 aspect = vec2(iResolution.x / iResolution.y, 1.0);\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  uv *= aspect;\n  vec2 center = vec2(0.5) * aspect;\n  \n  float distortion = noise(vec3(uv * 5.0, iTime));\n\n  float proteinR = 0.2; \n  float yolkR    = 0.1;\n\n  float protein = 1.0 - step(0.0, distance(center, uv) - proteinR);\n  float yolk    = 1.0 - step(0.0, distance(center, uv) - yolkR);\n  \n  vec3 egg = vec3(1.0) * protein - vec3(0.0, 0.2, 1.0) * yolk;\n  \n  gl_FragColor = vec4(egg, 1.0);\n}\n",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\nuniform sampler2D iChannel0;\n\nvec3 random3(vec3 st){\n  float d1 = dot(st, vec3(12.3, 32.1, 21.3));\n  float d2 = dot(st, vec3(45.6, 65.4, 54.6));\n  float d3 = dot(st, vec3(78.9, 98.7, 87.9));\n  \n  st = vec3(d1, d2, d3);\n  return fract(sin(st) * 14.7) * 2.0 - 1.0;\n}\n\nfloat noise(vec3 st) {\n  vec3 i = floor(st);\n  vec3 f = fract(st);\n\n  vec3 u = smoothstep(0.0, 1.0, f);\n  \n  float d1 = dot(random3(i + vec3(0.0, 0.0, 0.0)), f - vec3(0.0, 0.0, 0.0));\n  float d2 = dot(random3(i + vec3(1.0, 0.0, 0.0)), f - vec3(1.0, 0.0, 0.0));\n  float d3 = dot(random3(i + vec3(0.0, 1.0, 0.0)), f - vec3(0.0, 1.0, 0.0));\n  float d4 = dot(random3(i + vec3(1.0, 1.0, 0.0)), f - vec3(1.0, 1.0, 0.0));\n  \n  float d5 = dot(random3(i + vec3(0.0, 0.0, 1.0)), f - vec3(0.0, 0.0, 1.0));\n  float d6 = dot(random3(i + vec3(1.0, 0.0, 1.0)), f - vec3(1.0, 0.0, 1.0));\n  float d7 = dot(random3(i + vec3(0.0, 1.0, 1.0)), f - vec3(0.0, 1.0, 1.0));\n  float d8 = dot(random3(i + vec3(1.0, 1.0, 1.0)), f - vec3(1.0, 1.0, 1.0));\n  \n  float m1 = mix(mix(d1, d2, u.x), mix(d3, d4, u.x), u.y);\n  float m2 = mix(mix(d5, d6, u.x), mix(d7, d8, u.x), u.y);\n  \n  float result = mix(m1, m2, u.z);\n  result = result * 0.5 + 0.5;\n  \n  return result;\n}\n\nvoid main() {\n  vec2 aspect = vec2(iResolution.x / iResolution.y, 1.0);\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  uv *= aspect;\n  vec2 center = vec2(0.5) * aspect;\n  \n  float distortion = noise(vec3(uv * 5.0, iTime));\n\n  float proteinR = 0.2; \n  float yolkR    = 0.1;\n\n  float protein = 1.0 - step(0.0, distance(center, uv) - proteinR);\n  float yolk    = 1.0 - step(0.0, distance(center, uv) - yolkR);\n  \n  vec3 egg = vec3(1.0) * protein - vec3(0.0, 0.2, 1.0) * yolk;\n  \n  gl_FragColor = vec4(egg, 1.0);\n}\n",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 180,
                        "slug": "noise-texture",
                        "moduleId": 8,
                        "name": "Noise Texture",
                        "order": 9,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 180,
                                "slug": "noise-texture",
                                "moduleId": 8,
                                "name": "Noise Texture",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\nuniform sampler2D iChannel0;\n\nfloat sdfBox(vec2 center, vec2 size, vec2 pos) {\n  vec2 d = abs(pos - center) - size;\n  return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\nvoid main() {\n  vec2 aspect = vec2(iResolution.x / iResolution.y, 1.0);\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  float time = iTime * 0.25;\n  \n  float distortion = texture(iChannel0, fract(uv - vec2(0.0, time))).r;\n  distortion *= uv.y;\n  distortion *= 0.4;\n\n  vec2 center = vec2(0.5, 0.4);\n  float shape = sdfBox(center * aspect, vec2(0.5, 0.15), uv * aspect);\n  shape = max(shape - distortion, 0.0);\n  \n  float t = 1.0 - smoothstep(0.0, 0.1, shape);\n  vec3 color = vec3(1.5, 1.0, 0.25) * t * (distortion + 0.6);\n  \n  gl_FragColor = vec4(color * color, 1.0);\n}\n",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\nuniform sampler2D iChannel0;\n\nfloat sdfBox(vec2 center, vec2 size, vec2 pos) {\n  vec2 d = abs(pos - center) - size;\n  return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\nvoid main() {\n  vec2 aspect = vec2(iResolution.x / iResolution.y, 1.0);\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  float time = iTime * 0.25;\n  \n  float distortion = 0.0; // sample noise value\n  distortion *= uv.y;\n  distortion *= 0.4;\n\n  vec2 center = vec2(0.5, 0.4);\n  float shape = sdfBox(center * aspect, vec2(0.5, 0.15), uv * aspect);\n  shape = max(shape - distortion, 0.0);\n  \n  float t = 1.0 - smoothstep(0.0, 0.1, shape);\n  vec3 color = vec3(1.5, 1.0, 0.25) * t * (distortion + 0.6);\n  \n  gl_FragColor = vec4(color * color, 1.0);\n}\n",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1,\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"backgroundRGBA\":\"FFFFFF\",\"background\":16777215}",
                                "description": "By saving noise to a texture and using texture scrolling, you can create dynamic and animated effects efficiently.\n\n<br>\n\n### Texture Scrolling\n\n<br>\n\nTexture scrolling involves offsetting the texture coordinates over time to create a moving effect. This can be achieved by modifying the UV coordinates based on a time variable:\n\n```\n// scroll texture horizontally\ntexture(iChannel0, fract(uv - vec2(time, 0.0)))\n\n// scroll texture vertically\ntexture(iChannel0, fract(uv - vec2(0.0, time)))\n```\n\n### Efficiency Considerations\n\n<br>\n\nUsing texture sampling to read precomputed noise values is much more efficient than generating noise values on-the-fly in the fragment shader. This is because:\n\n1. **Texture Sampling**: Modern GPUs are highly optimized for texture sampling. Accessing a value from a texture is a fast operation, often supported by dedicated hardware units within the GPU.\n\n\n2. **Noise Generation**: Generating noise values in the shader involves complex mathematical operations, which can be computationally expensive and slow down rendering, especially when done for every fragment.\n\n### Task\nYou are given a shader program that needs to be edited to achieve the following:\n\n1. **Sample a Noise Texture**: use a precomputed noise texture to obtain noise values.\n2. **Implement Vertical Texture Scrolling**: modify the uv coordinates to scroll the texture vertically over time.\n3. **Distortion Value**: use the sampled noise as a distortion value.",
                                "hints": [],
                                "restrictions": [],
                                "order": 9,
                                "cost": 5,
                                "threshold": 99,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [
                                    {
                                        "index": 0
                                    }
                                ],
                                "animated": true,
                                "animationSteps": 10,
                                "animationStepTime": 100,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\nuniform sampler2D iChannel0;\n\nfloat sdfBox(vec2 center, vec2 size, vec2 pos) {\n  vec2 d = abs(pos - center) - size;\n  return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\nvoid main() {\n  vec2 aspect = vec2(iResolution.x / iResolution.y, 1.0);\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  float time = iTime * 0.25;\n  \n  float distortion = 0.0; // sample noise value\n  distortion *= uv.y;\n  distortion *= 0.4;\n\n  vec2 center = vec2(0.5, 0.4);\n  float shape = sdfBox(center * aspect, vec2(0.5, 0.15), uv * aspect);\n  shape = max(shape - distortion, 0.0);\n  \n  float t = 1.0 - smoothstep(0.0, 0.1, shape);\n  vec3 color = vec3(1.5, 1.0, 0.25) * t * (distortion + 0.6);\n  \n  gl_FragColor = vec4(color * color, 1.0);\n}\n",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\nuniform sampler2D iChannel0;\n\nfloat sdfBox(vec2 center, vec2 size, vec2 pos) {\n  vec2 d = abs(pos - center) - size;\n  return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\nvoid main() {\n  vec2 aspect = vec2(iResolution.x / iResolution.y, 1.0);\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  float time = iTime * 0.25;\n  \n  float distortion = 0.0; // sample noise value\n  distortion *= uv.y;\n  distortion *= 0.4;\n\n  vec2 center = vec2(0.5, 0.4);\n  float shape = sdfBox(center * aspect, vec2(0.5, 0.15), uv * aspect);\n  shape = max(shape - distortion, 0.0);\n  \n  float t = 1.0 - smoothstep(0.0, 0.1, shape);\n  vec3 color = vec3(1.5, 1.0, 0.25) * t * (distortion + 0.6);\n  \n  gl_FragColor = vec4(color * color, 1.0);\n}\n",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 66,
                        "slug": "cellular-noise",
                        "moduleId": 8,
                        "name": "Cellular Noise",
                        "order": 12,
                        "cost": 10,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 66,
                                "slug": "cellular-noise",
                                "moduleId": 8,
                                "name": "Cellular Noise",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nvec2 points[9];\n\nvoid init() {\n  points[0] = vec2(0.05,0.15);\n  points[1] = vec2(0.35,0.27);\n  points[2] = vec2(0.78,0.04);\n  \n  points[3] =  vec2(0.25,0.46);\n  points[4] = vec2(0.50,0.55);\n  points[5] = vec2(0.91,0.37);\n  \n  points[6] = vec2(0.28,0.67);\n  points[7] =  vec2(0.53,0.76);\n  points[8] = vec2(0.73,0.75); \n}\n\nvec2 getPoint(int index) {\n  return sin(points[index] * 6.28 + iTime / 3.0) * 0.5 + 0.5;\n}\n\nvoid main() {\n  init();\n  \n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  float m_dist = 1.0;\n  \n  for (int i = 0; i < 9; i++) {\n    float dist = distance(uv, getPoint(i));\n    m_dist = min(m_dist, dist);\n  }\n  \n  gl_FragColor = vec4(0.0, m_dist * 2.25, 0.0, 1.0);\n}",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nvec2 points[9];\n\nvoid init() {\n  points[0] = vec2(0.05,0.15);\n  points[1] = vec2(0.35,0.27);\n  points[2] = vec2(0.78,0.04);\n  \n  points[3] =  vec2(0.25,0.46);\n  points[4] = vec2(0.50,0.55);\n  points[5] = vec2(0.91,0.37);\n  \n  points[6] = vec2(0.28,0.67);\n  points[7] =  vec2(0.53,0.76);\n  points[8] = vec2(0.73,0.75); \n}\n\nvec2 getPoint(int index) {\n  return sin(points[index] * 6.28 + iTime / 3.0) * 0.5 + 0.5;\n}\n\nvoid main() {\n  init();\n  \n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  float m_dist = 1.0;\n  \n  gl_FragColor = vec4(0.0, m_dist * 2.25, 0.0, 1.0);\n}",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"object\":{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1},\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "Cellular Noise is based on distance fields, the distance to the closest one of a set of feature points.\n\n### Task\nIterate through all the points, compute their distances to the current pixel and store the value for the one that is closest. Use the resulting distance as the green output channel.",
                                "hints": [],
                                "restrictions": [],
                                "order": 12,
                                "cost": 10,
                                "threshold": 95,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": true,
                                "animationSteps": 6,
                                "animationStepTime": 1000,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nvec2 points[9];\n\nvoid init() {\n  points[0] = vec2(0.05,0.15);\n  points[1] = vec2(0.35,0.27);\n  points[2] = vec2(0.78,0.04);\n  \n  points[3] =  vec2(0.25,0.46);\n  points[4] = vec2(0.50,0.55);\n  points[5] = vec2(0.91,0.37);\n  \n  points[6] = vec2(0.28,0.67);\n  points[7] =  vec2(0.53,0.76);\n  points[8] = vec2(0.73,0.75); \n}\n\nvec2 getPoint(int index) {\n  return sin(points[index] * 6.28 + iTime / 3.0) * 0.5 + 0.5;\n}\n\nvoid main() {\n  init();\n  \n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  float m_dist = 1.0;\n  \n  gl_FragColor = vec4(0.0, m_dist * 2.25, 0.0, 1.0);\n}",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nvec2 points[9];\n\nvoid init() {\n  points[0] = vec2(0.05,0.15);\n  points[1] = vec2(0.35,0.27);\n  points[2] = vec2(0.78,0.04);\n  \n  points[3] =  vec2(0.25,0.46);\n  points[4] = vec2(0.50,0.55);\n  points[5] = vec2(0.91,0.37);\n  \n  points[6] = vec2(0.28,0.67);\n  points[7] =  vec2(0.53,0.76);\n  points[8] = vec2(0.73,0.75); \n}\n\nvec2 getPoint(int index) {\n  return sin(points[index] * 6.28 + iTime / 3.0) * 0.5 + 0.5;\n}\n\nvoid main() {\n  init();\n  \n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  float m_dist = 1.0;\n  \n  gl_FragColor = vec4(0.0, m_dist * 2.25, 0.0, 1.0);\n}",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 67,
                        "slug": "tiling",
                        "moduleId": 8,
                        "name": "Tiling",
                        "order": 14,
                        "cost": 10,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 67,
                                "slug": "tiling",
                                "moduleId": 8,
                                "name": "Tiling",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nvec2 points[100];\n\nvoid init() {\n  for (int i = 0; i < 100; i++) {\n    points[i] = vec2(sin(float(i)), cos(float(i)));  \n  }\n}\n\nvec2 getPoint(int index) {\n  return sin(iTime + points[index] * 6.28) * 0.5 + 0.5;\n}\n\nvoid main() {\n  init();\n  \n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  uv *= 10.0;\n  vec2 uv_i = floor(uv);\n  \n  float m_dist = 1.0;\n  \n  for (int y= -1; y <= 1; y++) {\n    for (int x= -1; x <= 1; x++) {\n      float index_f = uv_i.x + uv_i.y * 10.0 + float(x) + float(y) * 10.0;\n      index_f = mod(index_f + 100.0, 100.0);\n      int index = int(index_f);\n      \n      vec2 point = getPoint(index) ; \n      point = point + vec2(float(x), float(y)) + uv_i;\n      \n      float dist = distance(uv, point);\n      m_dist = min(m_dist, dist);\n    }\n  }\n\n  gl_FragColor = vec4(0.0, m_dist, 0.0, 1.0);\n}",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nvec2 points[100];\n\nvoid init() {\n  for (int i = 0; i < 100; i++) {\n    points[i] = vec2(sin(float(i)), cos(float(i)));  \n  }\n}\n\nvec2 getPoint(int index) {\n  return sin(iTime + points[index] * 6.28) * 0.5 + 0.5;\n}\n\nvoid main() {\n  init();\n  \n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"object\":{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1},\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "Iterating through a lot of instances reduces the performance of your shader significantly. To get around this problem, we can divide the space into tiles. As a result, each pixel only needs to check nine positions: its own cell point and points in 8 cells around it.\n\n### Task\nSubdivide the screen into 100 tiles. For each pixel calculate the distance to the point in their own tile and the surrounding 8 tiles. Store the closest distance. Use the resulting distance as the green output channel.",
                                "hints": [],
                                "restrictions": [],
                                "order": 14,
                                "cost": 10,
                                "threshold": 95,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": true,
                                "animationSteps": 6,
                                "animationStepTime": 1000,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nvec2 points[100];\n\nvoid init() {\n  for (int i = 0; i < 100; i++) {\n    points[i] = vec2(sin(float(i)), cos(float(i)));  \n  }\n}\n\nvec2 getPoint(int index) {\n  return sin(iTime + points[index] * 6.28) * 0.5 + 0.5;\n}\n\nvoid main() {\n  init();\n  \n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nvec2 points[100];\n\nvoid init() {\n  for (int i = 0; i < 100; i++) {\n    points[i] = vec2(sin(float(i)), cos(float(i)));  \n  }\n}\n\nvec2 getPoint(int index) {\n  return sin(iTime + points[index] * 6.28) * 0.5 + 0.5;\n}\n\nvoid main() {\n  init();\n  \n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 68,
                        "slug": "sine-wave",
                        "moduleId": 8,
                        "name": "Sine Wave",
                        "order": 15,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 68,
                                "slug": "sine-wave",
                                "moduleId": 8,
                                "name": "Sine Wave",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nfloat grid(float size) {\n  vec2 center = iResolution.xy * 0.5;\n  vec2 dist = abs(center - gl_FragCoord.xy);\n  vec2 posInCell = fract(dist / size);\n  \n  float stroke = 1.0 / size;\n  float t = step(stroke, posInCell.x);\n  t *= 1.0 - step(1.0 - stroke, posInCell.x);\n  t *= step(stroke, posInCell.y);\n  t *= 1.0 - step(1.0 - stroke, posInCell.y);\n   \n  return 1.0 - t;\n}\n\nfloat sinPlot(float x) {\n  float _x = (iResolution.x * 0.5 - x) / 20.0;\n  float _y =sin(_x) * 0.05 * iResolution.y;\n  return _y;\n}\n\nfloat fbm(float x) {\n  return sinPlot(x * 2.0 - iTime * 100.0) * 5.0;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  float smallGrid = grid(20.0);\n  float bigGrid = grid(80.0);\n  \n  vec3 color = vec3(1.0);\n  color = mix(color, vec3(0.9, 0.9, 0.9), smallGrid);\n  color = mix(color, vec3(0.75, 0.75, 0.75), bigGrid);\n  color = mix(vec3(0.0, 0.0, 0.0), color, step(1.0 / iResolution.x, abs(uv.x - 0.5)));\n  color = mix(vec3(0.0, 0.0, 0.0), color, step(1.0 / iResolution.y, abs(uv.y - 0.5)));\n  \n  float y =  iResolution.y * 0.5 - fbm(gl_FragCoord.x);\n  float dx = dFdx(y);\n  \n  float stroke = 3.0;\n  float t = smoothstep(0.0, stroke * max(1.0, abs(dx)), abs(gl_FragCoord.y - y));\n  color = mix(vec3(1.0, 0.0, 0.0), color, t);\n  \n  gl_FragColor = vec4(color, 1.0);\n}",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nfloat grid(float size) {\n  vec2 center = iResolution.xy * 0.5;\n  vec2 dist = abs(center - gl_FragCoord.xy);\n  vec2 posInCell = fract(dist / size);\n  \n  float stroke = 1.0 / size;\n  float t = step(stroke, posInCell.x);\n  t *= 1.0 - step(1.0 - stroke, posInCell.x);\n  t *= step(stroke, posInCell.y);\n  t *= 1.0 - step(1.0 - stroke, posInCell.y);\n   \n  return 1.0 - t;\n}\n\nfloat sinPlot(float x) {\n  float _x = (iResolution.x * 0.5 - x) / 20.0;\n  float _y =sin(_x) * 0.05 * iResolution.y;\n  return _y;\n}\n\nfloat fbm(float x) {\n  return sinPlot(x);\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  float smallGrid = grid(20.0);\n  float bigGrid = grid(80.0);\n  \n  vec3 color = vec3(1.0);\n  color = mix(color, vec3(0.9, 0.9, 0.9), smallGrid);\n  color = mix(color, vec3(0.75, 0.75, 0.75), bigGrid);\n  color = mix(vec3(0.0, 0.0, 0.0), color, step(1.0 / iResolution.x, abs(uv.x - 0.5)));\n  color = mix(vec3(0.0, 0.0, 0.0), color, step(1.0 / iResolution.y, abs(uv.y - 0.5)));\n  \n  float y =  iResolution.y * 0.5 - fbm(gl_FragCoord.x);\n  float dx = dFdx(y);\n  \n  float stroke = 3.0;\n  float t = smoothstep(0.0, stroke * max(1.0, abs(dx)), abs(gl_FragCoord.y - y));\n  color = mix(vec3(1.0, 0.0, 0.0), color, t);\n  \n  gl_FragColor = vec4(color, 1.0);\n}",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"object\":{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1},\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "General form:\n\n```\ny(x, t) = A * sin(x * F + W * t)\n```\n**A** - amplitude is the peak deviation of the function from zero. **F** - frequency controls the number of oscillations (cycles). **W** - linear speed (speed of propagation) of wave.\n\n### Task\nFind the `fbm` method. Change the frequency of the sine plot by 2 times and the amplitude by 5. Add wave propagation with 100.0 speed.",
                                "hints": [],
                                "restrictions": [],
                                "order": 15,
                                "cost": 5,
                                "threshold": 99,
                                "likes": 1,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": true,
                                "animationSteps": 5,
                                "animationStepTime": 100,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nfloat grid(float size) {\n  vec2 center = iResolution.xy * 0.5;\n  vec2 dist = abs(center - gl_FragCoord.xy);\n  vec2 posInCell = fract(dist / size);\n  \n  float stroke = 1.0 / size;\n  float t = step(stroke, posInCell.x);\n  t *= 1.0 - step(1.0 - stroke, posInCell.x);\n  t *= step(stroke, posInCell.y);\n  t *= 1.0 - step(1.0 - stroke, posInCell.y);\n   \n  return 1.0 - t;\n}\n\nfloat sinPlot(float x) {\n  float _x = (iResolution.x * 0.5 - x) / 20.0;\n  float _y =sin(_x) * 0.05 * iResolution.y;\n  return _y;\n}\n\nfloat fbm(float x) {\n  return sinPlot(x);\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  float smallGrid = grid(20.0);\n  float bigGrid = grid(80.0);\n  \n  vec3 color = vec3(1.0);\n  color = mix(color, vec3(0.9, 0.9, 0.9), smallGrid);\n  color = mix(color, vec3(0.75, 0.75, 0.75), bigGrid);\n  color = mix(vec3(0.0, 0.0, 0.0), color, step(1.0 / iResolution.x, abs(uv.x - 0.5)));\n  color = mix(vec3(0.0, 0.0, 0.0), color, step(1.0 / iResolution.y, abs(uv.y - 0.5)));\n  \n  float y =  iResolution.y * 0.5 - fbm(gl_FragCoord.x);\n  float dx = dFdx(y);\n  \n  float stroke = 3.0;\n  float t = smoothstep(0.0, stroke * max(1.0, abs(dx)), abs(gl_FragCoord.y - y));\n  color = mix(vec3(1.0, 0.0, 0.0), color, t);\n  \n  gl_FragColor = vec4(color, 1.0);\n}",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nfloat grid(float size) {\n  vec2 center = iResolution.xy * 0.5;\n  vec2 dist = abs(center - gl_FragCoord.xy);\n  vec2 posInCell = fract(dist / size);\n  \n  float stroke = 1.0 / size;\n  float t = step(stroke, posInCell.x);\n  t *= 1.0 - step(1.0 - stroke, posInCell.x);\n  t *= step(stroke, posInCell.y);\n  t *= 1.0 - step(1.0 - stroke, posInCell.y);\n   \n  return 1.0 - t;\n}\n\nfloat sinPlot(float x) {\n  float _x = (iResolution.x * 0.5 - x) / 20.0;\n  float _y =sin(_x) * 0.05 * iResolution.y;\n  return _y;\n}\n\nfloat fbm(float x) {\n  return sinPlot(x);\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  float smallGrid = grid(20.0);\n  float bigGrid = grid(80.0);\n  \n  vec3 color = vec3(1.0);\n  color = mix(color, vec3(0.9, 0.9, 0.9), smallGrid);\n  color = mix(color, vec3(0.75, 0.75, 0.75), bigGrid);\n  color = mix(vec3(0.0, 0.0, 0.0), color, step(1.0 / iResolution.x, abs(uv.x - 0.5)));\n  color = mix(vec3(0.0, 0.0, 0.0), color, step(1.0 / iResolution.y, abs(uv.y - 0.5)));\n  \n  float y =  iResolution.y * 0.5 - fbm(gl_FragCoord.x);\n  float dx = dFdx(y);\n  \n  float stroke = 3.0;\n  float t = smoothstep(0.0, stroke * max(1.0, abs(dx)), abs(gl_FragCoord.y - y));\n  color = mix(vec3(1.0, 0.0, 0.0), color, t);\n  \n  gl_FragColor = vec4(color, 1.0);\n}",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 69,
                        "slug": "wave-superposition",
                        "moduleId": 8,
                        "name": "Wave Superposition",
                        "order": 16,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 69,
                                "slug": "wave-superposition",
                                "moduleId": 8,
                                "name": "Wave Superposition",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nfloat grid(float size) {\n  vec2 center = iResolution.xy * 0.5;\n  vec2 dist = abs(center - gl_FragCoord.xy);\n  vec2 posInCell = fract(dist / size);\n  \n  float stroke = 1.0 / size;\n  float t = step(stroke, posInCell.x);\n  t *= 1.0 - step(1.0 - stroke, posInCell.x);\n  t *= step(stroke, posInCell.y);\n  t *= 1.0 - step(1.0 - stroke, posInCell.y);\n   \n  return 1.0 - t;\n}\n\nfloat sinPlot(float x) {\n  float _x = (iResolution.x * 0.5 - x)* 0.05;\n  float _y =sin(_x) * 0.05 * iResolution.y;\n  return _y;\n}\n\nfloat fbm(float x) {\n  float t = 0.0;\n  for (int i = 1; i <= 4; i *= 2) {\n    float frequency = 1.0 / float(i);\n    float amplitude = 1.0 * float(i);\n    t += sinPlot(x * frequency - iTime * 100.0) * amplitude;\n  }\n  \n  return t;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  float smallGrid = grid(20.0);\n  float bigGrid = grid(80.0);\n  \n  vec3 color = vec3(1.0);\n  color = mix(color, vec3(0.9, 0.9, 0.9), smallGrid);\n  color = mix(color, vec3(0.75, 0.75, 0.75), bigGrid);\n  color = mix(vec3(0.0, 0.0, 0.0), color, step(1.0 / iResolution.x, abs(uv.x - 0.5)));\n  color = mix(vec3(0.0, 0.0, 0.0), color, step(1.0 / iResolution.y, abs(uv.y - 0.5)));\n  \n  float y = iResolution.y * 0.5 - fbm(gl_FragCoord.x);\n    \n  float dx =dFdx(y);\n  \n  float stroke = 3.0;\n  float t = smoothstep(0.0, stroke * max(1.0, abs(dx)), abs(gl_FragCoord.y - y));\n  color = mix(vec3(1.0, 0.0, 0.0), color, t);\n  \n  gl_FragColor = vec4(color, 1.0);\n}",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nfloat grid(float size) {\n  vec2 center = iResolution.xy * 0.5;\n  vec2 dist = abs(center - gl_FragCoord.xy);\n  vec2 posInCell = fract(dist / size);\n  \n  float stroke = 1.0 / size;\n  float t = step(stroke, posInCell.x);\n  t *= 1.0 - step(1.0 - stroke, posInCell.x);\n  t *= step(stroke, posInCell.y);\n  t *= 1.0 - step(1.0 - stroke, posInCell.y);\n   \n  return 1.0 - t;\n}\n\nfloat sinPlot(float x) {\n  float _x = (iResolution.x * 0.5 - x)* 0.05;\n  float _y =sin(_x) * 0.05 * iResolution.y;\n  return _y;\n}\n\nfloat fbm(float x) {\n  return sinPlot(x - iTime * 100.0);\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  float smallGrid = grid(20.0);\n  float bigGrid = grid(80.0);\n  \n  vec3 color = vec3(1.0);\n  color = mix(color, vec3(0.9, 0.9, 0.9), smallGrid);\n  color = mix(color, vec3(0.75, 0.75, 0.75), bigGrid);\n  color = mix(vec3(0.0, 0.0, 0.0), color, step(1.0 / iResolution.x, abs(uv.x - 0.5)));\n  color = mix(vec3(0.0, 0.0, 0.0), color, step(1.0 / iResolution.y, abs(uv.y - 0.5)));\n  \n  float y = iResolution.y * 0.5 - fbm(gl_FragCoord.x);\n    \n  float dx =dFdx(y);\n  \n  float stroke = 3.0;\n  float t = smoothstep(0.0, stroke * max(1.0, abs(dx)), abs(gl_FragCoord.y - y));\n  color = mix(vec3(1.0, 0.0, 0.0), color, t);\n  \n  gl_FragColor = vec4(color, 1.0);\n}",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"object\":{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1},\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "Superposition is the ability of waves to add up. The resulting wave displacement may be written as:\n\n```\ny(x, t) = A1 * sin(F1 * x + W1 * t) + ... + An * sin(Fn * x + Wn * t)\n```\n\n### Task\nFind the `fbm` method. Try to combine three sine waves with the following parameters:\n1. Amplitude 1.0, Frequency 1.0\n2. Amplitude 2.0, Frequency 0.5\n3. Amplitude 4.0, Frequency 0.25\n",
                                "hints": [],
                                "restrictions": [],
                                "order": 16,
                                "cost": 5,
                                "threshold": 99,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": true,
                                "animationSteps": 5,
                                "animationStepTime": 500,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nfloat grid(float size) {\n  vec2 center = iResolution.xy * 0.5;\n  vec2 dist = abs(center - gl_FragCoord.xy);\n  vec2 posInCell = fract(dist / size);\n  \n  float stroke = 1.0 / size;\n  float t = step(stroke, posInCell.x);\n  t *= 1.0 - step(1.0 - stroke, posInCell.x);\n  t *= step(stroke, posInCell.y);\n  t *= 1.0 - step(1.0 - stroke, posInCell.y);\n   \n  return 1.0 - t;\n}\n\nfloat sinPlot(float x) {\n  float _x = (iResolution.x * 0.5 - x)* 0.05;\n  float _y =sin(_x) * 0.05 * iResolution.y;\n  return _y;\n}\n\nfloat fbm(float x) {\n  return sinPlot(x - iTime * 100.0);\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  float smallGrid = grid(20.0);\n  float bigGrid = grid(80.0);\n  \n  vec3 color = vec3(1.0);\n  color = mix(color, vec3(0.9, 0.9, 0.9), smallGrid);\n  color = mix(color, vec3(0.75, 0.75, 0.75), bigGrid);\n  color = mix(vec3(0.0, 0.0, 0.0), color, step(1.0 / iResolution.x, abs(uv.x - 0.5)));\n  color = mix(vec3(0.0, 0.0, 0.0), color, step(1.0 / iResolution.y, abs(uv.y - 0.5)));\n  \n  float y = iResolution.y * 0.5 - fbm(gl_FragCoord.x);\n    \n  float dx =dFdx(y);\n  \n  float stroke = 3.0;\n  float t = smoothstep(0.0, stroke * max(1.0, abs(dx)), abs(gl_FragCoord.y - y));\n  color = mix(vec3(1.0, 0.0, 0.0), color, t);\n  \n  gl_FragColor = vec4(color, 1.0);\n}",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nfloat grid(float size) {\n  vec2 center = iResolution.xy * 0.5;\n  vec2 dist = abs(center - gl_FragCoord.xy);\n  vec2 posInCell = fract(dist / size);\n  \n  float stroke = 1.0 / size;\n  float t = step(stroke, posInCell.x);\n  t *= 1.0 - step(1.0 - stroke, posInCell.x);\n  t *= step(stroke, posInCell.y);\n  t *= 1.0 - step(1.0 - stroke, posInCell.y);\n   \n  return 1.0 - t;\n}\n\nfloat sinPlot(float x) {\n  float _x = (iResolution.x * 0.5 - x)* 0.05;\n  float _y =sin(_x) * 0.05 * iResolution.y;\n  return _y;\n}\n\nfloat fbm(float x) {\n  return sinPlot(x - iTime * 100.0);\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  float smallGrid = grid(20.0);\n  float bigGrid = grid(80.0);\n  \n  vec3 color = vec3(1.0);\n  color = mix(color, vec3(0.9, 0.9, 0.9), smallGrid);\n  color = mix(color, vec3(0.75, 0.75, 0.75), bigGrid);\n  color = mix(vec3(0.0, 0.0, 0.0), color, step(1.0 / iResolution.x, abs(uv.x - 0.5)));\n  color = mix(vec3(0.0, 0.0, 0.0), color, step(1.0 / iResolution.y, abs(uv.y - 0.5)));\n  \n  float y = iResolution.y * 0.5 - fbm(gl_FragCoord.x);\n    \n  float dx =dFdx(y);\n  \n  float stroke = 3.0;\n  float t = smoothstep(0.0, stroke * max(1.0, abs(dx)), abs(gl_FragCoord.y - y));\n  color = mix(vec3(1.0, 0.0, 0.0), color, t);\n  \n  gl_FragColor = vec4(color, 1.0);\n}",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 70,
                        "slug": "fbm",
                        "moduleId": 8,
                        "name": "FBM",
                        "order": 17,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 70,
                                "slug": "fbm",
                                "moduleId": 8,
                                "name": "FBM",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nfloat fbm(float x) {\n  const int octaves = 30;\n  float lacunarity = 2.0;\n  float gain = 0.5;\n  \n  float amplitude = 0.5;\n  float frequency = 6.28;\n  \n  float y = 0.0;\n  for (int i = 0; i < octaves; i++) {\n    y += amplitude * sin(frequency * x);\n    frequency *= lacunarity;\n    amplitude *= gain;\n  }\n  \n  return y;\n}\n\nfloat grid(float size) {\n  vec2 center = iResolution.xy * 0.5;\n  vec2 dist = abs(center - gl_FragCoord.xy);\n  vec2 posInCell = fract(dist / size);\n  \n  float stroke = 1.0 / size;\n  float t = step(stroke, posInCell.x);\n  t *= 1.0 - step(1.0 - stroke, posInCell.x);\n  t *= step(stroke, posInCell.y);\n  t *= 1.0 - step(1.0 - stroke, posInCell.y);\n   \n  return 1.0 - t;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  float smallGrid = grid(20.0);\n  float bigGrid = grid(80.0);\n  \n  vec3 color = vec3(1.0);\n  color = mix(color, vec3(0.9, 0.9, 0.9), smallGrid);\n  color = mix(color, vec3(0.75, 0.75, 0.75), bigGrid);\n  color = mix(vec3(0.0, 0.0, 0.0), color, step(1.0 / iResolution.x, abs(uv.x - 0.5)));\n  color = mix(vec3(0.0, 0.0, 0.0), color, step(1.0 / iResolution.y, abs(uv.y - 0.5)));\n  \n  float z = 33.0 + (sin(iTime * 0.25) * 8000.0 + 8000.0);\n  float center = 0.5;\n  float x = (uv.x - center) / z + center + 0.049201;\n  float y = (fbm(x) - 0.123436) * z + 0.5;\n  \n  float stroke = 5.0;\n  float t = step(stroke / iResolution.y, abs(uv.y - y));\n  color = mix(vec3(1.0, 0.0, 0.0), color, t);\n  \n  gl_FragColor = vec4(color, 1.0);\n}",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nbool animate = false;\n\nfloat fbm(float x) { \n  float amplitude = 0.5;\n  float frequency = 6.28;\n  \n  return amplitude * sin(frequency * x);\n}\n\nfloat grid(float size) {\n  vec2 center = iResolution.xy * 0.5;\n  vec2 dist = abs(center - gl_FragCoord.xy);\n  vec2 posInCell = fract(dist / size);\n  \n  float stroke = 1.0 / size;\n  float t = step(stroke, posInCell.x);\n  t *= 1.0 - step(1.0 - stroke, posInCell.x);\n  t *= step(stroke, posInCell.y);\n  t *= 1.0 - step(1.0 - stroke, posInCell.y);\n   \n  return 1.0 - t;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  float smallGrid = grid(20.0);\n  float bigGrid = grid(80.0);\n  \n  vec3 color = vec3(1.0);\n  color = mix(color, vec3(0.9, 0.9, 0.9), smallGrid);\n  color = mix(color, vec3(0.75, 0.75, 0.75), bigGrid);\n  color = mix(vec3(0.0, 0.0, 0.0), color, step(1.0 / iResolution.x, abs(uv.x - 0.5)));\n  color = mix(vec3(0.0, 0.0, 0.0), color, step(1.0 / iResolution.y, abs(uv.y - 0.5)));\n  \n  float z = 1.0;\n  float center = 0.5;\n  float x = 0.0;\n  float y = 0.0;\n  \n  if (animate) {\n    z = 33.0 + (sin(iTime * 0.25) * 8000.0 + 8000.0);\n    x = (uv.x - center) / z + center + 0.049201;\n    y = (fbm(x) - 0.123436) * z + 0.5;\n  } else {\n    x = (uv.x - center) / z + center;\n    y = fbm(x) * z + 0.5;\n  }\n  \n  float stroke = 5.0;\n  float t = step(stroke / iResolution.y, abs(uv.y - y));\n  color = mix(vec3(1.0, 0.0, 0.0), color, t);\n  \n  gl_FragColor = vec4(color, 1.0);\n}",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"object\":{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1},\"backgroundRGBA\":\"FFFFFF\",\"background\":16777215}",
                                "description": "By adding different iterations of sine waves (**octaves**), where we increase the frequencies step by step (multiply by **lacunarity**) and decrease the amplitude (multiply by **gain**) of the wave, we can achieve finer detail in the result. This technique is called **fractal Brownian motion** (fBM) or simply **fractal noise**.\n\n<br>\n\nIf we zoom the curve, the smaller part will look about the same as the whole wave. Theoretically, we will get a real mathematical fractal if we add an infinite number of wave components\n\n### Task\nFind the `fbm` method in the code. Try iteratively combining 30 sine waves. With each iteration, increase the frequency of the wave by 2 times, decrease the amplitude by 2 times. After that, find the `animate` flag in the code and switch it to true.",
                                "hints": [],
                                "restrictions": [],
                                "order": 17,
                                "cost": 5,
                                "threshold": 99,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": true,
                                "animationSteps": 6,
                                "animationStepTime": 2000,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nbool animate = false;\n\nfloat fbm(float x) { \n  float amplitude = 0.5;\n  float frequency = 6.28;\n  \n  return amplitude * sin(frequency * x);\n}\n\nfloat grid(float size) {\n  vec2 center = iResolution.xy * 0.5;\n  vec2 dist = abs(center - gl_FragCoord.xy);\n  vec2 posInCell = fract(dist / size);\n  \n  float stroke = 1.0 / size;\n  float t = step(stroke, posInCell.x);\n  t *= 1.0 - step(1.0 - stroke, posInCell.x);\n  t *= step(stroke, posInCell.y);\n  t *= 1.0 - step(1.0 - stroke, posInCell.y);\n   \n  return 1.0 - t;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  float smallGrid = grid(20.0);\n  float bigGrid = grid(80.0);\n  \n  vec3 color = vec3(1.0);\n  color = mix(color, vec3(0.9, 0.9, 0.9), smallGrid);\n  color = mix(color, vec3(0.75, 0.75, 0.75), bigGrid);\n  color = mix(vec3(0.0, 0.0, 0.0), color, step(1.0 / iResolution.x, abs(uv.x - 0.5)));\n  color = mix(vec3(0.0, 0.0, 0.0), color, step(1.0 / iResolution.y, abs(uv.y - 0.5)));\n  \n  float z = 1.0;\n  float center = 0.5;\n  float x = 0.0;\n  float y = 0.0;\n  \n  if (animate) {\n    z = 33.0 + (sin(iTime * 0.25) * 8000.0 + 8000.0);\n    x = (uv.x - center) / z + center + 0.049201;\n    y = (fbm(x) - 0.123436) * z + 0.5;\n  } else {\n    x = (uv.x - center) / z + center;\n    y = fbm(x) * z + 0.5;\n  }\n  \n  float stroke = 5.0;\n  float t = step(stroke / iResolution.y, abs(uv.y - y));\n  color = mix(vec3(1.0, 0.0, 0.0), color, t);\n  \n  gl_FragColor = vec4(color, 1.0);\n}",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nbool animate = false;\n\nfloat fbm(float x) { \n  float amplitude = 0.5;\n  float frequency = 6.28;\n  \n  return amplitude * sin(frequency * x);\n}\n\nfloat grid(float size) {\n  vec2 center = iResolution.xy * 0.5;\n  vec2 dist = abs(center - gl_FragCoord.xy);\n  vec2 posInCell = fract(dist / size);\n  \n  float stroke = 1.0 / size;\n  float t = step(stroke, posInCell.x);\n  t *= 1.0 - step(1.0 - stroke, posInCell.x);\n  t *= step(stroke, posInCell.y);\n  t *= 1.0 - step(1.0 - stroke, posInCell.y);\n   \n  return 1.0 - t;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  float smallGrid = grid(20.0);\n  float bigGrid = grid(80.0);\n  \n  vec3 color = vec3(1.0);\n  color = mix(color, vec3(0.9, 0.9, 0.9), smallGrid);\n  color = mix(color, vec3(0.75, 0.75, 0.75), bigGrid);\n  color = mix(vec3(0.0, 0.0, 0.0), color, step(1.0 / iResolution.x, abs(uv.x - 0.5)));\n  color = mix(vec3(0.0, 0.0, 0.0), color, step(1.0 / iResolution.y, abs(uv.y - 0.5)));\n  \n  float z = 1.0;\n  float center = 0.5;\n  float x = 0.0;\n  float y = 0.0;\n  \n  if (animate) {\n    z = 33.0 + (sin(iTime * 0.25) * 8000.0 + 8000.0);\n    x = (uv.x - center) / z + center + 0.049201;\n    y = (fbm(x) - 0.123436) * z + 0.5;\n  } else {\n    x = (uv.x - center) / z + center;\n    y = fbm(x) * z + 0.5;\n  }\n  \n  float stroke = 5.0;\n  float t = step(stroke / iResolution.y, abs(uv.y - y));\n  color = mix(vec3(1.0, 0.0, 0.0), color, t);\n  \n  gl_FragColor = vec4(color, 1.0);\n}",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 80,
                        "slug": "fractal-noise",
                        "moduleId": 8,
                        "name": "Fractal noise",
                        "order": 18,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 80,
                                "slug": "fractal-noise",
                                "moduleId": 8,
                                "name": "Fractal noise",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nvec3 random3(vec3 point){\n  float d1 = dot(point, vec3(12.3, 32.1, 21.3));\n  float d2 = dot(point, vec3(45.6, 65.4, 54.6));\n  float d3 = dot(point, vec3(78.9, 98.7, 87.9));\n  \n  point = vec3(d1, d2, d3);\n  return fract(sin(point) * 14.7) * 2.0 - 1.0;\n}\n\nfloat noise(vec3 st) {\n  vec3 i = floor(st);\n  vec3 f = fract(st);\n\n  vec3 u = smoothstep(0.0, 1.0, f);\n  \n  float d1 = dot(random3(i + vec3(0.0, 0.0, 0.0)), f - vec3(0.0, 0.0, 0.0));\n  float d2 = dot(random3(i + vec3(1.0, 0.0, 0.0)), f - vec3(1.0, 0.0, 0.0));\n  float d3 = dot(random3(i + vec3(0.0, 1.0, 0.0)), f - vec3(0.0, 1.0, 0.0));\n  float d4 = dot(random3(i + vec3(1.0, 1.0, 0.0)), f - vec3(1.0, 1.0, 0.0));\n  \n  float d5 = dot(random3(i + vec3(0.0, 0.0, 1.0)), f - vec3(0.0, 0.0, 1.0));\n  float d6 = dot(random3(i + vec3(1.0, 0.0, 1.0)), f - vec3(1.0, 0.0, 1.0));\n  float d7 = dot(random3(i + vec3(0.0, 1.0, 1.0)), f - vec3(0.0, 1.0, 1.0));\n  float d8 = dot(random3(i + vec3(1.0, 1.0, 1.0)), f - vec3(1.0, 1.0, 1.0));\n  \n  float m1 = mix(mix(d1, d2, u.x), mix(d3, d4, u.x), u.y);\n  float m2 = mix(mix(d5, d6, u.x), mix(d7, d8, u.x), u.y);\n  \n  return mix(m1, m2, u.z);\n}\n\nfloat fbm(vec3 st) { \n  const int octaves = 5;\n  float lacunarity = 2.0;\n  float gain = 0.5;\n  \n  float amplitude = 1.0;\n  float frequency = 1.0;\n  \n  float y = 0.0;\n  for (int i = 0; i < octaves; i++) {\n    y += amplitude * noise(frequency * st);\n    frequency *= lacunarity;\n    amplitude *= gain;\n  }\n  \n  return y;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  vec2 ratio = vec2(iResolution.x / iResolution.y, 1.0);\n  \n  float noiseValue = fbm(vec3(uv * ratio * 2.0, iTime * 0.1));\n  noiseValue = noiseValue * 0.5 + 0.5;\n\n  gl_FragColor = vec4(vec3(noiseValue), 1.0);\n}",
                                "postProcessShader": "",
                                "properties": "",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nvec3 random3(vec3 point){\n  float d1 = dot(point, vec3(12.3, 32.1, 21.3));\n  float d2 = dot(point, vec3(45.6, 65.4, 54.6));\n  float d3 = dot(point, vec3(78.9, 98.7, 87.9));\n  \n  point = vec3(d1, d2, d3);\n  return fract(sin(point) * 14.7) * 2.0 - 1.0;\n}\n\nfloat noise(vec3 st) {\n  vec3 i = floor(st);\n  vec3 f = fract(st);\n\n  vec3 u = smoothstep(0.0, 1.0, f);\n  \n  float d1 = dot(random3(i + vec3(0.0, 0.0, 0.0)), f - vec3(0.0, 0.0, 0.0));\n  float d2 = dot(random3(i + vec3(1.0, 0.0, 0.0)), f - vec3(1.0, 0.0, 0.0));\n  float d3 = dot(random3(i + vec3(0.0, 1.0, 0.0)), f - vec3(0.0, 1.0, 0.0));\n  float d4 = dot(random3(i + vec3(1.0, 1.0, 0.0)), f - vec3(1.0, 1.0, 0.0));\n  \n  float d5 = dot(random3(i + vec3(0.0, 0.0, 1.0)), f - vec3(0.0, 0.0, 1.0));\n  float d6 = dot(random3(i + vec3(1.0, 0.0, 1.0)), f - vec3(1.0, 0.0, 1.0));\n  float d7 = dot(random3(i + vec3(0.0, 1.0, 1.0)), f - vec3(0.0, 1.0, 1.0));\n  float d8 = dot(random3(i + vec3(1.0, 1.0, 1.0)), f - vec3(1.0, 1.0, 1.0));\n  \n  float m1 = mix(mix(d1, d2, u.x), mix(d3, d4, u.x), u.y);\n  float m2 = mix(mix(d5, d6, u.x), mix(d7, d8, u.x), u.y);\n  \n  return mix(m1, m2, u.z);\n}\n\nfloat fbm(vec3 st) { \n  return 0.0;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  vec2 ratio = vec2(iResolution.x / iResolution.y, 1.0);\n  \n  float noiseValue = fbm(vec3(uv * ratio * 2.0, iTime * 0.1));\n  noiseValue = noiseValue * 0.5 + 0.5;\n\n  gl_FragColor = vec4(vec3(noiseValue), 1.0);\n}\n",
                                "defaultPostProcessShader": "",
                                "defaultProperties": "",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1,\"model\":null,\"meshes\":[{\"name\":\"main\",\"materialId\":0}],\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"materials\":[],\"actions\":[],\"backgroundRGBA\":\"FFFFFF\",\"background\":16777215,\"customDepthBufferTexture\":false,\"glslVersion\":1}",
                                "description": "So let's now try to generate 2D fractal noise using the FBM function from the previous lesson, but instead of the sine, we will use the gradient noise as an octave.\n\n### Task\nFind the `fbm` method declaration and implement its body. Use the following configurations: initial *amplitude* and *frequency* - `1.0`, *octaves* - `5`, *lacunarity* - `2.0`, *gain* - `0.5`.",
                                "hints": [],
                                "restrictions": [],
                                "order": 18,
                                "cost": 5,
                                "threshold": 95,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": true,
                                "animationSteps": 5,
                                "animationStepTime": 200,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nvec3 random3(vec3 point){\n  float d1 = dot(point, vec3(12.3, 32.1, 21.3));\n  float d2 = dot(point, vec3(45.6, 65.4, 54.6));\n  float d3 = dot(point, vec3(78.9, 98.7, 87.9));\n  \n  point = vec3(d1, d2, d3);\n  return fract(sin(point) * 14.7) * 2.0 - 1.0;\n}\n\nfloat noise(vec3 st) {\n  vec3 i = floor(st);\n  vec3 f = fract(st);\n\n  vec3 u = smoothstep(0.0, 1.0, f);\n  \n  float d1 = dot(random3(i + vec3(0.0, 0.0, 0.0)), f - vec3(0.0, 0.0, 0.0));\n  float d2 = dot(random3(i + vec3(1.0, 0.0, 0.0)), f - vec3(1.0, 0.0, 0.0));\n  float d3 = dot(random3(i + vec3(0.0, 1.0, 0.0)), f - vec3(0.0, 1.0, 0.0));\n  float d4 = dot(random3(i + vec3(1.0, 1.0, 0.0)), f - vec3(1.0, 1.0, 0.0));\n  \n  float d5 = dot(random3(i + vec3(0.0, 0.0, 1.0)), f - vec3(0.0, 0.0, 1.0));\n  float d6 = dot(random3(i + vec3(1.0, 0.0, 1.0)), f - vec3(1.0, 0.0, 1.0));\n  float d7 = dot(random3(i + vec3(0.0, 1.0, 1.0)), f - vec3(0.0, 1.0, 1.0));\n  float d8 = dot(random3(i + vec3(1.0, 1.0, 1.0)), f - vec3(1.0, 1.0, 1.0));\n  \n  float m1 = mix(mix(d1, d2, u.x), mix(d3, d4, u.x), u.y);\n  float m2 = mix(mix(d5, d6, u.x), mix(d7, d8, u.x), u.y);\n  \n  return mix(m1, m2, u.z);\n}\n\nfloat fbm(vec3 st) { \n  return 0.0;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  vec2 ratio = vec2(iResolution.x / iResolution.y, 1.0);\n  \n  float noiseValue = fbm(vec3(uv * ratio * 2.0, iTime * 0.1));\n  noiseValue = noiseValue * 0.5 + 0.5;\n\n  gl_FragColor = vec4(vec3(noiseValue), 1.0);\n}\n",
                            "postProcessShader": "",
                            "properties": "",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nvec3 random3(vec3 point){\n  float d1 = dot(point, vec3(12.3, 32.1, 21.3));\n  float d2 = dot(point, vec3(45.6, 65.4, 54.6));\n  float d3 = dot(point, vec3(78.9, 98.7, 87.9));\n  \n  point = vec3(d1, d2, d3);\n  return fract(sin(point) * 14.7) * 2.0 - 1.0;\n}\n\nfloat noise(vec3 st) {\n  vec3 i = floor(st);\n  vec3 f = fract(st);\n\n  vec3 u = smoothstep(0.0, 1.0, f);\n  \n  float d1 = dot(random3(i + vec3(0.0, 0.0, 0.0)), f - vec3(0.0, 0.0, 0.0));\n  float d2 = dot(random3(i + vec3(1.0, 0.0, 0.0)), f - vec3(1.0, 0.0, 0.0));\n  float d3 = dot(random3(i + vec3(0.0, 1.0, 0.0)), f - vec3(0.0, 1.0, 0.0));\n  float d4 = dot(random3(i + vec3(1.0, 1.0, 0.0)), f - vec3(1.0, 1.0, 0.0));\n  \n  float d5 = dot(random3(i + vec3(0.0, 0.0, 1.0)), f - vec3(0.0, 0.0, 1.0));\n  float d6 = dot(random3(i + vec3(1.0, 0.0, 1.0)), f - vec3(1.0, 0.0, 1.0));\n  float d7 = dot(random3(i + vec3(0.0, 1.0, 1.0)), f - vec3(0.0, 1.0, 1.0));\n  float d8 = dot(random3(i + vec3(1.0, 1.0, 1.0)), f - vec3(1.0, 1.0, 1.0));\n  \n  float m1 = mix(mix(d1, d2, u.x), mix(d3, d4, u.x), u.y);\n  float m2 = mix(mix(d5, d6, u.x), mix(d7, d8, u.x), u.y);\n  \n  return mix(m1, m2, u.z);\n}\n\nfloat fbm(vec3 st) { \n  return 0.0;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  vec2 ratio = vec2(iResolution.x / iResolution.y, 1.0);\n  \n  float noiseValue = fbm(vec3(uv * ratio * 2.0, iTime * 0.1));\n  noiseValue = noiseValue * 0.5 + 0.5;\n\n  gl_FragColor = vec4(vec3(noiseValue), 1.0);\n}\n",
                            "defaultPostProcessShader": "",
                            "defaultProperties": "",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 81,
                        "slug": "turbulence",
                        "moduleId": 8,
                        "name": "Turbulence",
                        "order": 19,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 81,
                                "slug": "turbulence",
                                "moduleId": 8,
                                "name": "Turbulence",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "\nuniform vec2 iResolution;\nuniform float iTime;\n\nvec3 random3(vec3 point){\n  float d1 = dot(point, vec3(12.3, 32.1, 21.3));\n  float d2 = dot(point, vec3(45.6, 65.4, 54.6));\n  float d3 = dot(point, vec3(78.9, 98.7, 87.9));\n  \n  point = vec3(d1, d2, d3);\n  return fract(sin(point) * 14.7) * 2.0 - 1.0;\n}\n\nfloat noise(vec3 st) {\n  vec3 i = floor(st);\n  vec3 f = fract(st);\n\n  vec3 u = smoothstep(0.0, 1.0, f);\n  \n  float d1 = dot(random3(i + vec3(0.0, 0.0, 0.0)), f - vec3(0.0, 0.0, 0.0));\n  float d2 = dot(random3(i + vec3(1.0, 0.0, 0.0)), f - vec3(1.0, 0.0, 0.0));\n  float d3 = dot(random3(i + vec3(0.0, 1.0, 0.0)), f - vec3(0.0, 1.0, 0.0));\n  float d4 = dot(random3(i + vec3(1.0, 1.0, 0.0)), f - vec3(1.0, 1.0, 0.0));\n  \n  float d5 = dot(random3(i + vec3(0.0, 0.0, 1.0)), f - vec3(0.0, 0.0, 1.0));\n  float d6 = dot(random3(i + vec3(1.0, 0.0, 1.0)), f - vec3(1.0, 0.0, 1.0));\n  float d7 = dot(random3(i + vec3(0.0, 1.0, 1.0)), f - vec3(0.0, 1.0, 1.0));\n  float d8 = dot(random3(i + vec3(1.0, 1.0, 1.0)), f - vec3(1.0, 1.0, 1.0));\n  \n  float m1 = mix(mix(d1, d2, u.x), mix(d3, d4, u.x), u.y);\n  float m2 = mix(mix(d5, d6, u.x), mix(d7, d8, u.x), u.y);\n  \n  return mix(m1, m2, u.z);\n}\n\nfloat turbulence(vec3 st) { \n  const int octaves = 5;\n  float lacunarity = 2.0;\n  float gain = 0.5;\n  \n  float amplitude = 1.0;\n  float frequency = 1.0;\n  \n  float y = 0.0;\n  for (int i = 0; i < octaves; i++) {\n    y += amplitude * abs(noise(frequency * st));\n    frequency *= lacunarity;\n    amplitude *= gain;\n  }\n  \n  return y;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  vec2 ratio = vec2(iResolution.x / iResolution.y, 1.0);\n  \n  float noiseValue = turbulence(vec3(uv * ratio * 2.0 , iTime * 0.1));\n  gl_FragColor = vec4(vec3(noiseValue), 1.0);\n}\n",
                                "postProcessShader": "",
                                "properties": "",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "\nuniform vec2 iResolution;\nuniform float iTime;\n\nvec3 random3(vec3 point){\n  float d1 = dot(point, vec3(12.3, 32.1, 21.3));\n  float d2 = dot(point, vec3(45.6, 65.4, 54.6));\n  float d3 = dot(point, vec3(78.9, 98.7, 87.9));\n  \n  point = vec3(d1, d2, d3);\n  return fract(sin(point) * 14.7) * 2.0 - 1.0;\n}\n\nfloat noise(vec3 st) {\n  vec3 i = floor(st);\n  vec3 f = fract(st);\n\n  vec3 u = smoothstep(0.0, 1.0, f);\n  \n  float d1 = dot(random3(i + vec3(0.0, 0.0, 0.0)), f - vec3(0.0, 0.0, 0.0));\n  float d2 = dot(random3(i + vec3(1.0, 0.0, 0.0)), f - vec3(1.0, 0.0, 0.0));\n  float d3 = dot(random3(i + vec3(0.0, 1.0, 0.0)), f - vec3(0.0, 1.0, 0.0));\n  float d4 = dot(random3(i + vec3(1.0, 1.0, 0.0)), f - vec3(1.0, 1.0, 0.0));\n  \n  float d5 = dot(random3(i + vec3(0.0, 0.0, 1.0)), f - vec3(0.0, 0.0, 1.0));\n  float d6 = dot(random3(i + vec3(1.0, 0.0, 1.0)), f - vec3(1.0, 0.0, 1.0));\n  float d7 = dot(random3(i + vec3(0.0, 1.0, 1.0)), f - vec3(0.0, 1.0, 1.0));\n  float d8 = dot(random3(i + vec3(1.0, 1.0, 1.0)), f - vec3(1.0, 1.0, 1.0));\n  \n  float m1 = mix(mix(d1, d2, u.x), mix(d3, d4, u.x), u.y);\n  float m2 = mix(mix(d5, d6, u.x), mix(d7, d8, u.x), u.y);\n  \n  return mix(m1, m2, u.z);\n}\n\nfloat turbulence(vec3 st) { \n  return 0.0;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  vec2 ratio = vec2(iResolution.x / iResolution.y, 1.0);\n  \n  float noiseValue = turbulence(vec3(uv * ratio * 2.0, iTime * 0.1));\n  gl_FragColor = vec4(vec3(noiseValue), 1.0);\n}\n",
                                "defaultPostProcessShader": "",
                                "defaultProperties": "",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1,\"model\":null,\"meshes\":[{\"name\":\"main\",\"materialId\":0}],\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"materials\":[],\"actions\":[],\"backgroundRGBA\":\"FFFFFF\",\"background\":16777215,\"customDepthBufferTexture\":false,\"glslVersion\":1}",
                                "description": "Turbulence is a function built on the same principle as the fractal Brownian motion. However, instead of using the noise function directly for each layer, we will use the absolute value of the signed noise.\n\n<br>\n\nThis technique with a 2D noise can produce patterns suitable to simulate fire, smoke, or clouds.\n\n### Task\nFind the `turbulence` method declaration and implement its body. Use the following configurations: initial *amplitude* and *frequency* - `1.0`, *octaves* - `5`, *lacunarity* - `2.0`, *gain* - `0.5`.",
                                "hints": [],
                                "restrictions": [],
                                "order": 19,
                                "cost": 5,
                                "threshold": 95,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": true,
                                "animationSteps": 5,
                                "animationStepTime": 200,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "\nuniform vec2 iResolution;\nuniform float iTime;\n\nvec3 random3(vec3 point){\n  float d1 = dot(point, vec3(12.3, 32.1, 21.3));\n  float d2 = dot(point, vec3(45.6, 65.4, 54.6));\n  float d3 = dot(point, vec3(78.9, 98.7, 87.9));\n  \n  point = vec3(d1, d2, d3);\n  return fract(sin(point) * 14.7) * 2.0 - 1.0;\n}\n\nfloat noise(vec3 st) {\n  vec3 i = floor(st);\n  vec3 f = fract(st);\n\n  vec3 u = smoothstep(0.0, 1.0, f);\n  \n  float d1 = dot(random3(i + vec3(0.0, 0.0, 0.0)), f - vec3(0.0, 0.0, 0.0));\n  float d2 = dot(random3(i + vec3(1.0, 0.0, 0.0)), f - vec3(1.0, 0.0, 0.0));\n  float d3 = dot(random3(i + vec3(0.0, 1.0, 0.0)), f - vec3(0.0, 1.0, 0.0));\n  float d4 = dot(random3(i + vec3(1.0, 1.0, 0.0)), f - vec3(1.0, 1.0, 0.0));\n  \n  float d5 = dot(random3(i + vec3(0.0, 0.0, 1.0)), f - vec3(0.0, 0.0, 1.0));\n  float d6 = dot(random3(i + vec3(1.0, 0.0, 1.0)), f - vec3(1.0, 0.0, 1.0));\n  float d7 = dot(random3(i + vec3(0.0, 1.0, 1.0)), f - vec3(0.0, 1.0, 1.0));\n  float d8 = dot(random3(i + vec3(1.0, 1.0, 1.0)), f - vec3(1.0, 1.0, 1.0));\n  \n  float m1 = mix(mix(d1, d2, u.x), mix(d3, d4, u.x), u.y);\n  float m2 = mix(mix(d5, d6, u.x), mix(d7, d8, u.x), u.y);\n  \n  return mix(m1, m2, u.z);\n}\n\nfloat turbulence(vec3 st) { \n  return 0.0;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  vec2 ratio = vec2(iResolution.x / iResolution.y, 1.0);\n  \n  float noiseValue = turbulence(vec3(uv * ratio * 2.0, iTime * 0.1));\n  gl_FragColor = vec4(vec3(noiseValue), 1.0);\n}\n",
                            "postProcessShader": "",
                            "properties": "",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "\nuniform vec2 iResolution;\nuniform float iTime;\n\nvec3 random3(vec3 point){\n  float d1 = dot(point, vec3(12.3, 32.1, 21.3));\n  float d2 = dot(point, vec3(45.6, 65.4, 54.6));\n  float d3 = dot(point, vec3(78.9, 98.7, 87.9));\n  \n  point = vec3(d1, d2, d3);\n  return fract(sin(point) * 14.7) * 2.0 - 1.0;\n}\n\nfloat noise(vec3 st) {\n  vec3 i = floor(st);\n  vec3 f = fract(st);\n\n  vec3 u = smoothstep(0.0, 1.0, f);\n  \n  float d1 = dot(random3(i + vec3(0.0, 0.0, 0.0)), f - vec3(0.0, 0.0, 0.0));\n  float d2 = dot(random3(i + vec3(1.0, 0.0, 0.0)), f - vec3(1.0, 0.0, 0.0));\n  float d3 = dot(random3(i + vec3(0.0, 1.0, 0.0)), f - vec3(0.0, 1.0, 0.0));\n  float d4 = dot(random3(i + vec3(1.0, 1.0, 0.0)), f - vec3(1.0, 1.0, 0.0));\n  \n  float d5 = dot(random3(i + vec3(0.0, 0.0, 1.0)), f - vec3(0.0, 0.0, 1.0));\n  float d6 = dot(random3(i + vec3(1.0, 0.0, 1.0)), f - vec3(1.0, 0.0, 1.0));\n  float d7 = dot(random3(i + vec3(0.0, 1.0, 1.0)), f - vec3(0.0, 1.0, 1.0));\n  float d8 = dot(random3(i + vec3(1.0, 1.0, 1.0)), f - vec3(1.0, 1.0, 1.0));\n  \n  float m1 = mix(mix(d1, d2, u.x), mix(d3, d4, u.x), u.y);\n  float m2 = mix(mix(d5, d6, u.x), mix(d7, d8, u.x), u.y);\n  \n  return mix(m1, m2, u.z);\n}\n\nfloat turbulence(vec3 st) { \n  return 0.0;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  vec2 ratio = vec2(iResolution.x / iResolution.y, 1.0);\n  \n  float noiseValue = turbulence(vec3(uv * ratio * 2.0, iTime * 0.1));\n  gl_FragColor = vec4(vec3(noiseValue), 1.0);\n}\n",
                            "defaultPostProcessShader": "",
                            "defaultProperties": "",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 113,
                        "slug": "marble-texture",
                        "moduleId": 8,
                        "name": "Marble Texture",
                        "order": 22,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 113,
                                "slug": "marble-texture",
                                "moduleId": 8,
                                "name": "Marble Texture",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nvec3 random3(vec3 point){\n  float d1 = dot(point, vec3(12.3, 32.1, 21.3));\n  float d2 = dot(point, vec3(45.6, 65.4, 54.6));\n  float d3 = dot(point, vec3(78.9, 98.7, 87.9));\n  \n  point = vec3(d1, d2, d3);\n  return fract(sin(point) * 14.7) * 2.0 - 1.0;\n}\n\nfloat noise(vec3 st) {\n  vec3 i = floor(st);\n  vec3 f = fract(st);\n\n  vec3 u = smoothstep(0.0, 1.0, f);\n  \n  float d1 = dot(random3(i + vec3(0.0, 0.0, 0.0)), f - vec3(0.0, 0.0, 0.0));\n  float d2 = dot(random3(i + vec3(1.0, 0.0, 0.0)), f - vec3(1.0, 0.0, 0.0));\n  float d3 = dot(random3(i + vec3(0.0, 1.0, 0.0)), f - vec3(0.0, 1.0, 0.0));\n  float d4 = dot(random3(i + vec3(1.0, 1.0, 0.0)), f - vec3(1.0, 1.0, 0.0));\n  \n  float d5 = dot(random3(i + vec3(0.0, 0.0, 1.0)), f - vec3(0.0, 0.0, 1.0));\n  float d6 = dot(random3(i + vec3(1.0, 0.0, 1.0)), f - vec3(1.0, 0.0, 1.0));\n  float d7 = dot(random3(i + vec3(0.0, 1.0, 1.0)), f - vec3(0.0, 1.0, 1.0));\n  float d8 = dot(random3(i + vec3(1.0, 1.0, 1.0)), f - vec3(1.0, 1.0, 1.0));\n  \n  float m1 = mix(mix(d1, d2, u.x), mix(d3, d4, u.x), u.y);\n  float m2 = mix(mix(d5, d6, u.x), mix(d7, d8, u.x), u.y);\n  \n  return mix(m1, m2, u.z);\n}\n\nfloat turbulence(vec3 st) { \n  const int octaves = 5;\n  float lacunarity = 2.0;\n  float gain = 0.5;\n  \n  float amplitude = 1.0;\n  float frequency = 1.0;\n  \n  float y = 0.0;\n  for (int i = 0; i < octaves; i++) {\n    y += amplitude * abs(noise(frequency * st));\n    frequency *= lacunarity;\n    amplitude *= gain;\n  }\n  \n  return y;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  vec2 ratio = vec2(iResolution.x / iResolution.y, 1.0);\n  \n  float noiseValue = turbulence(vec3(uv * ratio , iTime * 0.1));\n  \n  float t = (uv.x + noiseValue * 0.25) * 6.28 * 4.0;\n  float result = sin(t) * 0.5 + 0.5;\n  \n  gl_FragColor = vec4(vec3(result), 1.0);\n}",
                                "postProcessShader": "",
                                "properties": "",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nvec3 random3(vec3 point){\n  float d1 = dot(point, vec3(12.3, 32.1, 21.3));\n  float d2 = dot(point, vec3(45.6, 65.4, 54.6));\n  float d3 = dot(point, vec3(78.9, 98.7, 87.9));\n  \n  point = vec3(d1, d2, d3);\n  return fract(sin(point) * 14.7) * 2.0 - 1.0;\n}\n\nfloat noise(vec3 st) {\n  vec3 i = floor(st);\n  vec3 f = fract(st);\n\n  vec3 u = smoothstep(0.0, 1.0, f);\n  \n  float d1 = dot(random3(i + vec3(0.0, 0.0, 0.0)), f - vec3(0.0, 0.0, 0.0));\n  float d2 = dot(random3(i + vec3(1.0, 0.0, 0.0)), f - vec3(1.0, 0.0, 0.0));\n  float d3 = dot(random3(i + vec3(0.0, 1.0, 0.0)), f - vec3(0.0, 1.0, 0.0));\n  float d4 = dot(random3(i + vec3(1.0, 1.0, 0.0)), f - vec3(1.0, 1.0, 0.0));\n  \n  float d5 = dot(random3(i + vec3(0.0, 0.0, 1.0)), f - vec3(0.0, 0.0, 1.0));\n  float d6 = dot(random3(i + vec3(1.0, 0.0, 1.0)), f - vec3(1.0, 0.0, 1.0));\n  float d7 = dot(random3(i + vec3(0.0, 1.0, 1.0)), f - vec3(0.0, 1.0, 1.0));\n  float d8 = dot(random3(i + vec3(1.0, 1.0, 1.0)), f - vec3(1.0, 1.0, 1.0));\n  \n  float m1 = mix(mix(d1, d2, u.x), mix(d3, d4, u.x), u.y);\n  float m2 = mix(mix(d5, d6, u.x), mix(d7, d8, u.x), u.y);\n  \n  return mix(m1, m2, u.z);\n}\n\nfloat turbulence(vec3 st) { \n  return 0.0;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  vec2 ratio = vec2(iResolution.x / iResolution.y, 1.0);\n  \n  float noiseValue = turbulence(vec3(uv * ratio , iTime * 0.1));\n  \n  gl_FragColor = vec4(vec3(noiseValue), 1.0);\n}\n",
                                "defaultPostProcessShader": "",
                                "defaultProperties": "",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1,\"model\":null,\"meshes\":[{\"name\":\"main\",\"materialId\":0}],\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"materials\":[],\"actions\":[],\"backgroundRGBA\":\"FFFFFF\",\"background\":16777215,\"customDepthBufferTexture\":false,\"glslVersion\":1}",
                                "description": "A marble texture can be created by distorting the phase of some periodic function with a noise or a fractal sum.\n\n### Task\nLet's shift the phase of the sine with the turbulence noise. \n\n<br>\n\nUse the following configurations for the turbulence noise: initial *amplitude* and *frequency* - `1.0`, *octaves* - `5`, *lacunarity* - `2.0`, *gain* - `0.5`.\n\n<br>\n\nDisplay 4 periods of the sine wave using the x-coordinate as an argument, but shift it using the noise value with a multiplier of `0.25`.",
                                "hints": [],
                                "restrictions": [],
                                "order": 22,
                                "cost": 5,
                                "threshold": 95,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": true,
                                "animationSteps": 5,
                                "animationStepTime": 200,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nvec3 random3(vec3 point){\n  float d1 = dot(point, vec3(12.3, 32.1, 21.3));\n  float d2 = dot(point, vec3(45.6, 65.4, 54.6));\n  float d3 = dot(point, vec3(78.9, 98.7, 87.9));\n  \n  point = vec3(d1, d2, d3);\n  return fract(sin(point) * 14.7) * 2.0 - 1.0;\n}\n\nfloat noise(vec3 st) {\n  vec3 i = floor(st);\n  vec3 f = fract(st);\n\n  vec3 u = smoothstep(0.0, 1.0, f);\n  \n  float d1 = dot(random3(i + vec3(0.0, 0.0, 0.0)), f - vec3(0.0, 0.0, 0.0));\n  float d2 = dot(random3(i + vec3(1.0, 0.0, 0.0)), f - vec3(1.0, 0.0, 0.0));\n  float d3 = dot(random3(i + vec3(0.0, 1.0, 0.0)), f - vec3(0.0, 1.0, 0.0));\n  float d4 = dot(random3(i + vec3(1.0, 1.0, 0.0)), f - vec3(1.0, 1.0, 0.0));\n  \n  float d5 = dot(random3(i + vec3(0.0, 0.0, 1.0)), f - vec3(0.0, 0.0, 1.0));\n  float d6 = dot(random3(i + vec3(1.0, 0.0, 1.0)), f - vec3(1.0, 0.0, 1.0));\n  float d7 = dot(random3(i + vec3(0.0, 1.0, 1.0)), f - vec3(0.0, 1.0, 1.0));\n  float d8 = dot(random3(i + vec3(1.0, 1.0, 1.0)), f - vec3(1.0, 1.0, 1.0));\n  \n  float m1 = mix(mix(d1, d2, u.x), mix(d3, d4, u.x), u.y);\n  float m2 = mix(mix(d5, d6, u.x), mix(d7, d8, u.x), u.y);\n  \n  return mix(m1, m2, u.z);\n}\n\nfloat turbulence(vec3 st) { \n  return 0.0;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  vec2 ratio = vec2(iResolution.x / iResolution.y, 1.0);\n  \n  float noiseValue = turbulence(vec3(uv * ratio , iTime * 0.1));\n  \n  gl_FragColor = vec4(vec3(noiseValue), 1.0);\n}\n",
                            "postProcessShader": "",
                            "properties": "",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nvec3 random3(vec3 point){\n  float d1 = dot(point, vec3(12.3, 32.1, 21.3));\n  float d2 = dot(point, vec3(45.6, 65.4, 54.6));\n  float d3 = dot(point, vec3(78.9, 98.7, 87.9));\n  \n  point = vec3(d1, d2, d3);\n  return fract(sin(point) * 14.7) * 2.0 - 1.0;\n}\n\nfloat noise(vec3 st) {\n  vec3 i = floor(st);\n  vec3 f = fract(st);\n\n  vec3 u = smoothstep(0.0, 1.0, f);\n  \n  float d1 = dot(random3(i + vec3(0.0, 0.0, 0.0)), f - vec3(0.0, 0.0, 0.0));\n  float d2 = dot(random3(i + vec3(1.0, 0.0, 0.0)), f - vec3(1.0, 0.0, 0.0));\n  float d3 = dot(random3(i + vec3(0.0, 1.0, 0.0)), f - vec3(0.0, 1.0, 0.0));\n  float d4 = dot(random3(i + vec3(1.0, 1.0, 0.0)), f - vec3(1.0, 1.0, 0.0));\n  \n  float d5 = dot(random3(i + vec3(0.0, 0.0, 1.0)), f - vec3(0.0, 0.0, 1.0));\n  float d6 = dot(random3(i + vec3(1.0, 0.0, 1.0)), f - vec3(1.0, 0.0, 1.0));\n  float d7 = dot(random3(i + vec3(0.0, 1.0, 1.0)), f - vec3(0.0, 1.0, 1.0));\n  float d8 = dot(random3(i + vec3(1.0, 1.0, 1.0)), f - vec3(1.0, 1.0, 1.0));\n  \n  float m1 = mix(mix(d1, d2, u.x), mix(d3, d4, u.x), u.y);\n  float m2 = mix(mix(d5, d6, u.x), mix(d7, d8, u.x), u.y);\n  \n  return mix(m1, m2, u.z);\n}\n\nfloat turbulence(vec3 st) { \n  return 0.0;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  vec2 ratio = vec2(iResolution.x / iResolution.y, 1.0);\n  \n  float noiseValue = turbulence(vec3(uv * ratio , iTime * 0.1));\n  \n  gl_FragColor = vec4(vec3(noiseValue), 1.0);\n}\n",
                            "defaultPostProcessShader": "",
                            "defaultProperties": "",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 75,
                        "slug": "ridget",
                        "moduleId": 8,
                        "name": "Ridget",
                        "order": 23,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 75,
                                "slug": "ridget",
                                "moduleId": 8,
                                "name": "Ridget",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nvec3 random3(vec3 point){\n  float d1 = dot(point, vec3(12.3, 32.1, 21.3));\n  float d2 = dot(point, vec3(45.6, 65.4, 54.6));\n  float d3 = dot(point, vec3(78.9, 98.7, 87.9));\n  \n  point = vec3(d1, d2, d3);\n  return fract(sin(point) * 14.7) * 2.0 - 1.0;\n}\n\nfloat noise(vec3 st) {\n  vec3 i = floor(st);\n  vec3 f = fract(st);\n\n  vec3 u = smoothstep(0.0, 1.0, f);\n  \n  float d1 = dot(random3(i + vec3(0.0, 0.0, 0.0)), f - vec3(0.0, 0.0, 0.0));\n  float d2 = dot(random3(i + vec3(1.0, 0.0, 0.0)), f - vec3(1.0, 0.0, 0.0));\n  float d3 = dot(random3(i + vec3(0.0, 1.0, 0.0)), f - vec3(0.0, 1.0, 0.0));\n  float d4 = dot(random3(i + vec3(1.0, 1.0, 0.0)), f - vec3(1.0, 1.0, 0.0));\n  \n  float d5 = dot(random3(i + vec3(0.0, 0.0, 1.0)), f - vec3(0.0, 0.0, 1.0));\n  float d6 = dot(random3(i + vec3(1.0, 0.0, 1.0)), f - vec3(1.0, 0.0, 1.0));\n  float d7 = dot(random3(i + vec3(0.0, 1.0, 1.0)), f - vec3(0.0, 1.0, 1.0));\n  float d8 = dot(random3(i + vec3(1.0, 1.0, 1.0)), f - vec3(1.0, 1.0, 1.0));\n  \n  float m1 = mix(mix(d1, d2, u.x), mix(d3, d4, u.x), u.y);\n  float m2 = mix(mix(d5, d6, u.x), mix(d7, d8, u.x), u.y);\n  \n  return mix(m1, m2, u.z);\n}\n\nfloat ridge(float h) {\n  h = abs(h);\n  h = 1.0 - h;\n  h = h * h;\n  return h;\n}\n\nfloat ridget(vec3 st) { \n  const int octaves = 5;\n  float lacunarity = 2.0;\n  float gain = 0.5;\n  \n  float amplitude = 1.0;\n  float frequency = 1.0;\n  \n  float y = 0.0;\n  float normalization = 0.0;\n  for (int i = 0; i < octaves; i++) {\n    y += amplitude * ridge(noise(frequency * st));\n    normalization += amplitude;\n    frequency *= lacunarity;\n    amplitude *= gain;\n  }\n  \n  return y / normalization;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  vec2 ratio = vec2(iResolution.x / iResolution.y, 1.0);\n  \n  float noiseValue = ridget(vec3(uv * ratio * 2.0, iTime * 0.1));\n\n  gl_FragColor = vec4(vec3(noiseValue), 1.0);\n}",
                                "postProcessShader": "",
                                "properties": "",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nvec3 random3(vec3 point){\n  float d1 = dot(point, vec3(12.3, 32.1, 21.3));\n  float d2 = dot(point, vec3(45.6, 65.4, 54.6));\n  float d3 = dot(point, vec3(78.9, 98.7, 87.9));\n  \n  point = vec3(d1, d2, d3);\n  return fract(sin(point) * 14.7) * 2.0 - 1.0;\n}\n\nfloat noise(vec3 st) {\n  vec3 i = floor(st);\n  vec3 f = fract(st);\n\n  vec3 u = smoothstep(0.0, 1.0, f);\n  \n  float d1 = dot(random3(i + vec3(0.0, 0.0, 0.0)), f - vec3(0.0, 0.0, 0.0));\n  float d2 = dot(random3(i + vec3(1.0, 0.0, 0.0)), f - vec3(1.0, 0.0, 0.0));\n  float d3 = dot(random3(i + vec3(0.0, 1.0, 0.0)), f - vec3(0.0, 1.0, 0.0));\n  float d4 = dot(random3(i + vec3(1.0, 1.0, 0.0)), f - vec3(1.0, 1.0, 0.0));\n  \n  float d5 = dot(random3(i + vec3(0.0, 0.0, 1.0)), f - vec3(0.0, 0.0, 1.0));\n  float d6 = dot(random3(i + vec3(1.0, 0.0, 1.0)), f - vec3(1.0, 0.0, 1.0));\n  float d7 = dot(random3(i + vec3(0.0, 1.0, 1.0)), f - vec3(0.0, 1.0, 1.0));\n  float d8 = dot(random3(i + vec3(1.0, 1.0, 1.0)), f - vec3(1.0, 1.0, 1.0));\n  \n  float m1 = mix(mix(d1, d2, u.x), mix(d3, d4, u.x), u.y);\n  float m2 = mix(mix(d5, d6, u.x), mix(d7, d8, u.x), u.y);\n  \n  return mix(m1, m2, u.z);\n}\n\nfloat ridget(vec3 st) { \n  return 0.0;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  vec2 ratio = vec2(iResolution.x / iResolution.y, 1.0);\n  \n  float noiseValue = ridget(vec3(uv * ratio * 2.0, iTime * 0.1));\n  gl_FragColor = vec4(vec3(noiseValue), 1.0);\n}\n",
                                "defaultPostProcessShader": "",
                                "defaultProperties": "",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1,\"model\":null,\"meshes\":[{\"name\":\"main\",\"materialId\":0}],\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"materials\":[],\"actions\":[],\"backgroundRGBA\":\"FFFFFF\",\"background\":16777215,\"customDepthBufferTexture\":false,\"glslVersion\":1}",
                                "description": "The algorithm for generating ridged fractal noise involves iterating over multiple octaves of noise, each with increasing frequency and decreasing amplitude. At each octave, the noise is modified by taking the absolute value and subtracting it from one, which creates sharp ridges in the output. The resulting noise values are then multiplied by the current amplitude and added to a running total. The maximum possible value is also tracked to normalize the final output. Finally, the total is divided by the maximum possible value to adjust the range of the output values.\n\n### Task\nFind the `ridget` method declaration and implement its body. Use the following configurations: initial *amplitude* and *frequency* - `1.0`, *octaves* - `5`, *lacunarity* - `2.0`, *gain* - `0.5`.",
                                "hints": [],
                                "restrictions": [],
                                "order": 23,
                                "cost": 5,
                                "threshold": 95,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": true,
                                "animationSteps": 5,
                                "animationStepTime": 200,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nvec3 random3(vec3 point){\n  float d1 = dot(point, vec3(12.3, 32.1, 21.3));\n  float d2 = dot(point, vec3(45.6, 65.4, 54.6));\n  float d3 = dot(point, vec3(78.9, 98.7, 87.9));\n  \n  point = vec3(d1, d2, d3);\n  return fract(sin(point) * 14.7) * 2.0 - 1.0;\n}\n\nfloat noise(vec3 st) {\n  vec3 i = floor(st);\n  vec3 f = fract(st);\n\n  vec3 u = smoothstep(0.0, 1.0, f);\n  \n  float d1 = dot(random3(i + vec3(0.0, 0.0, 0.0)), f - vec3(0.0, 0.0, 0.0));\n  float d2 = dot(random3(i + vec3(1.0, 0.0, 0.0)), f - vec3(1.0, 0.0, 0.0));\n  float d3 = dot(random3(i + vec3(0.0, 1.0, 0.0)), f - vec3(0.0, 1.0, 0.0));\n  float d4 = dot(random3(i + vec3(1.0, 1.0, 0.0)), f - vec3(1.0, 1.0, 0.0));\n  \n  float d5 = dot(random3(i + vec3(0.0, 0.0, 1.0)), f - vec3(0.0, 0.0, 1.0));\n  float d6 = dot(random3(i + vec3(1.0, 0.0, 1.0)), f - vec3(1.0, 0.0, 1.0));\n  float d7 = dot(random3(i + vec3(0.0, 1.0, 1.0)), f - vec3(0.0, 1.0, 1.0));\n  float d8 = dot(random3(i + vec3(1.0, 1.0, 1.0)), f - vec3(1.0, 1.0, 1.0));\n  \n  float m1 = mix(mix(d1, d2, u.x), mix(d3, d4, u.x), u.y);\n  float m2 = mix(mix(d5, d6, u.x), mix(d7, d8, u.x), u.y);\n  \n  return mix(m1, m2, u.z);\n}\n\nfloat ridget(vec3 st) { \n  return 0.0;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  vec2 ratio = vec2(iResolution.x / iResolution.y, 1.0);\n  \n  float noiseValue = ridget(vec3(uv * ratio * 2.0, iTime * 0.1));\n  gl_FragColor = vec4(vec3(noiseValue), 1.0);\n}\n",
                            "postProcessShader": "",
                            "properties": "",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nvec3 random3(vec3 point){\n  float d1 = dot(point, vec3(12.3, 32.1, 21.3));\n  float d2 = dot(point, vec3(45.6, 65.4, 54.6));\n  float d3 = dot(point, vec3(78.9, 98.7, 87.9));\n  \n  point = vec3(d1, d2, d3);\n  return fract(sin(point) * 14.7) * 2.0 - 1.0;\n}\n\nfloat noise(vec3 st) {\n  vec3 i = floor(st);\n  vec3 f = fract(st);\n\n  vec3 u = smoothstep(0.0, 1.0, f);\n  \n  float d1 = dot(random3(i + vec3(0.0, 0.0, 0.0)), f - vec3(0.0, 0.0, 0.0));\n  float d2 = dot(random3(i + vec3(1.0, 0.0, 0.0)), f - vec3(1.0, 0.0, 0.0));\n  float d3 = dot(random3(i + vec3(0.0, 1.0, 0.0)), f - vec3(0.0, 1.0, 0.0));\n  float d4 = dot(random3(i + vec3(1.0, 1.0, 0.0)), f - vec3(1.0, 1.0, 0.0));\n  \n  float d5 = dot(random3(i + vec3(0.0, 0.0, 1.0)), f - vec3(0.0, 0.0, 1.0));\n  float d6 = dot(random3(i + vec3(1.0, 0.0, 1.0)), f - vec3(1.0, 0.0, 1.0));\n  float d7 = dot(random3(i + vec3(0.0, 1.0, 1.0)), f - vec3(0.0, 1.0, 1.0));\n  float d8 = dot(random3(i + vec3(1.0, 1.0, 1.0)), f - vec3(1.0, 1.0, 1.0));\n  \n  float m1 = mix(mix(d1, d2, u.x), mix(d3, d4, u.x), u.y);\n  float m2 = mix(mix(d5, d6, u.x), mix(d7, d8, u.x), u.y);\n  \n  return mix(m1, m2, u.z);\n}\n\nfloat ridget(vec3 st) { \n  return 0.0;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  vec2 ratio = vec2(iResolution.x / iResolution.y, 1.0);\n  \n  float noiseValue = ridget(vec3(uv * ratio * 2.0, iTime * 0.1));\n  gl_FragColor = vec4(vec3(noiseValue), 1.0);\n}\n",
                            "defaultPostProcessShader": "",
                            "defaultProperties": "",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    }
                ],
                "cover": true,
                "pageHeaderImage": true,
                "fullDesc": "This module is designed for users who want to learn how to generate random values in shaders and explore various noise algorithms. You will study different types of noise and their applications in creating visual effects. Each topic includes theoretical material and practical tasks that can be completed directly on the website.",
                "skillsDesc": "how to generate random values in shaders.<br>various noise algorithms, including value noise, gradient noise, FBM, turbulence, and ridged noise.<br>apply these noise algorithms to create realistic and complex visual effects.",
                "importanceDesc": "Noise functions are essential for creating natural and complex visual effects in computer graphics. Understanding how to generate and manipulate noise allows developers to simulate a wide range of phenomena such as textures, terrains, clouds, and fire. Mastery of these techniques is crucial for advanced graphics applications in games, simulations, and visual effects.",
                "certifiable": false,
                "images": [
                    "img-6.png",
                    "img-1.png",
                    "img-2.png",
                    "img-3.png",
                    "img-4.png",
                    "img-5.png"
                ]
            }
        },
        {
            "id": 11,
            "slug": "advanced-rendering",
            "name": "Advanced Rendering",
            "description": "Modern advanced rendering techniques in computer graphics leverage the power of hardware to create visually stunning and highly realistic scenes in real-time.",
            "tasks": 17,
            "acceptedTasks": 0,
            "isOpen": false,
            "order": 7,
            "locked": false,
            "cover": true,
            "child": {
                "id": 11,
                "slug": "advanced-rendering",
                "name": "Advanced Rendering",
                "description": "Modern advanced rendering techniques in computer graphics leverage the power of hardware to create visually stunning and highly realistic scenes in real-time.",
                "order": 7,
                "createdBy": {
                    "id": 3,
                    "name": "Alexander"
                },
                "locked": false,
                "tasks": [
                    {
                        "id": 183,
                        "slug": "ins-and-outs",
                        "moduleId": 11,
                        "name": "Ins and outs",
                        "order": 0,
                        "cost": 10,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": 0,
                        "premium": false,
                        "child": {
                            "task": {
                                "id": 183,
                                "slug": "ins-and-outs",
                                "moduleId": 11,
                                "name": "Ins and outs",
                                "vertexShader": "uniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\nin vec3 position;\nin vec3 normal;\nin vec4 color;\n\nout vec4 vColor;\nout vec3 vNormal;\n\nvoid main() {\n  vColor = color;\n  vNormal = mat3(transpose(inverse(modelMatrix))) * normal;\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "in vec4 vColor;\nin vec3 vNormal;\n\nout vec4 FragColor;\n\nconst vec3 lightColor = vec3(2.0);\nconst vec3 lightDir   = normalize(vec3(1.0));\n\nvoid main() {\n  vec3 normal = normalize(vNormal);\n  float diffuse = max(0.0, dot(lightDir, normal));\n  \n  FragColor = vec4(vColor.rgb * lightColor * diffuse, 1.0);\n}\n",
                                "postProcessShader": "",
                                "properties": "",
                                "defaultVertexShader": "uniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\nin vec3 position;\nin vec3 normal;\nin vec4 color;\n\nvoid main() {\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "const vec3 lightColor = vec3(2.0);\nconst vec3 lightDir   = normalize(vec3(1.0)); // world space\n\nvoid main() { }",
                                "defaultPostProcessShader": "",
                                "defaultProperties": "",
                                "vertexCodeEditable": true,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-1,\"y\":5,\"z\":9},\"rotation\":{\"x\":-0.3,\"y\":0,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":45,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":-0.7,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":\"10\",\"model\":\"Cow.glb\",\"meshes\":[{\"name\":\"Cow_1\",\"materialId\":0},{\"name\":\"Cow_2\",\"materialId\":0},{\"name\":\"Cow_3\",\"materialId\":0},{\"name\":\"Cow_4\",\"materialId\":0},{\"name\":\"Cow_5\",\"materialId\":0},{\"name\":\"Cow_6\",\"materialId\":0},{\"name\":\"Cow_7\",\"materialId\":0}],\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"materials\":[],\"actions\":[],\"backgroundRGBA\":\"CCCCCC\",\"background\":13421772,\"customDepthBufferTexture\":false,\"glslVersion\":\"3\"}",
                                "description": "In **OpenGL 3.3**, shaders use `in` and `out` attributes to pass data between different stages of the rendering pipeline. This tutorial will guide you through the basics of using these attributes to transfer parameters between vertex and fragment shaders.\n\n<br>\n\n### Vertex Shader\n\n<br>\n\nThe vertex shader processes each vertex and passes data to the fragment shader:\n\n```\n// Input attributes from the vertex buffer\nin vec4 color;\n\n// Output attributes to the fragment shader\nout vec4 vColor;\n\nvoid main() {\n    vColor = color;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n```\n\n### Fragment Shader\n\n<br>\n\nThe fragment shader receives data from the vertex shader and processes each fragment:\n```\n// Input attributes from the vertex shader\nin vec4 vColor;\n\n// Output color to the framebuffer\nout vec4 FragColor;\n\nvoid main() {\n    FragColor = vColor;\n}\n```\n\n### Attribute Names and Types\n\n<br>\n\nIt's important to note that the names and types of the `in` and `out` attributes must match between shaders. For example, if the vertex shader outputs a variable named `vColor` of type `vec4`, the fragment shader must have an input variable with the same name `vColor` and the same type `vec4`. This ensures that the data is correctly passed from one shader stage to the next.\n\n<br>\n\nThe `out` attribute in the fragment shader typically outputs a `vec4` representing the **RGBA** color. This should match the color format of the framebuffer. For example, if your framebuffer is set up to use an **RGBA** format, your fragment shader should output a `vec4`.\n\n### Task\n\nCreate a program that passes the fragment normal in world space and it's color from the vertex shader to the fragment shader and implements diffuse lighting.",
                                "hints": [],
                                "restrictions": [],
                                "order": 0,
                                "cost": 10,
                                "threshold": 99,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": false
                            },
                            "vertexShader": "uniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\nin vec3 position;\nin vec3 normal;\nin vec4 color;\n\nvoid main() {\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "const vec3 lightColor = vec3(2.0);\nconst vec3 lightDir   = normalize(vec3(1.0)); // world space\n\nvoid main() { }",
                            "postProcessShader": "",
                            "properties": "",
                            "defaultVertexShader": "uniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\nin vec3 position;\nin vec3 normal;\nin vec4 color;\n\nvoid main() {\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "const vec3 lightColor = vec3(2.0);\nconst vec3 lightDir   = normalize(vec3(1.0)); // world space\n\nvoid main() { }",
                            "defaultPostProcessShader": "",
                            "defaultProperties": "",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 184,
                        "slug": "blending",
                        "moduleId": 11,
                        "name": "Blending",
                        "order": 1,
                        "cost": 10,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": 0,
                        "premium": false,
                        "child": {
                            "task": {
                                "id": 184,
                                "slug": "blending",
                                "moduleId": 11,
                                "name": "Blending",
                                "vertexShader": "uniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\nin vec3 position;\nin vec2 uv;\n\nout vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}",
                                "fragmentShader": "uniform float iTime;\n\nin vec2 vUv;\n\nout vec4 FragColor;\n\nfloat random(float x) {\n   float r = fract(sin(x * 12.34) * 1234.5678);\n   return r;\n}\n\nvoid main() {\n  float r = distance(vec2(0.5), vUv);\n  float t = 1.0 - smoothstep(0.0, 0.5, r);\n  float f = random(iTime) * 0.1 + 0.9;\n  FragColor = vec4(1.0, 0.8, 0.0, t * 0.5 * f);\n}\n",
                                "postProcessShader": "",
                                "properties": "DepthTest = false\nBlending = Blending.ALPHA",
                                "defaultVertexShader": "uniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\nin vec3 position;\nin vec2 uv;\n\nout vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}",
                                "defaultFragmentShader": "uniform float iTime;\n\nin vec2 vUv;\n\nout vec4 FragColor;\n\nfloat random(float x) {\n   float r = fract(sin(x * 12.34) * 1234.5678);\n   return r;\n}\n\nvoid main() {\n  float r = distance(vec2(0.5), vUv);\n  float t = 1.0 - smoothstep(0.0, 0.5, r);\n  float f = random(iTime) * 0.1 + 0.9;\n  FragColor = vec4(1.0, 0.8, 0.0, t * 0.5 * f);\n}\n",
                                "defaultPostProcessShader": "",
                                "defaultProperties": "DepthTest = false\nBlending = Blending.NO",
                                "vertexCodeEditable": true,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": true,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":0,\"y\":0.75,\"z\":1},\"rotation\":{\"x\":-0.25,\"y\":0,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":45,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0.04,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":\"10\",\"model\":\"Candle.glb\",\"meshes\":[{\"name\":\"Candle\",\"materialId\":2},{\"name\":\"Flame\",\"materialId\":1},{\"name\":\"Rope\",\"materialId\":1}],\"colorRGBA\":\"FFFFFF\",\"color\":null},{\"position\":{\"x\":0,\"y\":0.525,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":0.75,\"y\":0.75,\"z\":0.75},\"geometry\":1,\"model\":null,\"meshes\":[{\"name\":\"main\",\"materialId\":0}],\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"materials\":[{\"vertex\":\"uniform mat4 modelMatrix;\\nuniform mat4 viewMatrix;\\nuniform mat4 projectionMatrix;\\n\\nin vec3 position;\\nin vec3 normal;\\nin vec4 color;\\n\\nout vec4 vColor;\\n\\nvoid main() {\\n  vColor = color;\\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\\n}\\n\",\"fragment\":\"in vec4 vColor;\\n\\nout vec4 FragColor;\\n\\nvoid main() {\\n  FragColor = vec4(1.0, 0.5, 0.0, 1.0);\\n}\\n\",\"properties\":\"\"},{\"vertex\":\"uniform mat4 modelMatrix;\\nuniform mat4 viewMatrix;\\nuniform mat4 projectionMatrix;\\n\\nin vec3 position;\\nin vec3 normal;\\nin vec4 color;\\n\\nout vec4 vColor;\\nout vec3 vNormal;\\nout vec3 vPos;\\n\\nvoid main() {\\n  vColor = color;\\n  vNormal = normalize(mat3(transpose(inverse(modelMatrix))) * normal);\\n  \\n  vec4 worldPos = modelMatrix * vec4(position, 1.0);\\n  vPos = worldPos.xyz;\\n  \\n  gl_Position = projectionMatrix * viewMatrix * worldPos;\\n}\\n\",\"fragment\":\"uniform float iTime;\\n\\nin vec4 vColor;\\nin vec3 vNormal;\\nin vec3 vPos;\\n\\nconst vec3 lightPos0 = vec3(0.0, 2.0, 0.5);\\nconst vec3 lightPos1 = vec3(0.0, 2.0, -.5);\\nconst vec3 lightCol = vec3(1.0, 0.9, 0.8);\\n\\nout vec4 FragColor;\\n\\nfloat random(float x) {\\n   float r = fract(sin(x * 12.34) * 1234.5678);\\n   return r;\\n}\\n\\nvoid main() {\\n  vec3 normal = normalize(vNormal);\\n  \\n  vec3 lightDir0 = normalize(lightPos0 - vPos);\\n  float diffuse0 = max(0.0, dot(normalize(vNormal), lightDir0));\\n\\n  vec3 lightDir1 = normalize(lightPos1 - vPos);\\n  float diffuse1 = max(0.0, dot(normalize(vNormal), lightDir1));\\n\\n  float diffuse = diffuse0 + diffuse1;\\n\\n  float f = random(iTime) * 0.25 + 0.75;\\n  \\n  FragColor = vec4(vColor.rgb * lightCol * f * (diffuse + 0.25), vColor.a);\\n}\\n\",\"properties\":\"\"}],\"actions\":[],\"backgroundRGBA\":\"111111\",\"background\":1118481,\"customDepthBufferTexture\":false,\"glslVersion\":\"3\"}",
                                "description": "Blending is a technique used to combine the color of a source pixel (the pixel being drawn) with the color of a destination pixel (the pixel already in the framebuffer).\n\n<br>\n\n### No Blending\n\n<br>\n\nWhen blending is disabled, the colors of the source pixels are directly written to the framebuffer without any modification. In this mode, the source color completely replaces the destination color in the framebuffer.\n\n<br>\n\n### Alpha Blending\n\n<br>\n\nAlpha blending is used to create transparency effects. It combines the source and destination colors based on the alpha value of the source color. The alpha value represents the opacity of the source color, where 0 is fully transparent and 1 is fully opaque.\n\n<br>\n\nThe blending equation for alpha blending is:\n```\nFinalColor = (SrcColor * SrcAlpha) + (DstColor * (1 − SrcAlpha))\n```\n\n### Task\n\nCreate a program that renders a candle with a halo effect. Initially, the halo is rendered without blending. Modify the program to use alpha blending for the halo effect by changing the blending settings in a `.properties` file.\n\n<br>\n\nYou can use the `Ctrl+Space` shortcut while editing the file to see autocomplete suggestions.\n",
                                "hints": [],
                                "restrictions": [],
                                "order": 1,
                                "cost": 10,
                                "threshold": 99,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": true,
                                "animationSteps": 10,
                                "animationStepTime": 200,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": false
                            },
                            "vertexShader": "uniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\nin vec3 position;\nin vec2 uv;\n\nout vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}",
                            "fragmentShader": "uniform float iTime;\n\nin vec2 vUv;\n\nout vec4 FragColor;\n\nfloat random(float x) {\n   float r = fract(sin(x * 12.34) * 1234.5678);\n   return r;\n}\n\nvoid main() {\n  float r = distance(vec2(0.5), vUv);\n  float t = 1.0 - smoothstep(0.0, 0.5, r);\n  float f = random(iTime) * 0.1 + 0.9;\n  FragColor = vec4(1.0, 0.8, 0.0, t * 0.5 * f);\n}\n",
                            "postProcessShader": "",
                            "properties": "DepthTest = false\nBlending = Blending.NO",
                            "defaultVertexShader": "uniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\nin vec3 position;\nin vec2 uv;\n\nout vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}",
                            "defaultFragmentShader": "uniform float iTime;\n\nin vec2 vUv;\n\nout vec4 FragColor;\n\nfloat random(float x) {\n   float r = fract(sin(x * 12.34) * 1234.5678);\n   return r;\n}\n\nvoid main() {\n  float r = distance(vec2(0.5), vUv);\n  float t = 1.0 - smoothstep(0.0, 0.5, r);\n  float f = random(iTime) * 0.1 + 0.9;\n  FragColor = vec4(1.0, 0.8, 0.0, t * 0.5 * f);\n}\n",
                            "defaultPostProcessShader": "",
                            "defaultProperties": "DepthTest = false\nBlending = Blending.NO",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 185,
                        "slug": "blending-addidtive",
                        "moduleId": 11,
                        "name": "Blending - Addidtive",
                        "order": 2,
                        "cost": 10,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": 0,
                        "premium": false,
                        "child": {
                            "task": {
                                "id": 185,
                                "slug": "blending-addidtive",
                                "moduleId": 11,
                                "name": "Blending - Addidtive",
                                "vertexShader": "uniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\nin vec3 position;\nin vec2 uv;\n\nout vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}",
                                "fragmentShader": "uniform float iTime;\n\nin vec2 vUv;\n\nout vec4 FragColor;\n\nfloat random(float x) {\n   float r = fract(sin(x * 12.34) * 1234.5678);\n   return r;\n}\n\nvoid main() {\n  float r = distance(vec2(0.5), vUv);\n  float t = 1.0 - smoothstep(0.0, 0.5, r);\n  float f = random(iTime) * 0.1 + 0.9;\n  FragColor = vec4(1.0, 0.8, 0.0, t * 0.5 * f);\n}\n",
                                "postProcessShader": "",
                                "properties": "DepthTest = false\nBlending = Blending.ADDITIVE",
                                "defaultVertexShader": "uniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\nin vec3 position;\nin vec2 uv;\n\nout vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}",
                                "defaultFragmentShader": "uniform float iTime;\n\nin vec2 vUv;\n\nout vec4 FragColor;\n\nfloat random(float x) {\n   float r = fract(sin(x * 12.34) * 1234.5678);\n   return r;\n}\n\nvoid main() {\n  float r = distance(vec2(0.5), vUv);\n  float t = 1.0 - smoothstep(0.0, 0.5, r);\n  float f = random(iTime) * 0.1 + 0.9;\n  FragColor = vec4(1.0, 0.8, 0.0, t * 0.5 * f);\n}\n",
                                "defaultPostProcessShader": "",
                                "defaultProperties": "DepthTest = false\nBlending = Blending.ALPHA",
                                "vertexCodeEditable": true,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": true,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":0,\"y\":0.75,\"z\":1},\"rotation\":{\"x\":-0.25,\"y\":0,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":45,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0.04,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":\"10\",\"model\":\"Candle.glb\",\"meshes\":[{\"name\":\"Candle\",\"materialId\":2},{\"name\":\"Flame\",\"materialId\":1},{\"name\":\"Rope\",\"materialId\":1}],\"colorRGBA\":\"FFFFFF\",\"color\":null},{\"position\":{\"x\":0,\"y\":0.5,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1,\"model\":null,\"meshes\":[{\"name\":\"main\",\"materialId\":0}],\"colorRGBA\":\"FFFFFF\",\"color\":null},{\"position\":{\"x\":0,\"y\":0.5,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":0.5,\"y\":0.5,\"z\":0.5},\"geometry\":1,\"model\":null,\"meshes\":[{\"name\":\"main\",\"materialId\":0}],\"colorRGBA\":\"FFFFFF\",\"color\":null},{\"position\":{\"x\":0,\"y\":0.5,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":0.08,\"y\":0.25,\"z\":0.25},\"geometry\":1,\"model\":null,\"meshes\":[{\"name\":\"main\",\"materialId\":0}],\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"materials\":[{\"vertex\":\"uniform mat4 modelMatrix;\\nuniform mat4 viewMatrix;\\nuniform mat4 projectionMatrix;\\n\\nin vec3 position;\\nin vec4 color;\\n\\nout vec4 vColor;\\n\\nvoid main() {\\n  vColor = color;\\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\\n}\\n\",\"fragment\":\"in vec4 vColor;\\n\\nout vec4 FragColor;\\n\\nvoid main() {\\n  FragColor = vec4(1.0, 0.5, 0.0, 1.0);\\n}\\n\",\"properties\":\"\"},{\"vertex\":\"uniform mat4 modelMatrix;\\nuniform mat4 viewMatrix;\\nuniform mat4 projectionMatrix;\\n\\nin vec3 position;\\nin vec3 normal;\\nin vec4 color;\\n\\nout vec4 vColor;\\nout vec3 vNormal;\\nout vec3 vPos;\\n\\nvoid main() {\\n  vColor = color;\\n  vNormal = normalize(mat3(transpose(inverse(modelMatrix))) * normal);\\n  \\n  vec4 worldPos = modelMatrix * vec4(position, 1.0);\\n  vPos = worldPos.xyz;\\n  \\n  gl_Position = projectionMatrix * viewMatrix * worldPos;\\n}\\n\",\"fragment\":\"uniform float iTime;\\n\\nin vec4 vColor;\\nin vec3 vNormal;\\nin vec3 vPos;\\n\\nconst vec3 lightPos0 = vec3(0.0, 2.0, 0.5);\\nconst vec3 lightPos1 = vec3(0.0, 2.0, -.5);\\nconst vec3 lightCol = vec3(1.0, 0.9, 0.8);\\n\\nout vec4 FragColor;\\n\\nfloat random(float x) {\\n   float r = fract(sin(x * 12.34) * 1234.5678);\\n   return r;\\n}\\n\\nvoid main() {\\n  vec3 normal = normalize(vNormal);\\n  \\n  vec3 lightDir0 = normalize(lightPos0 - vPos);\\n  float diffuse0 = max(0.0, dot(normalize(vNormal), lightDir0));\\n\\n  vec3 lightDir1 = normalize(lightPos1 - vPos);\\n  float diffuse1 = max(0.0, dot(normalize(vNormal), lightDir1));\\n\\n  float diffuse = diffuse0 + diffuse1;\\n\\n  float f = random(iTime) * 0.25 + 0.75;\\n  \\n  FragColor = vec4(vColor.rgb * lightCol * f * (diffuse + 0.25), vColor.a);\\n}\\n\",\"properties\":\"\"}],\"actions\":[],\"backgroundRGBA\":\"111111\",\"background\":1118481,\"customDepthBufferTexture\":false,\"glslVersion\":\"3\"}",
                                "description": "**Additive blending** is often used for effects like fire, explosions, and other light-emitting objects. In additive blending, the colors are added together, which can create a bright, glowing effect.\n\n<br>\n\nThe blending equation for additive blending is:\n```\nFinalColor = (SrcColor * SrcAlpha) + (DstColor * 1)\n```\n\n### Task\n\nGiven a program that draws a candle with a halo effect. The halo is rendered using several alpha blended overlaid planes. Modify the program so that the halos from the rectangles accumulate to create a glow effect.\n",
                                "hints": [],
                                "restrictions": [],
                                "order": 2,
                                "cost": 10,
                                "threshold": 99,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": true,
                                "animationSteps": 10,
                                "animationStepTime": 200,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": false
                            },
                            "vertexShader": "uniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\nin vec3 position;\nin vec2 uv;\n\nout vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}",
                            "fragmentShader": "uniform float iTime;\n\nin vec2 vUv;\n\nout vec4 FragColor;\n\nfloat random(float x) {\n   float r = fract(sin(x * 12.34) * 1234.5678);\n   return r;\n}\n\nvoid main() {\n  float r = distance(vec2(0.5), vUv);\n  float t = 1.0 - smoothstep(0.0, 0.5, r);\n  float f = random(iTime) * 0.1 + 0.9;\n  FragColor = vec4(1.0, 0.8, 0.0, t * 0.5 * f);\n}\n",
                            "postProcessShader": "",
                            "properties": "DepthTest = false\nBlending = Blending.ALPHA",
                            "defaultVertexShader": "uniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\nin vec3 position;\nin vec2 uv;\n\nout vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}",
                            "defaultFragmentShader": "uniform float iTime;\n\nin vec2 vUv;\n\nout vec4 FragColor;\n\nfloat random(float x) {\n   float r = fract(sin(x * 12.34) * 1234.5678);\n   return r;\n}\n\nvoid main() {\n  float r = distance(vec2(0.5), vUv);\n  float t = 1.0 - smoothstep(0.0, 0.5, r);\n  float f = random(iTime) * 0.1 + 0.9;\n  FragColor = vec4(1.0, 0.8, 0.0, t * 0.5 * f);\n}\n",
                            "defaultPostProcessShader": "",
                            "defaultProperties": "DepthTest = false\nBlending = Blending.ALPHA",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 186,
                        "slug": "screen-aligned-billboards",
                        "moduleId": 11,
                        "name": "Screen-Aligned Billboards",
                        "order": 3,
                        "cost": 10,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": 0,
                        "premium": false,
                        "child": {
                            "task": {
                                "id": 186,
                                "slug": "screen-aligned-billboards",
                                "moduleId": 11,
                                "name": "Screen-Aligned Billboards",
                                "vertexShader": "uniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\nin int index;\nin vec3 position;\nin vec2 uv;\n\nconst float dx[4] = float[](-0.25,  0.25, 0.25, -0.25);\nconst float dy[4] = float[](-0.25, -0.25, 0.25,  0.25);\n\nout vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  vec4 viewPos = viewMatrix * modelMatrix * vec4(position, 1.0);\n  viewPos.xy += vec2(dx[index], dy[index]);\n  gl_Position = projectionMatrix * viewPos;\n}",
                                "fragmentShader": "uniform float iTime;\n\nin vec2 vUv;\n\nout vec4 FragColor;\n\nfloat random(float x) {\n   float r = fract(sin(x * 12.34) * 1234.5678);\n   return r;\n}\n\nvoid main() {\n  float r = distance(vec2(0.5), vUv);\n  float t = 1.0 - smoothstep(0.0, 0.5, r);\n  float f = random(iTime) * 0.25 + 0.75;\n  FragColor = vec4(1.0, 0.8, 0.0, t * 0.75 * f);\n}\n",
                                "postProcessShader": "",
                                "properties": "DepthTest = false",
                                "defaultVertexShader": "uniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\nin int index;\nin vec3 position;\nin vec2 uv;\n\nout vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}",
                                "defaultFragmentShader": "uniform float iTime;\n\nin vec2 vUv;\n\nout vec4 FragColor;\n\nfloat random(float x) {\n   float r = fract(sin(x * 12.34) * 1234.5678);\n   return r;\n}\n\nvoid main() {\n  float r = distance(vec2(0.5), vUv);\n  float t = 1.0 - smoothstep(0.0, 0.5, r);\n  float f = random(iTime) * 0.25 + 0.75;\n  FragColor = vec4(1.0, 0.8, 0.0, t * 0.75 * f);\n}\n",
                                "defaultPostProcessShader": "",
                                "defaultProperties": "DepthTest = false",
                                "vertexCodeEditable": true,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": true,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":0,\"y\":0.75,\"z\":0.8},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":45,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":\"10\",\"model\":\"Candle.glb\",\"meshes\":[{\"name\":\"Candle\",\"materialId\":2},{\"name\":\"Flame\",\"materialId\":1},{\"name\":\"Rope\",\"materialId\":1}],\"colorRGBA\":\"FFFFFF\",\"color\":null},{\"position\":{\"x\":0,\"y\":0.5,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":\"11\",\"model\":null,\"meshes\":[{\"name\":\"main\",\"materialId\":0}],\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"materials\":[{\"vertex\":\"uniform mat4 modelMatrix;\\nuniform mat4 viewMatrix;\\nuniform mat4 projectionMatrix;\\n\\nin vec3 position;\\nin vec4 color;\\n\\nout vec4 vColor;\\n\\nvoid main() {\\n  vColor = color;\\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\\n}\\n\",\"fragment\":\"in vec4 vColor;\\n\\nout vec4 FragColor;\\n\\nvoid main() {\\n  FragColor = vec4(1.0, 0.5, 0.0, 1.0);\\n}\\n\",\"properties\":\"\"},{\"vertex\":\"uniform mat4 modelMatrix;\\nuniform mat4 viewMatrix;\\nuniform mat4 projectionMatrix;\\n\\nin vec3 position;\\nin vec3 normal;\\nin vec4 color;\\n\\nout vec4 vColor;\\nout vec3 vNormal;\\nout vec3 vPos;\\n\\nvoid main() {\\n  vColor = color;\\n  vNormal = normalize(mat3(transpose(inverse(modelMatrix))) * normal);\\n  \\n  vec4 worldPos = modelMatrix * vec4(position, 1.0);\\n  vPos = worldPos.xyz;\\n  \\n  gl_Position = projectionMatrix * viewMatrix * worldPos;\\n}\\n\",\"fragment\":\"uniform float iTime;\\n\\nin vec4 vColor;\\nin vec3 vNormal;\\nin vec3 vPos;\\n\\nconst vec3 lightPos0 = vec3(0.0, 2.0, 0.5);\\nconst vec3 lightPos1 = vec3(0.0, 2.0, -.5);\\nconst vec3 lightCol = vec3(1.0, 0.9, 0.8);\\n\\nout vec4 FragColor;\\n\\nfloat random(float x) {\\n   float r = fract(sin(x * 12.34) * 1234.5678);\\n   return r;\\n}\\n\\nvoid main() {\\n  vec3 normal = normalize(vNormal);\\n  \\n  vec3 lightDir0 = normalize(lightPos0 - vPos);\\n  float diffuse0 = max(0.0, dot(normalize(vNormal), lightDir0));\\n\\n  vec3 lightDir1 = normalize(lightPos1 - vPos);\\n  float diffuse1 = max(0.0, dot(normalize(vNormal), lightDir1));\\n\\n  float diffuse = diffuse0 + diffuse1;\\n\\n  float f = random(iTime) * 0.25 + 0.75;\\n  \\n  FragColor = vec4(vColor.rgb * lightCol * f * (diffuse + 0.25), vColor.a);\\n}\\n\",\"properties\":\"\"}],\"actions\":[{\"type\":0,\"speed\":1,\"pivot\":{\"x\":0,\"y\":0.4,\"z\":0}}],\"backgroundRGBA\":\"111111\",\"background\":1118481,\"customDepthBufferTexture\":false,\"glslVersion\":\"3\"}",
                                "description": "**Screen-aligned billboards** is a common technique in computer graphics used to render objects that are always oriented parallel to the screen, regardless of the camera position. This means that they always «face» the viewer. This technique is often used for rendering particles, sprites and other effects.\n\n<br>\n\nHere is one possible implementation:\n\n1. Pass a collapsed quad (4 vertices) representing the center of the billboard to the vertex shader.\n2. Translate vertices to view space using the model and view matrices.\n3. To expand it into a quad, move vertices according to a certain algorithm along the **X** and **Y** axes (often it is just two values **dx** and **dy**).\n4. Apply camera projection. \n5. Sample a texture or apply any desired effects in the fragment shader.\n\n### Task\n\nGiven a program that renders a candle with a halo. The camera rotates around the candle. The halo geometry is a two-sided collapsed quad. Each vertex of the quad have a unique index attribute ranging from 0 to 3. Modify the program to expand the halo with a size of 0.5 and make it always face the viewer. ",
                                "hints": [],
                                "restrictions": [],
                                "order": 3,
                                "cost": 10,
                                "threshold": 99,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": true,
                                "animationSteps": 10,
                                "animationStepTime": 200,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": false
                            },
                            "vertexShader": "uniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\nin int index;\nin vec3 position;\nin vec2 uv;\n\nout vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}",
                            "fragmentShader": "uniform float iTime;\n\nin vec2 vUv;\n\nout vec4 FragColor;\n\nfloat random(float x) {\n   float r = fract(sin(x * 12.34) * 1234.5678);\n   return r;\n}\n\nvoid main() {\n  float r = distance(vec2(0.5), vUv);\n  float t = 1.0 - smoothstep(0.0, 0.5, r);\n  float f = random(iTime) * 0.25 + 0.75;\n  FragColor = vec4(1.0, 0.8, 0.0, t * 0.75 * f);\n}\n",
                            "postProcessShader": "",
                            "properties": "DepthTest = false",
                            "defaultVertexShader": "uniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\nin int index;\nin vec3 position;\nin vec2 uv;\n\nout vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}",
                            "defaultFragmentShader": "uniform float iTime;\n\nin vec2 vUv;\n\nout vec4 FragColor;\n\nfloat random(float x) {\n   float r = fract(sin(x * 12.34) * 1234.5678);\n   return r;\n}\n\nvoid main() {\n  float r = distance(vec2(0.5), vUv);\n  float t = 1.0 - smoothstep(0.0, 0.5, r);\n  float f = random(iTime) * 0.25 + 0.75;\n  FragColor = vec4(1.0, 0.8, 0.0, t * 0.75 * f);\n}\n",
                            "defaultPostProcessShader": "",
                            "defaultProperties": "DepthTest = false",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 187,
                        "slug": "ndc-in-perspective-projection",
                        "moduleId": 11,
                        "name": "NDC in perspective projection",
                        "order": 4,
                        "cost": 10,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": 0,
                        "premium": false,
                        "child": {
                            "task": {
                                "id": 187,
                                "slug": "ndc-in-perspective-projection",
                                "moduleId": 11,
                                "name": "NDC in perspective projection",
                                "vertexShader": "uniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\nin vec3 position;\n\nout vec4 vPosProj;\n\nvoid main() {\n  vPosProj = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n  gl_Position = vPosProj;\n}\n",
                                "fragmentShader": "uniform sampler2D iChannel0;\n\nin vec4 vPosProj;\n\nout vec4 FragColor;\n\nvoid main() {\n  vec3 depth = vPosProj.xyz / vPosProj.w;\n  depth = depth * 0.5 + 0.5;\n\n  vec4 texel = texture(iChannel0, depth.xy);\n  \n  FragColor = vec4(texel.rgb, 1.0);\n}\n",
                                "postProcessShader": "",
                                "properties": "",
                                "defaultVertexShader": "uniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\nin vec3 position;\nin vec3 normal;\nin vec4 color;\n\nout vec4 vColor;\nout vec3 vNormal;\nout vec4 vPosProj;\n\nvoid main() {\n  vColor = color;\n  vNormal = mat3(transpose(inverse(modelMatrix))) * normal;\n  vPosProj = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n  gl_Position = vPosProj;\n}\n",
                                "defaultFragmentShader": "in vec4 vColor;\nin vec3 vNormal;\nin vec4 vPosProj;\n\nout vec4 FragColor;\n\nconst vec3 lightColor = vec3(2.0);\nconst vec3 lightDir   = normalize(vec3(1.0));\n\nvoid main() {\n  vec3 normal = normalize(vNormal);\n  float diffuse = max(0.0, dot(lightDir, normal));\n  \n  FragColor = vec4(vColor.rgb * lightColor * diffuse, 1.0);\n}\n",
                                "defaultPostProcessShader": "",
                                "defaultProperties": "",
                                "vertexCodeEditable": true,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-1,\"y\":5,\"z\":9},\"rotation\":{\"x\":-0.3,\"y\":0,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":45,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":-0.7,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":\"10\",\"model\":\"Cow.glb\",\"meshes\":[{\"name\":\"Cow_1\",\"materialId\":0},{\"name\":\"Cow_2\",\"materialId\":0},{\"name\":\"Cow_3\",\"materialId\":0},{\"name\":\"Cow_4\",\"materialId\":0},{\"name\":\"Cow_5\",\"materialId\":0},{\"name\":\"Cow_6\",\"materialId\":0},{\"name\":\"Cow_7\",\"materialId\":0}],\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"materials\":[],\"actions\":[{\"type\":0,\"speed\":1,\"pivot\":{\"x\":0,\"y\":2.5,\"z\":0}}],\"backgroundRGBA\":\"CCCCCC\",\"background\":13421772,\"customDepthBufferTexture\":false,\"glslVersion\":\"3\"}",
                                "description": "Having the **normalized device coordinates (NDC)** of a fragment is crucial for several advanced rendering techniques in computer graphics (SSAO, SSR, Post-Processing and etc).\n\n<br>\n\n### Getting NDC Coordinates\n\n<br>\n\nIn the vertex shader, transform the vertex positions from *model space* to *clip space* using the model, view, and projection matrices. Pass the clip space coordinates to the fragment shader:\n\n```\nout vec4 clipPos;\nclipPos = projection * view * model * vec4(position, 1.0);\n```\n\nIn the fragment shader, receive the clip space coordinates `clipPos` from the vertex shader. Convert these coordinates to NDC by performing a perspective division (dividing by the `w` component).\n\n```\nvec3 ndc = clipPos.xyz / clipPos.w;\n```\n\nThe division by the `w` component is necessary to convert from *homogeneous clip space* to NDC. This division accounts for the perspective effect, ensuring that objects farther from the camera appear smaller.\n\n<br>\n\nThe resulting NDC coordinates range from -1 to 1 in all three dimensions (x, y, z). These coordinates can then be converted to *normalized screen space coordinates* by the usual mapping to the interval [0, 1]:\n\n```\nscreenTexPos = ndc.xy * 0.5 + 0.5;\nscreenTexel  = texture(screenTex, screenTexPos);\n```\n\n### Depth Value\n\n<br>\n\nThe fragment depth value is stored in the `z` component of the NDC coordinates. You may also need to convert it to the interval [0, 1]. Because depth textures typically store values in the range [0, 1], where 0 represents the near clipping plane and 1 represents the far clipping plane.\n\n### Task\nCalculate each fragment's screen position and use it to sample a texture in `iChannel0'.\n",
                                "hints": [],
                                "restrictions": [],
                                "order": 4,
                                "cost": 10,
                                "threshold": 99,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [
                                    {
                                        "index": 0
                                    }
                                ],
                                "animated": true,
                                "animationSteps": 10,
                                "animationStepTime": 200,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": false
                            },
                            "vertexShader": "uniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\nin vec3 position;\nin vec3 normal;\nin vec4 color;\n\nout vec4 vColor;\nout vec3 vNormal;\nout vec4 vPosProj;\n\nvoid main() {\n  vColor = color;\n  vNormal = mat3(transpose(inverse(modelMatrix))) * normal;\n  vPosProj = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n  gl_Position = vPosProj;\n}\n",
                            "fragmentShader": "in vec4 vColor;\nin vec3 vNormal;\nin vec4 vPosProj;\n\nout vec4 FragColor;\n\nconst vec3 lightColor = vec3(2.0);\nconst vec3 lightDir   = normalize(vec3(1.0));\n\nvoid main() {\n  vec3 normal = normalize(vNormal);\n  float diffuse = max(0.0, dot(lightDir, normal));\n  \n  FragColor = vec4(vColor.rgb * lightColor * diffuse, 1.0);\n}\n",
                            "postProcessShader": "",
                            "properties": "",
                            "defaultVertexShader": "uniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\nin vec3 position;\nin vec3 normal;\nin vec4 color;\n\nout vec4 vColor;\nout vec3 vNormal;\nout vec4 vPosProj;\n\nvoid main() {\n  vColor = color;\n  vNormal = mat3(transpose(inverse(modelMatrix))) * normal;\n  vPosProj = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n  gl_Position = vPosProj;\n}\n",
                            "defaultFragmentShader": "in vec4 vColor;\nin vec3 vNormal;\nin vec4 vPosProj;\n\nout vec4 FragColor;\n\nconst vec3 lightColor = vec3(2.0);\nconst vec3 lightDir   = normalize(vec3(1.0));\n\nvoid main() {\n  vec3 normal = normalize(vNormal);\n  float diffuse = max(0.0, dot(lightDir, normal));\n  \n  FragColor = vec4(vColor.rgb * lightColor * diffuse, 1.0);\n}\n",
                            "defaultPostProcessShader": "",
                            "defaultProperties": "",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 188,
                        "slug": "soft-particle",
                        "moduleId": 11,
                        "name": "Soft Particle",
                        "order": 5,
                        "cost": 10,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": 0,
                        "premium": false,
                        "child": {
                            "task": {
                                "id": 188,
                                "slug": "soft-particle",
                                "moduleId": 11,
                                "name": "Soft Particle",
                                "vertexShader": "uniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\nin int index;\nin vec3 position;\nin vec2 uv;\n\nconst float dx[4] = float[](-0.5,  0.5, 0.5, -0.5);\nconst float dy[4] = float[](-0.5, -0.5, 0.5,  0.5);\n\nout vec2 vUv;\nout vec4 vPosProj;\n\nvoid main() {\n  vUv = uv;\n  vec4 viewPos = viewMatrix * modelMatrix * vec4(position, 1.0);\n  viewPos.xy += vec2(dx[index], dy[index]);\n  vPosProj = projectionMatrix * viewPos;\n  gl_Position = vPosProj;\n}",
                                "fragmentShader": "uniform float iTime;\nuniform sampler2D iDepthBuffer;\nuniform sampler2D iChannel0;\n\nin vec2 vUv;\nin vec4 vPosProj;\n\nout vec4 FragColor;\n\nfloat calculateDepthFade(vec3 pixelCoord) {\n  float depth = (texture(iDepthBuffer, pixelCoord.xy * 0.5 + 0.5).r);\n  float z = pixelCoord.z * 0.5 + 0.5;\n  return clamp((depth - z) * 50.0, 0.0, 1.0);\n}\n\nvoid main() {\n  float soft = calculateDepthFade(vPosProj.xyz / vPosProj.w);\n\n  float frame = mod(floor(iTime / 0.05), 30.0);\n  float x = mod(frame, 6.0);\n  float y = 4.0 - mod(floor(frame / 6.0), 5.0);\n\n  vec4 texel = texture(iChannel0, (vUv + vec2(x, y)) * vec2(1.0 / 6.0, 0.2));\n  \n  FragColor = vec4(texel.rgb, texel.a * soft);\n}\n",
                                "postProcessShader": "",
                                "properties": "DepthTest = TRUE\nDepthWrite = FALSE",
                                "defaultVertexShader": "uniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\nin int index;\nin vec3 position;\nin vec2 uv;\n\nconst float dx[4] = float[](-0.5,  0.5, 0.5, -0.5);\nconst float dy[4] = float[](-0.5, -0.5, 0.5,  0.5);\n\nout vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  vec4 viewPos = viewMatrix * modelMatrix * vec4(position, 1.0);\n  viewPos.xy += vec2(dx[index], dy[index]);\n  gl_Position = projectionMatrix * viewPos;\n}",
                                "defaultFragmentShader": "uniform float iTime;\nuniform sampler2D iDepthBuffer;\nuniform sampler2D iChannel0;\n\nin vec2 vUv;\n\nout vec4 FragColor;\n\nvoid main() {\n  float frame = mod(floor(iTime / 0.05), 30.0);\n  float x = mod(frame, 6.0);\n  float y = 4.0 - mod(floor(frame / 6.0), 5.0);\n\n  vec4 texel = texture(iChannel0, (vUv + vec2(x, y)) * vec2(1.0 / 6.0, 0.2));\n  \n  FragColor = texel;\n}\n",
                                "defaultPostProcessShader": "",
                                "defaultProperties": "DepthTest = TRUE\nDepthWrite = TRUE",
                                "vertexCodeEditable": true,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": true,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":0,\"y\":0.4,\"z\":1.1},\"rotation\":{\"x\":-0.3,\"y\":0,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":45,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":-0.12,\"z\":0},\"rotation\":{\"x\":-1.57,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1,\"model\":null,\"meshes\":[{\"name\":\"main\",\"materialId\":1}],\"colorRGBA\":\"FFFFFF\",\"color\":null},{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":\"11\",\"model\":null,\"meshes\":[{\"name\":\"main\",\"materialId\":0}],\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"materials\":[{\"vertex\":\"uniform mat4 modelMatrix;\\nuniform mat4 viewMatrix;\\nuniform mat4 projectionMatrix;\\n\\nin vec3 position;\\nin vec4 color;\\n\\nout vec4 vColor;\\n\\nvoid main() {\\n  vColor = color;\\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\\n}\\n\",\"fragment\":\"in vec4 vColor;\\n\\nout vec4 FragColor;\\n\\nvoid main() {\\n  FragColor = vec4(0.44, 0.76, 0.44, 1.0);\\n}\\n\",\"properties\":\"\"}],\"actions\":[{\"type\":0,\"speed\":1,\"pivot\":{\"x\":0,\"y\":0,\"z\":0}}],\"backgroundRGBA\":\"DDDDDD\",\"background\":14540253,\"customDepthBufferTexture\":false,\"glslVersion\":\"3\"}",
                                "description": "**Soft particles** are a technique used in computer graphics to create particles that blend smoothly with the scene, avoiding hard edges where particles intersect with other geometry. This is achieved by using the **depth buffer** to determine the distance between particles and the scene geometry, and then adjusting the particle opacity based on this distance.\n\n<br>\n\n### Steps to Create Soft Particles\n\n1. Turn on depth writing.\n2. Render the scene without the particles to a depth texture.\n3. Turn off depth writing.\n4. Render the particles using a shader that compares the particle depth with the scene depth. If the particle is close to the scene geometry, reduce its opacity to create a soft edge. This requires passing the depth texture to the particle shader.\n\n*To save computation time, you can take the depth texture from the previous frame.*\n\n### Task\n\nModify a program to make the intersection between the particle and the platform soft. To achieve this, use the scene depth texture `iDepthBuffer` to compare the depth of the particles with the platform. Adjust the particle opacity using the formula:\n\n```\nopacity = clamp((sceneDepth - particleDpeth) * 50.0, 0.0, 1.0)\n```\n\nBe sure to check the depth settings.\n",
                                "hints": [],
                                "restrictions": [],
                                "order": 5,
                                "cost": 10,
                                "threshold": 99,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [
                                    {
                                        "index": 0
                                    }
                                ],
                                "animated": true,
                                "animationSteps": 10,
                                "animationStepTime": 200,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": false
                            },
                            "vertexShader": "uniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\nin int index;\nin vec3 position;\nin vec2 uv;\n\nconst float dx[4] = float[](-0.5,  0.5, 0.5, -0.5);\nconst float dy[4] = float[](-0.5, -0.5, 0.5,  0.5);\n\nout vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  vec4 viewPos = viewMatrix * modelMatrix * vec4(position, 1.0);\n  viewPos.xy += vec2(dx[index], dy[index]);\n  gl_Position = projectionMatrix * viewPos;\n}",
                            "fragmentShader": "uniform float iTime;\nuniform sampler2D iDepthBuffer;\nuniform sampler2D iChannel0;\n\nin vec2 vUv;\n\nout vec4 FragColor;\n\nvoid main() {\n  float frame = mod(floor(iTime / 0.05), 30.0);\n  float x = mod(frame, 6.0);\n  float y = 4.0 - mod(floor(frame / 6.0), 5.0);\n\n  vec4 texel = texture(iChannel0, (vUv + vec2(x, y)) * vec2(1.0 / 6.0, 0.2));\n  \n  FragColor = texel;\n}\n",
                            "postProcessShader": "",
                            "properties": "DepthTest = TRUE\nDepthWrite = TRUE",
                            "defaultVertexShader": "uniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\nin int index;\nin vec3 position;\nin vec2 uv;\n\nconst float dx[4] = float[](-0.5,  0.5, 0.5, -0.5);\nconst float dy[4] = float[](-0.5, -0.5, 0.5,  0.5);\n\nout vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  vec4 viewPos = viewMatrix * modelMatrix * vec4(position, 1.0);\n  viewPos.xy += vec2(dx[index], dy[index]);\n  gl_Position = projectionMatrix * viewPos;\n}",
                            "defaultFragmentShader": "uniform float iTime;\nuniform sampler2D iDepthBuffer;\nuniform sampler2D iChannel0;\n\nin vec2 vUv;\n\nout vec4 FragColor;\n\nvoid main() {\n  float frame = mod(floor(iTime / 0.05), 30.0);\n  float x = mod(frame, 6.0);\n  float y = 4.0 - mod(floor(frame / 6.0), 5.0);\n\n  vec4 texel = texture(iChannel0, (vUv + vec2(x, y)) * vec2(1.0 / 6.0, 0.2));\n  \n  FragColor = texel;\n}\n",
                            "defaultPostProcessShader": "",
                            "defaultProperties": "DepthTest = TRUE\nDepthWrite = TRUE",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 189,
                        "slug": "multiple-render-targets",
                        "moduleId": 11,
                        "name": "Multiple Render Targets",
                        "order": 6,
                        "cost": 10,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": 0,
                        "premium": false,
                        "child": {
                            "task": {
                                "id": 189,
                                "slug": "multiple-render-targets",
                                "moduleId": 11,
                                "name": "Multiple Render Targets",
                                "vertexShader": "uniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\nin vec3 position;\nin vec3 normal;\nin vec4 color;\n\nout vec4 vColor;\nout vec3 vNormal;\nout vec3 vPos;\n\nvoid main() {\n  vColor = color;\n  vNormal = normalize(mat3(transpose(inverse(modelMatrix))) * normal);\n  vPos = (modelMatrix * vec4(position, 1.0)).xyz;\n  \n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}",
                                "fragmentShader": "in vec4 vColor;\nin vec3 vNormal;\nin vec3 vPos;\n\nlayout(location = 0) out vec4 colorBuffer;\nlayout(location = 1) out vec4 normalBuffer;\nlayout(location = 2) out vec4 posBuffer;\n\nvoid main() {\n  colorBuffer = vColor;\n  normalBuffer = vec4(normalize(vNormal), 1.0);\n  posBuffer = vec4(vPos.xyz, 1.0);\n}\n",
                                "postProcessShader": "uniform vec2 iResolution;\n\nuniform sampler2D iRTBuffer0;\nuniform sampler2D iRTBuffer1;\nuniform sampler2D iRTBuffer2;\nuniform sampler2D iDepthBuffer;\n\nout vec4 FragColor;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy * 2.0;\n\n  float i = floor(uv.y) * 2.0 + floor(uv.x);\n  vec2  f = fract(uv);\n\n  vec4 color  = texture(iRTBuffer0, f) * (1.0 - step(0.01, abs(i - 0.0)));\n  vec4 normal = texture(iRTBuffer1, f) * (1.0 - step(0.01, abs(i - 1.0)));\n  vec4 pos    = texture(iRTBuffer2, f) * (1.0 - step(0.01, abs(i - 2.0)));\n  vec4 depth  = texture(iDepthBuffer, f).rrrr * (1.0 - step(0.01, abs(i - 3.0)));\n  \n  FragColor = color + normal + pos + depth;\n}\n",
                                "properties": "RenderTargetsNumber = 3\nRenderTarget[0].dataType = DATA_TYPE.UNSIGNED_BYTE\nRenderTarget[0].pixelFormat = PIXEL_FORMAT.RGBA\nRenderTarget[1].dataType = DATA_TYPE.FLOAT\nRenderTarget[1].pixelFormat = PIXEL_FORMAT.RGBA\nRenderTarget[2].dataType = DATA_TYPE.FLOAT\nRenderTarget[2].pixelFormat = PIXEL_FORMAT.RGBA\nDepthTest = TRUE\nDepthWrite = TRUE\nBlending = Blending.NO",
                                "defaultVertexShader": "uniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\nin vec3 position;\nin vec3 normal;\nin vec4 color;\n\nout vec4 vColor;\n\nvoid main() {\n  vColor = color;\n  \n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}",
                                "defaultFragmentShader": "in vec4 vColor;\n\nlayout(location = 0) out vec4 colorBuffer;\n\nvoid main() {\n  colorBuffer = vColor;\n}\n",
                                "defaultPostProcessShader": "uniform vec2 iResolution;\n\nuniform sampler2D iRTBuffer0;\nuniform sampler2D iDepthBuffer;\n\nout vec4 FragColor;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  vec4 color  = texture(iRTBuffer0, uv);\n  \n  FragColor = color;\n}\n",
                                "defaultProperties": "RenderTargetsNumber = 1\nRenderTarget[0].dataType = DATA_TYPE.UNSIGNED_BYTE\nRenderTarget[0].pixelFormat = PIXEL_FORMAT.RGBA\nDepthTest = TRUE\nDepthWrite = TRUE",
                                "vertexCodeEditable": true,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": true,
                                "propertiesEditable": true,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":0,\"y\":5,\"z\":10},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":45,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":\"10\",\"model\":\"Cow.glb\",\"meshes\":[{\"name\":\"Cow_1\",\"materialId\":0},{\"name\":\"Cow_2\",\"materialId\":0},{\"name\":\"Cow_3\",\"materialId\":0},{\"name\":\"Cow_4\",\"materialId\":0},{\"name\":\"Cow_5\",\"materialId\":0},{\"name\":\"Cow_6\",\"materialId\":0},{\"name\":\"Cow_7\",\"materialId\":0}],\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"materials\":[],\"actions\":[{\"type\":0,\"speed\":1,\"pivot\":{\"x\":0,\"y\":2,\"z\":0}}],\"backgroundRGBA\":\"DDDDDD\",\"background\":14540253,\"customDepthBufferTexture\":false,\"glslVersion\":\"3\"}",
                                "description": "**Multiple Render Targets (MRT)** is a feature that allows a fragment shader to output to more than one render target simultaneously. This means that you can write different data to multiple textures in a single rendering pass. **MRT** is particularly useful for advanced rendering techniques such as deferred shading, where various types of information (e.g., color, normals, depth) need to be captured in separate textures for later processing.\n\n<br>\n\n### How to Use MRT\n\n1. Create a framebuffer object.\n2. Create multiple textures and attach them to the framebuffer as color attachments.\n3. In the fragment shader, output to multiple targets using the `layout` qualifier.\n\n```\nlayout(location = 0) out vec4 colorBuffer;\nlayout(location = 1) out vec4 normalBuffer;\nlayout(location = 2) out vec4 posBuffer;\n```\n\n`location` qualifier specify the render target index that a particular output writes to. By default the `location` is 0, so if we use one render target, we may not specify a `layout` for it:\n\n```\nout vec4 FragColor;\n```\n\n### Blending Issues\n\n<br>\n\nWhen using MRT, it is often necessary to disable blending. Each render target is intended to store different types of information, such as color, normals, or depth. Blending operations, however, are typically designed to combine the output of the fragment shader with the existing content of the framebuffer. If blending is enabled, it can inadvertently mix the outputs leading to incorrect results.\n\n### Task\n\nModify the program to render the scene's color, normal, and world position data into different render targets. Users can modify the `.properties` file to add render targets to the pipeline. \n\n<br>\n\nAdditionally, edit the `post-process` shader to render four render target textures: `iRTBuffer0`, `iRTBuffer1`, `iRTBuffer2`, and `iDepthBuffer`. This shader program is used to render a full-screen quad  after collecting all the scene data.\n\n",
                                "hints": [],
                                "restrictions": [],
                                "order": 6,
                                "cost": 10,
                                "threshold": 99,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": true,
                                "animationSteps": 10,
                                "animationStepTime": 200,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": false
                            },
                            "vertexShader": "uniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\nin vec3 position;\nin vec3 normal;\nin vec4 color;\n\nout vec4 vColor;\n\nvoid main() {\n  vColor = color;\n  \n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}",
                            "fragmentShader": "in vec4 vColor;\n\nlayout(location = 0) out vec4 colorBuffer;\n\nvoid main() {\n  colorBuffer = vColor;\n}\n",
                            "postProcessShader": "uniform vec2 iResolution;\n\nuniform sampler2D iRTBuffer0;\nuniform sampler2D iDepthBuffer;\n\nout vec4 FragColor;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  vec4 color  = texture(iRTBuffer0, uv);\n  \n  FragColor = color;\n}\n",
                            "properties": "RenderTargetsNumber = 1\nRenderTarget[0].dataType = DATA_TYPE.UNSIGNED_BYTE\nRenderTarget[0].pixelFormat = PIXEL_FORMAT.RGBA\nDepthTest = TRUE\nDepthWrite = TRUE",
                            "defaultVertexShader": "uniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\nin vec3 position;\nin vec3 normal;\nin vec4 color;\n\nout vec4 vColor;\n\nvoid main() {\n  vColor = color;\n  \n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}",
                            "defaultFragmentShader": "in vec4 vColor;\n\nlayout(location = 0) out vec4 colorBuffer;\n\nvoid main() {\n  colorBuffer = vColor;\n}\n",
                            "defaultPostProcessShader": "uniform vec2 iResolution;\n\nuniform sampler2D iRTBuffer0;\nuniform sampler2D iDepthBuffer;\n\nout vec4 FragColor;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  vec4 color  = texture(iRTBuffer0, uv);\n  \n  FragColor = color;\n}\n",
                            "defaultProperties": "RenderTargetsNumber = 1\nRenderTarget[0].dataType = DATA_TYPE.UNSIGNED_BYTE\nRenderTarget[0].pixelFormat = PIXEL_FORMAT.RGBA\nDepthTest = TRUE\nDepthWrite = TRUE",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 190,
                        "slug": "reconstruct-position-from-depth",
                        "moduleId": 11,
                        "name": "Reconstruct Position from Depth",
                        "order": 7,
                        "cost": 10,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": 0,
                        "premium": false,
                        "child": {
                            "task": {
                                "id": 190,
                                "slug": "reconstruct-position-from-depth",
                                "moduleId": 11,
                                "name": "Reconstruct Position from Depth",
                                "vertexShader": "uniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\nin vec3 position;\n\nvoid main() {\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}",
                                "fragmentShader": "out vec4 FragColor;\n\nvoid main() {\n  FragColor = vec4(1.0);\n}\n",
                                "postProcessShader": "uniform vec2 iResolution;\nuniform mat4 inverseProjectionMatrix;\nuniform mat4 inverseViewMatrix;\nuniform sampler2D iDepthBuffer;\n\nout vec4 FragColor;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  float depth = texture(iDepthBuffer, uv).r;\n\n  vec4 position = vec4(1.0); \n  position.x = uv.x * 2.0 - 1.0; \n  position.y = uv.y * 2.0 - 1.0; \n  position.z = depth * 2.0 - 1.0; \n  position = inverseViewMatrix * inverseProjectionMatrix * position; \n  position /= position.w;\n  \n  FragColor = vec4(position.xyz, 1.0);\n}\n",
                                "properties": "DepthTest = TRUE\nDepthWrite = TRUE",
                                "defaultVertexShader": "uniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\nin vec3 position;\n\nvoid main() {\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}",
                                "defaultFragmentShader": "out vec4 FragColor;\n\nvoid main() {\n  FragColor = vec4(1.0);\n}\n",
                                "defaultPostProcessShader": "uniform vec2 iResolution;\nuniform mat4 inverseProjectionMatrix;\nuniform mat4 inverseViewMatrix;\nuniform sampler2D iDepthBuffer;\n\nout vec4 FragColor;\n\nconst float farPlane  = 100.0;\nconst float nearPlane = 0.1;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  float depth = texture(iDepthBuffer, uv).r;\n\n  // replace with position restore\n  float linearDepth = depth * 2.0 - 1.0;\n  linearDepth = (2.0 * nearPlane * farPlane) / (farPlane + nearPlane - linearDepth * (farPlane - nearPlane));\n  linearDepth /= farPlane * 0.4;\n  \n  FragColor = vec4(vec3(linearDepth), 1.0);\n}\n",
                                "defaultProperties": "DepthTest = TRUE\nDepthWrite = TRUE",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": false,
                                "postProcessCodeEditable": true,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":0,\"y\":5,\"z\":10},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":45,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":\"10\",\"model\":\"Cow.glb\",\"meshes\":[{\"name\":\"Cow_1\",\"materialId\":0},{\"name\":\"Cow_2\",\"materialId\":0},{\"name\":\"Cow_3\",\"materialId\":0},{\"name\":\"Cow_4\",\"materialId\":0},{\"name\":\"Cow_5\",\"materialId\":0},{\"name\":\"Cow_6\",\"materialId\":0},{\"name\":\"Cow_7\",\"materialId\":0}],\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"materials\":[],\"actions\":[{\"type\":0,\"speed\":1,\"pivot\":{\"x\":0,\"y\":2,\"z\":0}}],\"backgroundRGBA\":\"DDDDDD\",\"background\":14540253,\"customDepthBufferTexture\":false,\"glslVersion\":\"3\"}",
                                "description": "Reconstructing the fragment's world position from its depth value involves a series of transformations that convert depth values back to world space coordinates.\n\n<br>\n\nThis approach is particularly advantageous in deferred rendering, where multiple render targets (MRT) are used to store various attributes of the scene, such as color, normals, and depth. By reconstructing the world position from the depth value, we can eliminate the need for a separate position texture. This not only simplifies the rendering pipeline but also significantly reduces memory usage, as storing high-resolution position data for every fragment can be quite memory-intensive.\n\n<br>\n\n### Steps to Restore World Position\n\n<br>\n\n**1. Obtain Depth Value**. The depth value of a fragment is stored in a depth texture, representing the distance from the camera to the fragment in the range [0, 1]:\n\n```\nfloat depth = texture(iDepthBuffer, uv).r;\n```\n\n**2. Reconstruct NDC**. Use the depth value and the fragment's screen coordinates to reconstruct the normalized device coordinates:\n\n```\nvec3 ndc = vec3(uv, depth) * 2.0 - 1.0;\n```\n\n**3. Transform to View Space**. Transform the NDC to view space using the inverse of the projection matrix.\n\n```\nvec4 viewPos = inverseProjectionMatrix * vec4(ndc, 1.0); \nviewPos /= viewPos.w;\n```\n\nBy multiplying the NDC coordinates by the inverse projection matrix, we get the view space position in homogeneous coordinates. To convert from homogeneous coordinates back to 3D coordinates, we divide by the `w` component.\n\n<br>\n\n**4. Transform to World Space**. Transform the view space position to world space using the inverse of the view matrix.\n\n### Task\n\nReconstruct the fragment's world position from its depth value in `iDepthBuffer`.\n",
                                "hints": [],
                                "restrictions": [],
                                "order": 7,
                                "cost": 10,
                                "threshold": 99,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": true,
                                "animationSteps": 10,
                                "animationStepTime": 200,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": false
                            },
                            "vertexShader": "uniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\nin vec3 position;\n\nvoid main() {\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}",
                            "fragmentShader": "out vec4 FragColor;\n\nvoid main() {\n  FragColor = vec4(1.0);\n}\n",
                            "postProcessShader": "uniform vec2 iResolution;\nuniform mat4 inverseProjectionMatrix;\nuniform mat4 inverseViewMatrix;\nuniform sampler2D iDepthBuffer;\n\nout vec4 FragColor;\n\nconst float farPlane  = 100.0;\nconst float nearPlane = 0.1;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  float depth = texture(iDepthBuffer, uv).r;\n\n  // replace with position restore\n  float linearDepth = depth * 2.0 - 1.0;\n  linearDepth = (2.0 * nearPlane * farPlane) / (farPlane + nearPlane - linearDepth * (farPlane - nearPlane));\n  linearDepth /= farPlane * 0.4;\n  \n  FragColor = vec4(vec3(linearDepth), 1.0);\n}\n",
                            "properties": "DepthTest = TRUE\nDepthWrite = TRUE",
                            "defaultVertexShader": "uniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\nin vec3 position;\n\nvoid main() {\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}",
                            "defaultFragmentShader": "out vec4 FragColor;\n\nvoid main() {\n  FragColor = vec4(1.0);\n}\n",
                            "defaultPostProcessShader": "uniform vec2 iResolution;\nuniform mat4 inverseProjectionMatrix;\nuniform mat4 inverseViewMatrix;\nuniform sampler2D iDepthBuffer;\n\nout vec4 FragColor;\n\nconst float farPlane  = 100.0;\nconst float nearPlane = 0.1;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  float depth = texture(iDepthBuffer, uv).r;\n\n  // replace with position restore\n  float linearDepth = depth * 2.0 - 1.0;\n  linearDepth = (2.0 * nearPlane * farPlane) / (farPlane + nearPlane - linearDepth * (farPlane - nearPlane));\n  linearDepth /= farPlane * 0.4;\n  \n  FragColor = vec4(vec3(linearDepth), 1.0);\n}\n",
                            "defaultProperties": "DepthTest = TRUE\nDepthWrite = TRUE",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 191,
                        "slug": "deferred-shading",
                        "moduleId": 11,
                        "name": "Deferred Shading",
                        "order": 8,
                        "cost": 10,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": 0,
                        "premium": false,
                        "child": {
                            "task": {
                                "id": 191,
                                "slug": "deferred-shading",
                                "moduleId": 11,
                                "name": "Deferred Shading",
                                "vertexShader": "uniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform float iTime;\n\nin int index;\nin float side;\n\nout float vH;\nflat out int vI;\nout vec3 vPos;\nout vec3 vNormal;\nout float vX;\n\nvec3 bezier3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    float tt = t * t;\n    float uu = u * u;\n\n    vec3 p = uu * p0; // (1-t)^2 * p0\n    p += 2.0 * u * t * p1; // 2 * (1-t) * t * p1\n    p += tt * p2; // t^2 * p2\n\n    return p;\n}\n\nvec3 bezierGradient3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    vec3 gradient = 2.0 * u * (p1 - p0) + 2.0 * t * (p2 - p1);\n    return gradient;\n}\n\nfloat random(float x) {\n  float r = fract(sin(x * 12.34) * 1234.5678);\n  return r * 2.0 - 1.0;\n}\n\nvec2 random2(vec2 st){\n  float d1 = dot(st, vec2(12.3, 32.1));\n  float d2 = dot(st, vec2(45.6, 65.4));\n  \n  st = vec2(d1, d2);\n  return fract(sin(st) * 78.9) * 2.0 - 1.0;\n}\n\nmat3 rotationYMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      vec3(cosAngle, 0, -sinAngle),\n      vec3(0, 1, 0),\n      vec3(sinAngle, 0, cosAngle)\n    );\n}\n\nvoid main() {\n  int i = index / 20;\n  int vi = index % 10;\n  \n  float h = float(vi / 2) / 4.0;\n  float xSide = mod(float(vi), 2.0);\n  float zSide = ((index % 20) / 10 == 1) ? 1.0 : -1.0;\n  float hash = random(float(i)) * 0.5 + 0.5;\n  vec2 worldPos = random2(vec2(hash)) * 6.0;\n  mat3 rotateY = rotationYMatrix(random(float(i)) * 3.14);\n\n  float lean = mix(1.57 - 0.5, 1.57 + 0.5, sin(iTime + random(float(i) * 3.14) * 2.0) * 0.5 + 0.5);\n  \n  vec3 curve = bezier3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.5, 0.0),\n    vec3(0.0, sin(lean), cos(lean)),\n    h\n  );\n\n  vec3 grad = bezierGradient3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.5, 0.0),\n    vec3(0.0, sin(lean), cos(lean)),\n    h\n  );\n  \n  vNormal = normalize(rotateY * vec3(0.0, grad.z, -grad.y)) * zSide;\n\n  float dx = xSide * 0.1 - 0.05;\n  dx *= mix(1.0, 0.0, pow(h, 4.0));\n  \n  vec3 pos = rotateY * vec3(dx, curve.y, curve.z);\n  pos += vec3(worldPos.x, 0.0, worldPos.y);\n  \n  vPos = pos;\n  vNormal = normalize(rotateY * zSide * vec3(0.0, grad.z, -grad.y));\n  vH = h;\n  vX = xSide > 0.0 ? 1.0 : -1.0;\n  \n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n",
                                "fragmentShader": "in float vH;\nflat in int vI;\nin vec3 vPos;\nin vec3 vNormal;\nin float vX;\n\nlayout(location = 0) out vec4 colorBuffer;\nlayout(location = 1) out vec4 normalBuffer;\nlayout(location = 2) out vec4 posBuffer;\n\nfloat random(float x) {\n   float r = fract(sin(x * 12.34) * 1234.5678);\n   return r;\n}\n\nconst vec3 lightPos = vec3(0.0, 3.0, 0.0);\n\nvoid main() {\n  float t = random(float(vI));\n  \n  vec3 color = mix(vec3(0.3, 0.3, 0.1), vec3(0.4, 0.2, 0.1), t) * vH;\n  \n  colorBuffer = vec4(color * (1.0 - abs(vX) * 0.5), 1.0);\n  normalBuffer = vec4(normalize(vNormal), 8.0);\n  posBuffer = vec4(vPos.xyz, 1.0);\n}",
                                "postProcessShader": "uniform float iTime;\nuniform vec2 iResolution;\nuniform mat4 inverseViewMatrix;\n\nuniform sampler2D iRTBuffer0; // color\nuniform sampler2D iRTBuffer1; // normal + specular\nuniform sampler2D iRTBuffer2; // position\n\nout vec4 FragColor;\n\nstruct TLight { vec3 position; vec3 color; };\n\nTLight c_Lights[4] = TLight[4](\n  TLight(vec3( 2.5, 0.5,  2.5), vec3(1.0, 0.2, 0.2)),\n  TLight(vec3(-2.5, 0.5,  2.5), vec3(0.2, 1.0, 0.2)),\n  TLight(vec3( 2.5, 0.5, -2.5), vec3(0.2, 0.2, 1.0)),\n  TLight(vec3(-2.5, 0.5, -2.5), vec3(1.0, 1.0, 0.2))\n);\n\nvec3 getViewPos() {\n  return (inverseViewMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz;  \n}\n\nmat3 rotationYMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      vec3(cosAngle, 0, -sinAngle),\n      vec3(0, 1, 0),\n      vec3(sinAngle, 0, cosAngle)\n    );\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  vec4 fragColor  = texture(iRTBuffer0, uv);\n  vec3 fragNormal = normalize(texture(iRTBuffer1, uv).xyz);\n  float fragSpec  = texture(iRTBuffer1, uv).w;\n  vec3 fragPos    = texture(iRTBuffer2, uv).xyz;\n  vec3 viewPos    = getViewPos();\n  mat3 rotateY    = rotationYMatrix(iTime * 1.57);\n  \n  vec3 result = vec3(0.0);\n  for (int i = 0; i < 4; i++) {\n    vec3 lightPos = rotateY * c_Lights[i].position;\n    vec3 lightDir = normalize(lightPos - fragPos);\n    \n    float diffuse = max(0.0, dot(fragNormal, lightDir));\n    \n    vec3 viewDir    = normalize(viewPos - fragPos);\n    vec3 halfwayDir = normalize(lightDir + viewDir);\n    float specular  = max(dot(fragNormal, halfwayDir), 0.0);\n    specular        = pow(specular, fragSpec);\n\n    float kc = 0.1;\n    float kl = 0.1;\n    float kq = 0.1;\n    float dist = distance(fragPos, lightPos);\n    float attenuation = 1.0 / (kc + kl * dist + kq * (dist * dist));\n\n    result += c_Lights[i].color * (0.5 + diffuse + specular) * fragColor.rgb * attenuation;\n  }\n  \n  FragColor = vec4(result, 1.0);\n}\n",
                                "properties": "RenderTargetsNumber = 3\nRenderTarget[0].dataType = DATA_TYPE.UNSIGNED_BYTE\nRenderTarget[0].pixelFormat = PIXEL_FORMAT.RGBA\nRenderTarget[1].dataType = DATA_TYPE.FLOAT\nRenderTarget[1].pixelFormat = PIXEL_FORMAT.RGBA\nRenderTarget[2].dataType = DATA_TYPE.FLOAT\nRenderTarget[2].pixelFormat = PIXEL_FORMAT.RGBA\nDepthTest = TRUE\nDepthWrite = TRUE\nBlending = Blending.NO",
                                "defaultVertexShader": "uniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform float iTime;\n\nin int index;\nin float side;\n\nout float vH;\nflat out int vI;\nout vec3 vPos;\nout vec3 vNormal;\nout float vX;\n\nvec3 bezier3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    float tt = t * t;\n    float uu = u * u;\n\n    vec3 p = uu * p0; // (1-t)^2 * p0\n    p += 2.0 * u * t * p1; // 2 * (1-t) * t * p1\n    p += tt * p2; // t^2 * p2\n\n    return p;\n}\n\nvec3 bezierGradient3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    vec3 gradient = 2.0 * u * (p1 - p0) + 2.0 * t * (p2 - p1);\n    return gradient;\n}\n\nfloat random(float x) {\n  float r = fract(sin(x * 12.34) * 1234.5678);\n  return r * 2.0 - 1.0;\n}\n\nvec2 random2(vec2 st){\n  float d1 = dot(st, vec2(12.3, 32.1));\n  float d2 = dot(st, vec2(45.6, 65.4));\n  \n  st = vec2(d1, d2);\n  return fract(sin(st) * 78.9) * 2.0 - 1.0;\n}\n\nmat3 rotationYMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      vec3(cosAngle, 0, -sinAngle),\n      vec3(0, 1, 0),\n      vec3(sinAngle, 0, cosAngle)\n    );\n}\n\nvoid main() {\n  int i = index / 20;\n  int vi = index % 10;\n  \n  float h = float(vi / 2) / 4.0;\n  float xSide = mod(float(vi), 2.0);\n  float zSide = ((index % 20) / 10 == 1) ? 1.0 : -1.0;\n  float hash = random(float(i)) * 0.5 + 0.5;\n  vec2 worldPos = random2(vec2(hash)) * 6.0;\n  mat3 rotateY = rotationYMatrix(random(float(i)) * 3.14);\n\n  float lean = mix(1.57 - 0.5, 1.57 + 0.5, sin(iTime + random(float(i) * 3.14) * 2.0) * 0.5 + 0.5);\n  \n  vec3 curve = bezier3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.5, 0.0),\n    vec3(0.0, sin(lean), cos(lean)),\n    h\n  );\n\n  vec3 grad = bezierGradient3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.5, 0.0),\n    vec3(0.0, sin(lean), cos(lean)),\n    h\n  );\n  \n  vNormal = normalize(rotateY * vec3(0.0, grad.z, -grad.y)) * zSide;\n\n  float dx = xSide * 0.1 - 0.05;\n  dx *= mix(1.0, 0.0, pow(h, 4.0));\n  \n  vec3 pos = rotateY * vec3(dx, curve.y, curve.z);\n  pos += vec3(worldPos.x, 0.0, worldPos.y);\n  \n  vPos = pos;\n  vNormal = normalize(rotateY * zSide * vec3(0.0, grad.z, -grad.y));\n  vH = h;\n  vX = xSide > 0.0 ? 1.0 : -1.0;\n  \n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n",
                                "defaultFragmentShader": "in float vH;\nflat in int vI;\nin vec3 vPos;\nin vec3 vNormal;\nin float vX;\n\nlayout(location = 0) out vec4 colorBuffer;\nlayout(location = 1) out vec4 normalBuffer;\nlayout(location = 2) out vec4 posBuffer;\n\nfloat random(float x) {\n   float r = fract(sin(x * 12.34) * 1234.5678);\n   return r;\n}\n\nconst vec3 lightPos = vec3(0.0, 3.0, 0.0);\n\nvoid main() {\n  float t = random(float(vI));\n  \n  vec3 color = mix(vec3(0.3, 0.3, 0.1), vec3(0.4, 0.2, 0.1), t) * vH;\n  \n  colorBuffer = vec4(color * (1.0 - abs(vX) * 0.5), 1.0);\n  normalBuffer = vec4(normalize(vNormal), 8.0);\n  posBuffer = vec4(vPos.xyz, 1.0);\n}",
                                "defaultPostProcessShader": "uniform float iTime;\nuniform vec2 iResolution;\nuniform mat4 inverseViewMatrix;\n\nuniform sampler2D iRTBuffer0; // color\nuniform sampler2D iRTBuffer1; // normal + specular\nuniform sampler2D iRTBuffer2; // position\n\nout vec4 FragColor;\n\nstruct TLight { vec3 position; vec3 color; };\n\nTLight c_Lights[4] = TLight[4](\n  TLight(vec3( 5.0, 5.0,  5.0), vec3(4.0, 0.2, 0.2)),\n  TLight(vec3(-5.0, 5.0,  5.0), vec3(0.2, 4.0, 0.2)),\n  TLight(vec3( 5.0, 5.0, -5.0), vec3(0.2, 0.2, 4.0)),\n  TLight(vec3(-5.0, 5.0, -5.0), vec3(4.0, 4.0, 0.2))\n);\n\nvec3 getViewPos() {\n  return (inverseViewMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz;  \n}\n\nmat3 rotationYMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      vec3(cosAngle, 0, -sinAngle),\n      vec3(0, 1, 0),\n      vec3(sinAngle, 0, cosAngle)\n    );\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  vec3 viewPos = getViewPos();\n  mat3 rotateY = rotationYMatrix(iTime * 1.57);\n\n  float kc = 0.1;\n  float kl = 0.1;\n  float kq = 0.1;\n  \n  FragColor = texture(iRTBuffer0, uv);\n}\n",
                                "defaultProperties": "RenderTargetsNumber = 3\nRenderTarget[0].dataType = DATA_TYPE.UNSIGNED_BYTE\nRenderTarget[0].pixelFormat = PIXEL_FORMAT.RGBA\nRenderTarget[1].dataType = DATA_TYPE.FLOAT\nRenderTarget[1].pixelFormat = PIXEL_FORMAT.RGBA\nRenderTarget[2].dataType = DATA_TYPE.FLOAT\nRenderTarget[2].pixelFormat = PIXEL_FORMAT.RGBA\nDepthTest = TRUE\nDepthWrite = TRUE\nBlending = Blending.NO",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": false,
                                "postProcessCodeEditable": true,
                                "propertiesEditable": true,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":0,\"y\":4,\"z\":8},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":45,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":\"13\",\"model\":null,\"meshes\":[{\"name\":\"main\",\"materialId\":0}],\"colorRGBA\":\"FFFFFF\",\"color\":null},{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":0.6,\"y\":0.6,\"z\":0.6},\"geometry\":\"10\",\"model\":\"Cow.glb\",\"meshes\":[{\"name\":\"Cow_1\",\"materialId\":1},{\"name\":\"Cow_2\",\"materialId\":1},{\"name\":\"Cow_3\",\"materialId\":1},{\"name\":\"Cow_4\",\"materialId\":1},{\"name\":\"Cow_5\",\"materialId\":1},{\"name\":\"Cow_6\",\"materialId\":1},{\"name\":\"Cow_7\",\"materialId\":1}],\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"materials\":[{\"vertex\":\"uniform mat4 modelMatrix;\\nuniform mat4 viewMatrix;\\nuniform mat4 projectionMatrix;\\n\\nin int id;\\nin vec3 position;\\nin vec3 normal;\\nin vec4 color;\\n\\nflat out int vId;\\nout vec4 vColor;\\nout vec3 vNormal;\\nout vec3 vPos;\\n\\nvoid main() {\\n  vId = id;\\n  vColor = color;\\n  vNormal = normalize(mat3(transpose(inverse(modelMatrix))) * normal);\\n  vPos = (modelMatrix * vec4(position, 1.0)).xyz;\\n  \\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\\n}\",\"fragment\":\"flat in int vId;\\nin vec4 vColor;\\nin vec3 vNormal;\\nin vec3 vPos;\\n\\nlayout(location = 0) out vec4 colorBuffer;\\nlayout(location = 1) out vec4 normalBuffer;\\nlayout(location = 2) out vec4 posBuffer;\\n\\nvoid main() {\\n  colorBuffer = vColor;\\n  normalBuffer = vec4(normalize(vNormal), pow(4.0, 1.0 + mod(float(vId), 3.0)));\\n  posBuffer = vec4(vPos.xyz, 1.0);\\n}\\n\",\"properties\":\"DepthTest = TRUE\\nDepthWrite = TRUE\\nBlending = Blending.NO\"}],\"actions\":[{\"type\":0,\"speed\":-0.25,\"pivot\":{\"x\":0,\"y\":0,\"z\":0}}],\"backgroundRGBA\":\"000000\",\"background\":0,\"customDepthBufferTexture\":false,\"glslVersion\":\"3\"}",
                                "description": "**Deferred shading** is an advanced rendering technique used in computer graphics to efficiently handle complex lighting calculations. Unlike traditional forward rendering, where lighting calculations are performed for each object as it is rendered, deferred shading separates the rendering process into two distinct passes: the geometry pass and the lighting pass. This separation allows for more efficient and flexible lighting calculations, especially in scenes with many light sources.\n\n<br>\n\n### 1. Geometry Pass\n\n<br>\n\nIn the geometry pass, the scene's geometry is rendered, and various attributes of each fragment are stored in multiple render targets (MRT), collectively known as the **G-buffer**. The G-buffer typically includes color, normal, position and depth textures.\n\n<br>\n\n*To eliminate the need for a separate position texture, you can reconstruct the fragment position from it's depth value.*\n\n<br>\n\n### 2. Lighting Pass\n\n<br>\n\nIn the lighting pass, the G-buffer textures are used to perform lighting calculations. Since all the necessary information (color, normals, positions, depth) is already stored in the G-buffer, the lighting calculations can be performed in screen space.\n\n<br>\n\n### Advantages\n\n<br>\n\n**1\\. Efficient Handling of Multiple Lights**. Deferred shading decouples geometry rendering from lighting calculations, allowing for efficient handling of scenes with many light sources. Each light is only computed for the pixels it affects\n\n<br>\n\n**2\\. Reduced Overdraw**. Since lighting is calculated in screen space, deferred shading avoids the overdraw problem common in forward rendering, where multiple objects might cover the same pixel.\n\n<br>\n\n**3\\. Flexibility in Lighting Models**. Deferred shading allows for complex lighting models and effects, as all necessary information (color, normals, positions) is available in the G-buffer.\n\n<br>\n\n### Disadvantages\n\n<br>\n\n**1\\. Transparency Handling**. Deferred shading struggles with transparency, as it requires additional passes or techniques like depth peeling to handle transparent objects.\n\n<br>\n\n**2\\. High Memory Bandwidth**. The G-buffer can be large, consuming significant memory bandwidth and storage.\n\n<br>\n\n**3\\. Anti-Aliasing Challenges**. Hardware anti-aliasing (MSAA) does not work well with deferred shading, requiring post-processing techniques like FXAA or MLAA to achieve smooth edges.\n\n<br>\n\n**4\\. Multiple Materials**. Handling multiple materials can be challenging, as it requires more data to be stored in the G-buffer.\n\n### Task\n\nImplement deferred shading with given G-buffer textures (`iRTBuffer0`, `iRTBuffer1`, `iRTBuffer2`) and an array of lights `c_Lights`. Use the *Blinn-Phong* diffuse and specular lighting model with *halfway* vector and *attenuation* with given constants (`kc`, `kl`, `kq`).",
                                "hints": [],
                                "restrictions": [],
                                "order": 8,
                                "cost": 10,
                                "threshold": 99,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": true,
                                "animationSteps": 10,
                                "animationStepTime": 200,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": false
                            },
                            "vertexShader": "uniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform float iTime;\n\nin int index;\nin float side;\n\nout float vH;\nflat out int vI;\nout vec3 vPos;\nout vec3 vNormal;\nout float vX;\n\nvec3 bezier3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    float tt = t * t;\n    float uu = u * u;\n\n    vec3 p = uu * p0; // (1-t)^2 * p0\n    p += 2.0 * u * t * p1; // 2 * (1-t) * t * p1\n    p += tt * p2; // t^2 * p2\n\n    return p;\n}\n\nvec3 bezierGradient3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    vec3 gradient = 2.0 * u * (p1 - p0) + 2.0 * t * (p2 - p1);\n    return gradient;\n}\n\nfloat random(float x) {\n  float r = fract(sin(x * 12.34) * 1234.5678);\n  return r * 2.0 - 1.0;\n}\n\nvec2 random2(vec2 st){\n  float d1 = dot(st, vec2(12.3, 32.1));\n  float d2 = dot(st, vec2(45.6, 65.4));\n  \n  st = vec2(d1, d2);\n  return fract(sin(st) * 78.9) * 2.0 - 1.0;\n}\n\nmat3 rotationYMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      vec3(cosAngle, 0, -sinAngle),\n      vec3(0, 1, 0),\n      vec3(sinAngle, 0, cosAngle)\n    );\n}\n\nvoid main() {\n  int i = index / 20;\n  int vi = index % 10;\n  \n  float h = float(vi / 2) / 4.0;\n  float xSide = mod(float(vi), 2.0);\n  float zSide = ((index % 20) / 10 == 1) ? 1.0 : -1.0;\n  float hash = random(float(i)) * 0.5 + 0.5;\n  vec2 worldPos = random2(vec2(hash)) * 6.0;\n  mat3 rotateY = rotationYMatrix(random(float(i)) * 3.14);\n\n  float lean = mix(1.57 - 0.5, 1.57 + 0.5, sin(iTime + random(float(i) * 3.14) * 2.0) * 0.5 + 0.5);\n  \n  vec3 curve = bezier3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.5, 0.0),\n    vec3(0.0, sin(lean), cos(lean)),\n    h\n  );\n\n  vec3 grad = bezierGradient3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.5, 0.0),\n    vec3(0.0, sin(lean), cos(lean)),\n    h\n  );\n  \n  vNormal = normalize(rotateY * vec3(0.0, grad.z, -grad.y)) * zSide;\n\n  float dx = xSide * 0.1 - 0.05;\n  dx *= mix(1.0, 0.0, pow(h, 4.0));\n  \n  vec3 pos = rotateY * vec3(dx, curve.y, curve.z);\n  pos += vec3(worldPos.x, 0.0, worldPos.y);\n  \n  vPos = pos;\n  vNormal = normalize(rotateY * zSide * vec3(0.0, grad.z, -grad.y));\n  vH = h;\n  vX = xSide > 0.0 ? 1.0 : -1.0;\n  \n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n",
                            "fragmentShader": "in float vH;\nflat in int vI;\nin vec3 vPos;\nin vec3 vNormal;\nin float vX;\n\nlayout(location = 0) out vec4 colorBuffer;\nlayout(location = 1) out vec4 normalBuffer;\nlayout(location = 2) out vec4 posBuffer;\n\nfloat random(float x) {\n   float r = fract(sin(x * 12.34) * 1234.5678);\n   return r;\n}\n\nconst vec3 lightPos = vec3(0.0, 3.0, 0.0);\n\nvoid main() {\n  float t = random(float(vI));\n  \n  vec3 color = mix(vec3(0.3, 0.3, 0.1), vec3(0.4, 0.2, 0.1), t) * vH;\n  \n  colorBuffer = vec4(color * (1.0 - abs(vX) * 0.5), 1.0);\n  normalBuffer = vec4(normalize(vNormal), 8.0);\n  posBuffer = vec4(vPos.xyz, 1.0);\n}",
                            "postProcessShader": "uniform float iTime;\nuniform vec2 iResolution;\nuniform mat4 inverseViewMatrix;\n\nuniform sampler2D iRTBuffer0; // color\nuniform sampler2D iRTBuffer1; // normal + specular\nuniform sampler2D iRTBuffer2; // position\n\nout vec4 FragColor;\n\nstruct TLight { vec3 position; vec3 color; };\n\nTLight c_Lights[4] = TLight[4](\n  TLight(vec3( 5.0, 5.0,  5.0), vec3(4.0, 0.2, 0.2)),\n  TLight(vec3(-5.0, 5.0,  5.0), vec3(0.2, 4.0, 0.2)),\n  TLight(vec3( 5.0, 5.0, -5.0), vec3(0.2, 0.2, 4.0)),\n  TLight(vec3(-5.0, 5.0, -5.0), vec3(4.0, 4.0, 0.2))\n);\n\nvec3 getViewPos() {\n  return (inverseViewMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz;  \n}\n\nmat3 rotationYMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      vec3(cosAngle, 0, -sinAngle),\n      vec3(0, 1, 0),\n      vec3(sinAngle, 0, cosAngle)\n    );\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  vec3 viewPos = getViewPos();\n  mat3 rotateY = rotationYMatrix(iTime * 1.57);\n\n  float kc = 0.1;\n  float kl = 0.1;\n  float kq = 0.1;\n  \n  FragColor = texture(iRTBuffer0, uv);\n}\n",
                            "properties": "RenderTargetsNumber = 3\nRenderTarget[0].dataType = DATA_TYPE.UNSIGNED_BYTE\nRenderTarget[0].pixelFormat = PIXEL_FORMAT.RGBA\nRenderTarget[1].dataType = DATA_TYPE.FLOAT\nRenderTarget[1].pixelFormat = PIXEL_FORMAT.RGBA\nRenderTarget[2].dataType = DATA_TYPE.FLOAT\nRenderTarget[2].pixelFormat = PIXEL_FORMAT.RGBA\nDepthTest = TRUE\nDepthWrite = TRUE\nBlending = Blending.NO",
                            "defaultVertexShader": "uniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform float iTime;\n\nin int index;\nin float side;\n\nout float vH;\nflat out int vI;\nout vec3 vPos;\nout vec3 vNormal;\nout float vX;\n\nvec3 bezier3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    float tt = t * t;\n    float uu = u * u;\n\n    vec3 p = uu * p0; // (1-t)^2 * p0\n    p += 2.0 * u * t * p1; // 2 * (1-t) * t * p1\n    p += tt * p2; // t^2 * p2\n\n    return p;\n}\n\nvec3 bezierGradient3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    vec3 gradient = 2.0 * u * (p1 - p0) + 2.0 * t * (p2 - p1);\n    return gradient;\n}\n\nfloat random(float x) {\n  float r = fract(sin(x * 12.34) * 1234.5678);\n  return r * 2.0 - 1.0;\n}\n\nvec2 random2(vec2 st){\n  float d1 = dot(st, vec2(12.3, 32.1));\n  float d2 = dot(st, vec2(45.6, 65.4));\n  \n  st = vec2(d1, d2);\n  return fract(sin(st) * 78.9) * 2.0 - 1.0;\n}\n\nmat3 rotationYMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      vec3(cosAngle, 0, -sinAngle),\n      vec3(0, 1, 0),\n      vec3(sinAngle, 0, cosAngle)\n    );\n}\n\nvoid main() {\n  int i = index / 20;\n  int vi = index % 10;\n  \n  float h = float(vi / 2) / 4.0;\n  float xSide = mod(float(vi), 2.0);\n  float zSide = ((index % 20) / 10 == 1) ? 1.0 : -1.0;\n  float hash = random(float(i)) * 0.5 + 0.5;\n  vec2 worldPos = random2(vec2(hash)) * 6.0;\n  mat3 rotateY = rotationYMatrix(random(float(i)) * 3.14);\n\n  float lean = mix(1.57 - 0.5, 1.57 + 0.5, sin(iTime + random(float(i) * 3.14) * 2.0) * 0.5 + 0.5);\n  \n  vec3 curve = bezier3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.5, 0.0),\n    vec3(0.0, sin(lean), cos(lean)),\n    h\n  );\n\n  vec3 grad = bezierGradient3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.5, 0.0),\n    vec3(0.0, sin(lean), cos(lean)),\n    h\n  );\n  \n  vNormal = normalize(rotateY * vec3(0.0, grad.z, -grad.y)) * zSide;\n\n  float dx = xSide * 0.1 - 0.05;\n  dx *= mix(1.0, 0.0, pow(h, 4.0));\n  \n  vec3 pos = rotateY * vec3(dx, curve.y, curve.z);\n  pos += vec3(worldPos.x, 0.0, worldPos.y);\n  \n  vPos = pos;\n  vNormal = normalize(rotateY * zSide * vec3(0.0, grad.z, -grad.y));\n  vH = h;\n  vX = xSide > 0.0 ? 1.0 : -1.0;\n  \n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n",
                            "defaultFragmentShader": "in float vH;\nflat in int vI;\nin vec3 vPos;\nin vec3 vNormal;\nin float vX;\n\nlayout(location = 0) out vec4 colorBuffer;\nlayout(location = 1) out vec4 normalBuffer;\nlayout(location = 2) out vec4 posBuffer;\n\nfloat random(float x) {\n   float r = fract(sin(x * 12.34) * 1234.5678);\n   return r;\n}\n\nconst vec3 lightPos = vec3(0.0, 3.0, 0.0);\n\nvoid main() {\n  float t = random(float(vI));\n  \n  vec3 color = mix(vec3(0.3, 0.3, 0.1), vec3(0.4, 0.2, 0.1), t) * vH;\n  \n  colorBuffer = vec4(color * (1.0 - abs(vX) * 0.5), 1.0);\n  normalBuffer = vec4(normalize(vNormal), 8.0);\n  posBuffer = vec4(vPos.xyz, 1.0);\n}",
                            "defaultPostProcessShader": "uniform float iTime;\nuniform vec2 iResolution;\nuniform mat4 inverseViewMatrix;\n\nuniform sampler2D iRTBuffer0; // color\nuniform sampler2D iRTBuffer1; // normal + specular\nuniform sampler2D iRTBuffer2; // position\n\nout vec4 FragColor;\n\nstruct TLight { vec3 position; vec3 color; };\n\nTLight c_Lights[4] = TLight[4](\n  TLight(vec3( 5.0, 5.0,  5.0), vec3(4.0, 0.2, 0.2)),\n  TLight(vec3(-5.0, 5.0,  5.0), vec3(0.2, 4.0, 0.2)),\n  TLight(vec3( 5.0, 5.0, -5.0), vec3(0.2, 0.2, 4.0)),\n  TLight(vec3(-5.0, 5.0, -5.0), vec3(4.0, 4.0, 0.2))\n);\n\nvec3 getViewPos() {\n  return (inverseViewMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz;  \n}\n\nmat3 rotationYMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      vec3(cosAngle, 0, -sinAngle),\n      vec3(0, 1, 0),\n      vec3(sinAngle, 0, cosAngle)\n    );\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  vec3 viewPos = getViewPos();\n  mat3 rotateY = rotationYMatrix(iTime * 1.57);\n\n  float kc = 0.1;\n  float kl = 0.1;\n  float kq = 0.1;\n  \n  FragColor = texture(iRTBuffer0, uv);\n}\n",
                            "defaultProperties": "RenderTargetsNumber = 3\nRenderTarget[0].dataType = DATA_TYPE.UNSIGNED_BYTE\nRenderTarget[0].pixelFormat = PIXEL_FORMAT.RGBA\nRenderTarget[1].dataType = DATA_TYPE.FLOAT\nRenderTarget[1].pixelFormat = PIXEL_FORMAT.RGBA\nRenderTarget[2].dataType = DATA_TYPE.FLOAT\nRenderTarget[2].pixelFormat = PIXEL_FORMAT.RGBA\nDepthTest = TRUE\nDepthWrite = TRUE\nBlending = Blending.NO",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 195,
                        "slug": "hdr",
                        "moduleId": 11,
                        "name": "HDR",
                        "order": 9,
                        "cost": 10,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": 0,
                        "premium": false,
                        "child": {
                            "task": {
                                "id": 195,
                                "slug": "hdr",
                                "moduleId": 11,
                                "name": "HDR",
                                "vertexShader": "uniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform float iTime;\n\nin int index;\nin float side;\n\nout float vH;\nflat out int vI;\nout vec3 vPos;\nout vec3 vNormal;\nout float vX;\n\nvec3 bezier3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    float tt = t * t;\n    float uu = u * u;\n\n    vec3 p = uu * p0; // (1-t)^2 * p0\n    p += 2.0 * u * t * p1; // 2 * (1-t) * t * p1\n    p += tt * p2; // t^2 * p2\n\n    return p;\n}\n\nvec3 bezierGradient3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    vec3 gradient = 2.0 * u * (p1 - p0) + 2.0 * t * (p2 - p1);\n    return gradient;\n}\n\nfloat random(float x) {\n  float r = fract(sin(x * 12.34) * 1234.5678);\n  return r * 2.0 - 1.0;\n}\n\nvec2 random2(vec2 st){\n  float d1 = dot(st, vec2(12.3, 32.1));\n  float d2 = dot(st, vec2(45.6, 65.4));\n  \n  st = vec2(d1, d2);\n  return fract(sin(st) * 78.9) * 2.0 - 1.0;\n}\n\nmat3 rotationYMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      vec3(cosAngle, 0, -sinAngle),\n      vec3(0, 1, 0),\n      vec3(sinAngle, 0, cosAngle)\n    );\n}\n\nvoid main() {\n  int i = index / 20;\n  int vi = index % 10;\n  \n  float h = float(vi / 2) / 4.0;\n  float xSide = mod(float(vi), 2.0);\n  float zSide = ((index % 20) / 10 == 1) ? 1.0 : -1.0;\n  float hash = random(float(i)) * 0.5 + 0.5;\n  vec2 worldPos = random2(vec2(hash)) * vec2(4.0, 2.0);\n  mat3 rotateY = rotationYMatrix(random(float(i)) * 3.14);\n\n  float lean = sin(iTime * 1.5 + random(hash * 3.14) * 2.0) * 0.5;\n  \n  vec3 curve = bezier3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.5, 0.0),\n    vec3(0.0, cos(lean), sin(lean)),\n    h\n  );\n\n  vec3 grad = bezierGradient3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.5, 0.0),\n    vec3(0.0, cos(lean), sin(lean)),\n    h\n  );\n  \n  vNormal = normalize(rotateY * vec3(0.0, grad.z, -grad.y)) * zSide;\n\n  float dx = xSide * 0.14 - 0.07;\n  dx *= mix(1.0, 0.0, pow(h, 4.0));\n  \n  vec3 pos = rotateY * vec3(dx, curve.y * 1.2, curve.z);\n  pos += vec3(worldPos.x, 0.0, worldPos.y);\n  \n  vPos = pos;\n  vNormal = normalize(rotateY * zSide * vec3(0.0, grad.z, -grad.y));\n  vH = h;\n  vX = xSide > 0.0 ? 1.0 : -1.0;\n  \n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n",
                                "fragmentShader": "uniform mat4 inverseViewMatrix;\n\nin float vH;\nflat in int vI;\nin vec3 vPos;\nin vec3 vNormal;\nin float vX;\n\nlayout(location = 0) out vec4 colorBuffer;\n\nvec3 getViewPos() {\n  return (inverseViewMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz;  \n}\n\nfloat random(float x) {\n   float r = fract(sin(x * 12.34) * 1234.5678);\n   return r;\n}\n\nconst vec3 lightPos = vec3(0.0, 3.0, 0.0);\n\nvoid main() {\n  float t = random(float(vI));\n  \n  vec3 color = mix(vec3(0.3, 0.4, 0.1), vec3(0.2, 0.2, 0.1), t) * vH;\n\n  vec4 fragColor  = vec4(color * (1.0 - abs(vX) * 0.3), 1.0);\n  vec3 fragNormal = normalize(vNormal);\n  float fragSpec  = 4.0;\n  vec3 fragPos    = vPos;\n  vec3 viewPos    = getViewPos();\n\n  vec3 lightClr = vec3(2.0, 2.0, 1.0);\n  vec3 lightPos = vec3(0.0, 2.5, 5.0);\n  vec3 lightDir = normalize(lightPos - fragPos);\n    \n  float diffuse = max(0.0, dot(fragNormal, lightDir));\n    \n  vec3 viewDir = normalize(viewPos - fragPos);\n  vec3 halfwayDir = normalize(lightDir + viewDir);\n  float specular = max(dot(fragNormal, halfwayDir), 0.0);\n  specular = pow(specular, fragSpec);\n\n  colorBuffer = vec4(lightClr * (0.5 + diffuse + specular) * fragColor.rgb, 1.0);\n}",
                                "postProcessShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nuniform sampler2D iRTBuffer0; // color\n\nout vec4 FragColor;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  float exposure = 0.5;\n  vec4 fragColor  = texture(iRTBuffer0, uv);\n  fragColor.rgb = 1.0 - exp(-fragColor.rgb * exposure);\n  \n  FragColor = vec4(fragColor.rgb, 1.0);\n}\n",
                                "properties": "RenderTargetsNumber = 1\nRenderTarget[0].dataType = DATA_TYPE.FLOAT\nRenderTarget[0].pixelFormat = PIXEL_FORMAT.RGBA\nDepthTest = TRUE\nDepthWrite = TRUE\nBlending = Blending.NO",
                                "defaultVertexShader": "uniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform float iTime;\n\nin int index;\nin float side;\n\nout float vH;\nflat out int vI;\nout vec3 vPos;\nout vec3 vNormal;\nout float vX;\n\nvec3 bezier3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    float tt = t * t;\n    float uu = u * u;\n\n    vec3 p = uu * p0; // (1-t)^2 * p0\n    p += 2.0 * u * t * p1; // 2 * (1-t) * t * p1\n    p += tt * p2; // t^2 * p2\n\n    return p;\n}\n\nvec3 bezierGradient3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    vec3 gradient = 2.0 * u * (p1 - p0) + 2.0 * t * (p2 - p1);\n    return gradient;\n}\n\nfloat random(float x) {\n  float r = fract(sin(x * 12.34) * 1234.5678);\n  return r * 2.0 - 1.0;\n}\n\nvec2 random2(vec2 st){\n  float d1 = dot(st, vec2(12.3, 32.1));\n  float d2 = dot(st, vec2(45.6, 65.4));\n  \n  st = vec2(d1, d2);\n  return fract(sin(st) * 78.9) * 2.0 - 1.0;\n}\n\nmat3 rotationYMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      vec3(cosAngle, 0, -sinAngle),\n      vec3(0, 1, 0),\n      vec3(sinAngle, 0, cosAngle)\n    );\n}\n\nvoid main() {\n  int i = index / 20;\n  int vi = index % 10;\n  \n  float h = float(vi / 2) / 4.0;\n  float xSide = mod(float(vi), 2.0);\n  float zSide = ((index % 20) / 10 == 1) ? 1.0 : -1.0;\n  float hash = random(float(i)) * 0.5 + 0.5;\n  vec2 worldPos = random2(vec2(hash)) * vec2(4.0, 2.0);\n  mat3 rotateY = rotationYMatrix(random(float(i)) * 3.14);\n\n  float lean = sin(iTime * 1.5 + random(hash * 3.14) * 2.0) * 0.5;\n  \n  vec3 curve = bezier3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.5, 0.0),\n    vec3(0.0, cos(lean), sin(lean)),\n    h\n  );\n\n  vec3 grad = bezierGradient3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.5, 0.0),\n    vec3(0.0, cos(lean), sin(lean)),\n    h\n  );\n  \n  vNormal = normalize(rotateY * vec3(0.0, grad.z, -grad.y)) * zSide;\n\n  float dx = xSide * 0.14 - 0.07;\n  dx *= mix(1.0, 0.0, pow(h, 4.0));\n  \n  vec3 pos = rotateY * vec3(dx, curve.y * 1.2, curve.z);\n  pos += vec3(worldPos.x, 0.0, worldPos.y);\n  \n  vPos = pos;\n  vNormal = normalize(rotateY * zSide * vec3(0.0, grad.z, -grad.y));\n  vH = h;\n  vX = xSide > 0.0 ? 1.0 : -1.0;\n  \n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform mat4 inverseViewMatrix;\n\nin float vH;\nflat in int vI;\nin vec3 vPos;\nin vec3 vNormal;\nin float vX;\n\nlayout(location = 0) out vec4 colorBuffer;\n\nvec3 getViewPos() {\n  return (inverseViewMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz;  \n}\n\nfloat random(float x) {\n   float r = fract(sin(x * 12.34) * 1234.5678);\n   return r;\n}\n\nconst vec3 lightPos = vec3(0.0, 3.0, 0.0);\n\nvoid main() {\n  float t = random(float(vI));\n  \n  vec3 color = mix(vec3(0.3, 0.4, 0.1), vec3(0.2, 0.2, 0.1), t) * vH;\n\n  vec4 fragColor  = vec4(color * (1.0 - abs(vX) * 0.3), 1.0);\n  vec3 fragNormal = normalize(vNormal);\n  float fragSpec  = 4.0;\n  vec3 fragPos    = vPos;\n  vec3 viewPos    = getViewPos();\n\n  vec3 lightClr = vec3(2.0, 2.0, 1.0);\n  vec3 lightPos = vec3(0.0, 2.5, 5.0);\n  vec3 lightDir = normalize(lightPos - fragPos);\n    \n  float diffuse = max(0.0, dot(fragNormal, lightDir));\n    \n  vec3 viewDir = normalize(viewPos - fragPos);\n  vec3 halfwayDir = normalize(lightDir + viewDir);\n  float specular = max(dot(fragNormal, halfwayDir), 0.0);\n  specular = pow(specular, fragSpec);\n\n  colorBuffer = vec4(lightClr * (0.5 + diffuse + specular) * fragColor.rgb, 1.0);\n}",
                                "defaultPostProcessShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nuniform sampler2D iRTBuffer0; // color\n\nout vec4 FragColor;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  vec4 fragColor = texture(iRTBuffer0, uv);\n  \n  FragColor = vec4(fragColor.rgb, 1.0);\n}\n",
                                "defaultProperties": "RenderTargetsNumber = 1\nRenderTarget[0].dataType = DATA_TYPE.UNSIGNED_BYTE\nRenderTarget[0].pixelFormat = PIXEL_FORMAT.RGBA\nDepthTest = TRUE\nDepthWrite = TRUE\nBlending = Blending.NO",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": false,
                                "postProcessCodeEditable": true,
                                "propertiesEditable": true,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":0,\"y\":2.5,\"z\":13},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":45,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":-0.5,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":\"12\",\"model\":null,\"meshes\":[{\"name\":\"main\",\"materialId\":0}],\"colorRGBA\":\"FFFFFF\",\"color\":16777215},{\"position\":{\"x\":-1,\"y\":-0.5,\"z\":-1},\"rotation\":{\"x\":0,\"y\":0.5,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":\"10\",\"model\":\"Cow.glb\",\"meshes\":[{\"name\":\"Cow_1\",\"materialId\":3},{\"name\":\"Cow_2\",\"materialId\":3},{\"name\":\"Cow_3\",\"materialId\":3},{\"name\":\"Cow_4\",\"materialId\":3},{\"name\":\"Cow_5\",\"materialId\":3},{\"name\":\"Cow_6\",\"materialId\":3},{\"name\":\"Cow_7\",\"materialId\":3}],\"colorRGBA\":\"FFFFFF\",\"color\":null},{\"position\":{\"x\":0,\"y\":0,\"z\":9},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":8,\"y\":2,\"z\":7},\"geometry\":\"2\",\"model\":null,\"meshes\":[{\"name\":\"main\",\"materialId\":1}],\"colorRGBA\":\"442211\",\"color\":4465169},{\"position\":{\"x\":0,\"y\":5,\"z\":9},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":8,\"y\":2,\"z\":7},\"geometry\":\"2\",\"model\":null,\"meshes\":[{\"name\":\"main\",\"materialId\":1}],\"colorRGBA\":\"442211\",\"color\":4465169},{\"position\":{\"x\":-3,\"y\":2.5,\"z\":9},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":2,\"y\":5,\"z\":7},\"geometry\":\"2\",\"model\":null,\"meshes\":[{\"name\":\"main\",\"materialId\":1}],\"colorRGBA\":\"442211\",\"color\":4465169},{\"position\":{\"x\":3,\"y\":2,\"z\":9},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":2,\"y\":5,\"z\":7},\"geometry\":\"2\",\"model\":null,\"meshes\":[{\"name\":\"main\",\"materialId\":1}],\"colorRGBA\":\"442211\",\"color\":4465169},{\"position\":{\"x\":0,\"y\":2.5,\"z\":8.5},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":4,\"y\":3,\"z\":1},\"geometry\":1,\"model\":null,\"meshes\":[{\"name\":\"main\",\"materialId\":2}],\"colorRGBA\":\"FFFFFF\",\"color\":null},{\"position\":{\"x\":0,\"y\":5,\"z\":-10},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":100,\"y\":100,\"z\":1},\"geometry\":1,\"model\":null,\"meshes\":[{\"name\":\"main\",\"materialId\":4}],\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"materials\":[{\"vertex\":\"uniform mat4 modelMatrix;\\nuniform mat4 viewMatrix;\\nuniform mat4 projectionMatrix;\\n\\nin int id;\\nin vec3 position;\\nin vec3 normal;\\nin vec4 color;\\n\\nflat out int vId;\\nout vec4 vColor;\\nout vec3 vNormal;\\nout vec3 vPos;\\n\\nvoid main() {\\n  vId = id;\\n  vColor = color;\\n  vNormal = normalize(mat3(transpose(inverse(modelMatrix))) * normal);\\n  vPos = (modelMatrix * vec4(position, 1.0)).xyz;\\n  \\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\\n}\",\"fragment\":\"uniform mat4 inverseViewMatrix;\\n\\nflat in int vId;\\nin vec4 vColor;\\nin vec3 vNormal;\\nin vec3 vPos;\\n\\nlayout(location = 0) out vec4 colorBuffer;\\n\\nvec3 getViewPos() {\\n  return (inverseViewMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz;  \\n}\\n\\nvoid main() {\\n  vec4 fragColor  = vColor;\\n  vec3 fragNormal = normalize(vNormal);\\n  float fragSpec  = 8.0;\\n  vec3 fragPos    = vPos;\\n  vec3 viewPos    = getViewPos();\\n\\n  vec3 lightClr = vec3(1.0, 1.0, 0.5);\\n  vec3 lightPos = vec3(0.0, 2.5, 0.0);\\n  vec3 lightDir = normalize(lightPos - fragPos);\\n    \\n  float diffuse = max(0.0, dot(fragNormal, lightDir));\\n    \\n  vec3 viewDir = normalize(viewPos - fragPos);\\n  vec3 halfwayDir = normalize(lightDir + viewDir);\\n  float specular = max(dot(fragNormal, halfwayDir), 0.0);\\n  specular = pow(specular, fragSpec);\\n\\n  colorBuffer = vec4((0.75 + diffuse + specular) * fragColor.rgb, 1.0);\\n}\\n\",\"properties\":\"DepthTest = TRUE\\nDepthWrite = TRUE\\nBlending = Blending.NO\"},{\"vertex\":\"uniform mat4 modelMatrix;\\nuniform mat4 viewMatrix;\\nuniform mat4 projectionMatrix;\\n\\nin int id;\\nin vec3 position;\\nin vec3 normal;\\nin vec4 color;\\nin vec2 uv;\\n\\nflat out int vId;\\nout vec4 vColor;\\nout vec3 vNormal;\\nout vec3 vPos;\\nout vec2 vUv;\\n\\nvoid main() {\\n  vUv = uv;\\n  vId = id;\\n  vColor = color;\\n  vNormal = normalize(mat3(transpose(inverse(modelMatrix))) * normal);\\n  vPos = (modelMatrix * vec4(position, 1.0)).xyz;\\n  \\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\\n}\",\"fragment\":\"uniform mat4 inverseViewMatrix;\\n\\nflat in int vId;\\nin vec4 vColor;\\nin vec3 vNormal;\\nin vec3 vPos;\\nin vec2 vUv;\\n\\nlayout(location = 0) out vec4 colorBuffer;\\n\\nvoid main() {\\n  float d = 0.25;\\n  float k = smoothstep(0.0, d, vUv.x);\\n  k *= 1.0 - smoothstep(1.0 - d, 1.0, vUv.x);\\n  k *= smoothstep(0.0, d, vUv.y);\\n  k *= 1.0 - smoothstep(1.0 - d, 1.0, vUv.y);\\n  colorBuffer = vColor * k;\\n}\\n\",\"properties\":\"DepthTest = FALSE\\nDepthWrite = FALSE\\nBlending = Blending.ADDITIVE\"},{\"vertex\":\"uniform mat4 modelMatrix;\\nuniform mat4 viewMatrix;\\nuniform mat4 projectionMatrix;\\n\\nin int id;\\nin vec3 position;\\nin vec3 normal;\\nin vec4 color;\\n\\nflat out int vId;\\nout vec4 vColor;\\nout vec3 vNormal;\\nout vec3 vPos;\\n\\nvoid main() {\\n  vId = id;\\n  vColor = color;\\n  vNormal = normalize(mat3(transpose(inverse(modelMatrix))) * normal);\\n  vPos = (modelMatrix * vec4(position, 1.0)).xyz;\\n  \\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\\n}\",\"fragment\":\"uniform mat4 inverseViewMatrix;\\n\\nflat in int vId;\\nin vec4 vColor;\\nin vec3 vNormal;\\nin vec3 vPos;\\n\\nlayout(location = 0) out vec4 colorBuffer;\\n\\nvec3 getViewPos() {\\n  return (inverseViewMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz;  \\n}\\n\\nvoid main() {\\n  vec4 fragColor  = vColor;\\n  vec3 fragNormal = normalize(vNormal);\\n  float fragSpec  = 8.0;\\n  vec3 fragPos    = vPos;\\n  vec3 viewPos    = getViewPos();\\n\\n  vec3 lightClr = vec3(1.0, 1.0, 0.5);\\n  vec3 lightPos = vec3(-2.0, 8.0, 2.0);\\n  vec3 lightDir = normalize(lightPos - fragPos);\\n    \\n  float diffuse = max(0.0, dot(fragNormal, lightDir));\\n    \\n  vec3 viewDir = normalize(viewPos - fragPos);\\n  vec3 halfwayDir = normalize(lightDir + viewDir);\\n  float specular = max(dot(fragNormal, halfwayDir), 0.0);\\n  specular = pow(specular, fragSpec);\\n\\n  colorBuffer = vec4((1.0 + diffuse + specular) * fragColor.rgb * 2.0, 1.0);\\n}\\n\",\"properties\":\"\"},{\"vertex\":\"uniform mat4 modelMatrix;\\nuniform mat4 viewMatrix;\\nuniform mat4 projectionMatrix;\\n\\nin vec3 position;\\n\\nvoid main() {\\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\\n}\",\"fragment\":\"uniform vec2 iResolution;\\n\\nlayout(location = 0) out vec4 colorBuffer;\\n\\nvoid main() {\\n  // Normalized pixel coordinates (from 0 to 1)\\n  vec2 uv = gl_FragCoord.xy / iResolution.xy * 1.0;\\n  vec2 ratio = vec2(iResolution.x / iResolution.y, 1.0); \\n  uv *= ratio;\\n\\n  //vec3 r0 = mix(vec3(0.5, 2.0, 0.5), vec3(1.5, 1.5, 1.0), uv.x);\\n  //vec3 r1 = mix(vec3(0.5, 0.5, 2.0), vec3(1.5, 1.5, 1.0), uv.x);\\n  //vec3 r = mix(r1, r0, uv.y);\\n\\n  vec3 r = mix(vec3(0.2, 0.4, 0.4), vec3(2.0, 1.8, 1.0), smoothstep(0.3, 0.8, uv.y));\\n  \\n  colorBuffer = vec4(r, 1.0);\\n}\\n\",\"properties\":\"\"}],\"actions\":[],\"backgroundRGBA\":\"AAAAAA\",\"background\":11184810,\"customDepthBufferTexture\":false,\"glslVersion\":\"3\"}",
                                "description": "**Standard Dynamic Range (SDR)** has limitations in representing the full range of brightness levels found in real-world scenes. SDR typically uses an 8-bit per channel format, which provides a luminance range of [0, 255]. This limited range can result in loss of detail in both very bright and very dark areas, making images appear less realistic.\n\n<br>\n\n**High Dynamic Range (HDR)** addresses these limitations by using a much wider range of luminance levels. HDR often uses floating-point data types for framebuffers, allowing for a luminance range that can extend to [0.0, 10000.0] or higher. This broader range preserves details in both bright and dark areas, resulting in more realistic and detailed images.\n\n<br>\n\n### Exposure and Tone Mapping\n\n<br>\n\n**Exposure** refers to the amount of light that reaches the camera sensor or the virtual camera in a rendering engine. By adjusting the exposure, you can control how bright or dark an image appears. This is similar to adjusting the exposure settings on a camera to capture the desired amount of light.\n\n<br>\n\n**Tone mapping** is the process of converting High Dynamic Range (HDR) images to a format that can be displayed on devices with a lower dynamic range, such as standard monitors and screens.\n\n<br>\n\n### How They Work Together\n\n<br>\n\nWhen rendering scenes in HDR, the luminance values can be very high, representing a wide range of brightness levels. However, most display devices cannot reproduce this full range. This is where **tone mapping** comes in. Tone mapping compresses the dynamic range of the HDR image to fit within the displayable range of the device.\n\n<br>\n\nExposure is used in conjunction with tone mapping to control the overall brightness of the scene. **Increasing exposure** makes the image brighter, bringing out details in darker areas but potentially causing very bright areas to become overexposed. **Decreasing exposure** makes the image darker, preserving details in bright areas but potentially causing dark areas to lose detail.\n\n<br>\n\nA relatively simple tone mapping algorithm with exposure looks like this:\n\n```\nvec3 srdColor = 1.0 - exp(-hdrColor * exposure);\n```\n\nThe higher the `exposure` value, the brighter the image will appear. The `exp` function is used to apply an exponential tone mapping curve, which helps to compress the dynamic range of the HDR image.\n\n<br>\n\nYou can experiment with given tone mapping function and exposure value interactively on [Desmos](https://www.desmos.com/). This will allow you to visualize the compressing curve.\n\n### Task\n\nIn this task, you will work with a very bright scene rendered using deferred shading. Your goal is to support High Dynamic Range (HDR) rendering. Then apply tone mapping compression with an exposure value of `0.5` to ensure you can see the details in the bright parts of the scene.\n",
                                "hints": [],
                                "restrictions": [],
                                "order": 9,
                                "cost": 10,
                                "threshold": 99,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": false
                            },
                            "vertexShader": "uniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform float iTime;\n\nin int index;\nin float side;\n\nout float vH;\nflat out int vI;\nout vec3 vPos;\nout vec3 vNormal;\nout float vX;\n\nvec3 bezier3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    float tt = t * t;\n    float uu = u * u;\n\n    vec3 p = uu * p0; // (1-t)^2 * p0\n    p += 2.0 * u * t * p1; // 2 * (1-t) * t * p1\n    p += tt * p2; // t^2 * p2\n\n    return p;\n}\n\nvec3 bezierGradient3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    vec3 gradient = 2.0 * u * (p1 - p0) + 2.0 * t * (p2 - p1);\n    return gradient;\n}\n\nfloat random(float x) {\n  float r = fract(sin(x * 12.34) * 1234.5678);\n  return r * 2.0 - 1.0;\n}\n\nvec2 random2(vec2 st){\n  float d1 = dot(st, vec2(12.3, 32.1));\n  float d2 = dot(st, vec2(45.6, 65.4));\n  \n  st = vec2(d1, d2);\n  return fract(sin(st) * 78.9) * 2.0 - 1.0;\n}\n\nmat3 rotationYMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      vec3(cosAngle, 0, -sinAngle),\n      vec3(0, 1, 0),\n      vec3(sinAngle, 0, cosAngle)\n    );\n}\n\nvoid main() {\n  int i = index / 20;\n  int vi = index % 10;\n  \n  float h = float(vi / 2) / 4.0;\n  float xSide = mod(float(vi), 2.0);\n  float zSide = ((index % 20) / 10 == 1) ? 1.0 : -1.0;\n  float hash = random(float(i)) * 0.5 + 0.5;\n  vec2 worldPos = random2(vec2(hash)) * vec2(4.0, 2.0);\n  mat3 rotateY = rotationYMatrix(random(float(i)) * 3.14);\n\n  float lean = sin(iTime * 1.5 + random(hash * 3.14) * 2.0) * 0.5;\n  \n  vec3 curve = bezier3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.5, 0.0),\n    vec3(0.0, cos(lean), sin(lean)),\n    h\n  );\n\n  vec3 grad = bezierGradient3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.5, 0.0),\n    vec3(0.0, cos(lean), sin(lean)),\n    h\n  );\n  \n  vNormal = normalize(rotateY * vec3(0.0, grad.z, -grad.y)) * zSide;\n\n  float dx = xSide * 0.14 - 0.07;\n  dx *= mix(1.0, 0.0, pow(h, 4.0));\n  \n  vec3 pos = rotateY * vec3(dx, curve.y * 1.2, curve.z);\n  pos += vec3(worldPos.x, 0.0, worldPos.y);\n  \n  vPos = pos;\n  vNormal = normalize(rotateY * zSide * vec3(0.0, grad.z, -grad.y));\n  vH = h;\n  vX = xSide > 0.0 ? 1.0 : -1.0;\n  \n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n",
                            "fragmentShader": "uniform mat4 inverseViewMatrix;\n\nin float vH;\nflat in int vI;\nin vec3 vPos;\nin vec3 vNormal;\nin float vX;\n\nlayout(location = 0) out vec4 colorBuffer;\n\nvec3 getViewPos() {\n  return (inverseViewMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz;  \n}\n\nfloat random(float x) {\n   float r = fract(sin(x * 12.34) * 1234.5678);\n   return r;\n}\n\nconst vec3 lightPos = vec3(0.0, 3.0, 0.0);\n\nvoid main() {\n  float t = random(float(vI));\n  \n  vec3 color = mix(vec3(0.3, 0.4, 0.1), vec3(0.2, 0.2, 0.1), t) * vH;\n\n  vec4 fragColor  = vec4(color * (1.0 - abs(vX) * 0.3), 1.0);\n  vec3 fragNormal = normalize(vNormal);\n  float fragSpec  = 4.0;\n  vec3 fragPos    = vPos;\n  vec3 viewPos    = getViewPos();\n\n  vec3 lightClr = vec3(2.0, 2.0, 1.0);\n  vec3 lightPos = vec3(0.0, 2.5, 5.0);\n  vec3 lightDir = normalize(lightPos - fragPos);\n    \n  float diffuse = max(0.0, dot(fragNormal, lightDir));\n    \n  vec3 viewDir = normalize(viewPos - fragPos);\n  vec3 halfwayDir = normalize(lightDir + viewDir);\n  float specular = max(dot(fragNormal, halfwayDir), 0.0);\n  specular = pow(specular, fragSpec);\n\n  colorBuffer = vec4(lightClr * (0.5 + diffuse + specular) * fragColor.rgb, 1.0);\n}",
                            "postProcessShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nuniform sampler2D iRTBuffer0; // color\n\nout vec4 FragColor;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  vec4 fragColor = texture(iRTBuffer0, uv);\n  \n  FragColor = vec4(fragColor.rgb, 1.0);\n}\n",
                            "properties": "RenderTargetsNumber = 1\nRenderTarget[0].dataType = DATA_TYPE.UNSIGNED_BYTE\nRenderTarget[0].pixelFormat = PIXEL_FORMAT.RGBA\nDepthTest = TRUE\nDepthWrite = TRUE\nBlending = Blending.NO",
                            "defaultVertexShader": "uniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform float iTime;\n\nin int index;\nin float side;\n\nout float vH;\nflat out int vI;\nout vec3 vPos;\nout vec3 vNormal;\nout float vX;\n\nvec3 bezier3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    float tt = t * t;\n    float uu = u * u;\n\n    vec3 p = uu * p0; // (1-t)^2 * p0\n    p += 2.0 * u * t * p1; // 2 * (1-t) * t * p1\n    p += tt * p2; // t^2 * p2\n\n    return p;\n}\n\nvec3 bezierGradient3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    vec3 gradient = 2.0 * u * (p1 - p0) + 2.0 * t * (p2 - p1);\n    return gradient;\n}\n\nfloat random(float x) {\n  float r = fract(sin(x * 12.34) * 1234.5678);\n  return r * 2.0 - 1.0;\n}\n\nvec2 random2(vec2 st){\n  float d1 = dot(st, vec2(12.3, 32.1));\n  float d2 = dot(st, vec2(45.6, 65.4));\n  \n  st = vec2(d1, d2);\n  return fract(sin(st) * 78.9) * 2.0 - 1.0;\n}\n\nmat3 rotationYMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      vec3(cosAngle, 0, -sinAngle),\n      vec3(0, 1, 0),\n      vec3(sinAngle, 0, cosAngle)\n    );\n}\n\nvoid main() {\n  int i = index / 20;\n  int vi = index % 10;\n  \n  float h = float(vi / 2) / 4.0;\n  float xSide = mod(float(vi), 2.0);\n  float zSide = ((index % 20) / 10 == 1) ? 1.0 : -1.0;\n  float hash = random(float(i)) * 0.5 + 0.5;\n  vec2 worldPos = random2(vec2(hash)) * vec2(4.0, 2.0);\n  mat3 rotateY = rotationYMatrix(random(float(i)) * 3.14);\n\n  float lean = sin(iTime * 1.5 + random(hash * 3.14) * 2.0) * 0.5;\n  \n  vec3 curve = bezier3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.5, 0.0),\n    vec3(0.0, cos(lean), sin(lean)),\n    h\n  );\n\n  vec3 grad = bezierGradient3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.5, 0.0),\n    vec3(0.0, cos(lean), sin(lean)),\n    h\n  );\n  \n  vNormal = normalize(rotateY * vec3(0.0, grad.z, -grad.y)) * zSide;\n\n  float dx = xSide * 0.14 - 0.07;\n  dx *= mix(1.0, 0.0, pow(h, 4.0));\n  \n  vec3 pos = rotateY * vec3(dx, curve.y * 1.2, curve.z);\n  pos += vec3(worldPos.x, 0.0, worldPos.y);\n  \n  vPos = pos;\n  vNormal = normalize(rotateY * zSide * vec3(0.0, grad.z, -grad.y));\n  vH = h;\n  vX = xSide > 0.0 ? 1.0 : -1.0;\n  \n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform mat4 inverseViewMatrix;\n\nin float vH;\nflat in int vI;\nin vec3 vPos;\nin vec3 vNormal;\nin float vX;\n\nlayout(location = 0) out vec4 colorBuffer;\n\nvec3 getViewPos() {\n  return (inverseViewMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz;  \n}\n\nfloat random(float x) {\n   float r = fract(sin(x * 12.34) * 1234.5678);\n   return r;\n}\n\nconst vec3 lightPos = vec3(0.0, 3.0, 0.0);\n\nvoid main() {\n  float t = random(float(vI));\n  \n  vec3 color = mix(vec3(0.3, 0.4, 0.1), vec3(0.2, 0.2, 0.1), t) * vH;\n\n  vec4 fragColor  = vec4(color * (1.0 - abs(vX) * 0.3), 1.0);\n  vec3 fragNormal = normalize(vNormal);\n  float fragSpec  = 4.0;\n  vec3 fragPos    = vPos;\n  vec3 viewPos    = getViewPos();\n\n  vec3 lightClr = vec3(2.0, 2.0, 1.0);\n  vec3 lightPos = vec3(0.0, 2.5, 5.0);\n  vec3 lightDir = normalize(lightPos - fragPos);\n    \n  float diffuse = max(0.0, dot(fragNormal, lightDir));\n    \n  vec3 viewDir = normalize(viewPos - fragPos);\n  vec3 halfwayDir = normalize(lightDir + viewDir);\n  float specular = max(dot(fragNormal, halfwayDir), 0.0);\n  specular = pow(specular, fragSpec);\n\n  colorBuffer = vec4(lightClr * (0.5 + diffuse + specular) * fragColor.rgb, 1.0);\n}",
                            "defaultPostProcessShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nuniform sampler2D iRTBuffer0; // color\n\nout vec4 FragColor;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  vec4 fragColor = texture(iRTBuffer0, uv);\n  \n  FragColor = vec4(fragColor.rgb, 1.0);\n}\n",
                            "defaultProperties": "RenderTargetsNumber = 1\nRenderTarget[0].dataType = DATA_TYPE.UNSIGNED_BYTE\nRenderTarget[0].pixelFormat = PIXEL_FORMAT.RGBA\nDepthTest = TRUE\nDepthWrite = TRUE\nBlending = Blending.NO",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 196,
                        "slug": "linear-fog",
                        "moduleId": 11,
                        "name": "Linear Fog",
                        "order": 10,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": 0,
                        "premium": false,
                        "child": {
                            "task": {
                                "id": 196,
                                "slug": "linear-fog",
                                "moduleId": 11,
                                "name": "Linear Fog",
                                "vertexShader": "uniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform float iTime;\nuniform sampler2D iChannel0;\n\nin int index;\nin float side;\n\nout float vH;\nflat out int vI;\nout vec3 vPos;\nout vec3 vNormal;\nout float vX;\n\nvec3 bezier3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    float tt = t * t;\n    float uu = u * u;\n\n    vec3 p = uu * p0;\n    p += 2.0 * u * t * p1;\n    p += tt * p2;\n\n    return p;\n}\n\nvec3 bezierGradient3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    vec3 gradient = 2.0 * u * (p1 - p0) + 2.0 * t * (p2 - p1);\n    return gradient;\n}\n\nfloat random(float x) {\n  float r = fract(sin(x * 12.34) * 1234.5678);\n  return r * 2.0 - 1.0;\n}\n\nfloat noise(vec3 st) {\n  vec2 offset = vec2(st.z, 0.0);\n  return texture(iChannel0, fract(st.xy + offset)).r * 2.0 - 1.0;\n}\n\nvec2 random2(vec2 st){\n  float d1 = dot(st, vec2(12.3, 32.1));\n  float d2 = dot(st, vec2(45.6, 65.4));\n  \n  st = vec2(d1, d2);\n  return fract(sin(st) * 78.9) * 2.0 - 1.0;\n}\n\nmat3 rotationXMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      1.0, 0, 0,\n      0, cosAngle, sinAngle,\n      0, -sinAngle, cosAngle\n    );\n}\n\nmat3 rotationYMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      vec3(cosAngle, 0, -sinAngle),\n      vec3(0, 1, 0),\n      vec3(sinAngle, 0, cosAngle)\n    );\n}\n\nvoid main() {\n  int i = index / 20;\n  int vi = index % 10;\n  \n  float h = float(vi / 2) / 4.0;\n  float xSide = mod(float(vi), 2.0);\n  float zSide = ((index % 20) / 10 == 1) ? 1.0 : -1.0;\n  float hash = random(float(i)) * 0.5 + 0.5;\n  vec2 worldPos = random2(vec2(hash)) * 9.0;\n  mat3 rotateY = rotationYMatrix(random(float(i)) * 3.14);\n\n  float windStength = noise(vec3(worldPos * 0.02, 0.0) + iTime * 0.1) * h * 2.0;\n  mat3  windRot = rotationXMatrix(windStength);\n\n  float leanAnimation = noise(vec3(worldPos, iTime * 0.3));\n  float lean = hash * 0.25 + leanAnimation;\n  \n  vec3 curve = bezier3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.8, 0.0),\n    vec3(0.0, cos(lean), sin(lean)),\n    h\n  );\n\n  vec3 grad = bezierGradient3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.5, 0.0),\n    vec3(0.0, cos(lean), sin(lean)),\n    h\n  );\n  \n  float dx = xSide * 0.14 - 0.07;\n  dx *= mix(1.0, 0.0, pow(h, 3.0));\n  \n  vec3 pos = windRot * rotateY * vec3(dx, curve.y * 1.5, curve.z);\n  pos += vec3(worldPos.x, 0.0, worldPos.y);\n  \n  vPos = pos;\n  vNormal = normalize(windRot * rotateY * zSide * vec3(0.0, grad.z, -grad.y));\n  vH = h;\n  vX = xSide > 0.0 ? 1.0 : -1.0;\n  \n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n",
                                "fragmentShader": "in float vH;\nflat in int vI;\nin vec3 vPos;\nin vec3 vNormal;\nin float vX;\n\nlayout(location = 0) out vec4 colorBuffer;\nlayout(location = 1) out vec4 normalBuffer;\nlayout(location = 2) out vec4 posBuffer;\n\nfloat random(float x) {\n   float r = fract(sin(x * 12.34) * 1234.5678);\n   return r;\n}\n\nvoid main() {\n  float t = random(float(vI)) * 0.5 + 0.5;\n\n  float h = vH * 0.7 + 0.3;\n  vec3 color = mix(vec3(0.4, 0.8, 0.2) * h, vec3(0.8, 0.4, 0.2) * h, t);\n  \n  colorBuffer = vec4(color * (1.0 - abs(vX) * 0.3), 1.0);\n  normalBuffer = vec4(vNormal, 1.0);\n  posBuffer = vec4(vPos.xyz, 1.0);\n}",
                                "postProcessShader": "uniform float iTime;\nuniform vec2 iResolution;\nuniform mat4 inverseViewMatrix;\n\nuniform sampler2D iRTBuffer0;\nuniform sampler2D iRTBuffer1;\nuniform sampler2D iRTBuffer2;\nuniform sampler2D iDepthBuffer;\n\nout vec4 FragColor;\n\nvec3 getViewPos() {\n  return (inverseViewMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz;  \n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  vec4 fragColor  = texture(iRTBuffer0, uv);\n  vec3 fragNormal = normalize(texture(iRTBuffer1, uv).xyz);\n  float fragSpec  = texture(iRTBuffer1, uv).w;\n  vec3 fragPos    = texture(iRTBuffer2, uv).xyz;\n  vec3 viewPos    = getViewPos();\n  vec3 lightPos    = vec3(0.0, 4.0, 0.0);\n  vec3 lightClr    = vec3(1.0, 0.9, 0.8);\n  \n  vec3 lightDir = normalize(lightPos - fragPos);\n  float diffuse = max(0.0, dot(fragNormal, lightDir));\n  \n  vec3 viewDir = normalize(viewPos - fragPos);\n  vec3 halfwayDir = normalize(lightDir + viewDir);\n  float specular = max(dot(fragNormal, halfwayDir), 0.0);\n  specular = pow(specular, fragSpec);\n\n  vec3 result = lightClr * (0.7 + diffuse + specular) * fragColor.rgb;\n\n  vec3 fogColor  = vec3(0.4, 0.4, 0.3);\n  float fogFar   = 13.0;\n  float fogNear  = 8.0;\n  float fragDist = distance(viewPos, fragPos);\n\n  float fog = 1.0 - (fogFar - fragDist) / (fogFar - fogNear);\n  fog = clamp(fog, 0.0, 1.0);\n  result = mix(result, fogColor, fog);\n  \n  FragColor = vec4(result.rgb, 1.0);\n}\n",
                                "properties": "RenderTargetsNumber = 3\nRenderTarget[0].dataType = DATA_TYPE.UNSIGNED_BYTE\nRenderTarget[0].pixelFormat = PIXEL_FORMAT.RGBA\nRenderTarget[1].dataType = DATA_TYPE.FLOAT\nRenderTarget[1].pixelFormat = PIXEL_FORMAT.RGBA\nRenderTarget[2].dataType = DATA_TYPE.FLOAT\nRenderTarget[2].pixelFormat = PIXEL_FORMAT.RGBA\nDepthTest = TRUE\nDepthWrite = TRUE\nBlending = Blending.NO",
                                "defaultVertexShader": "uniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform float iTime;\nuniform sampler2D iChannel0;\n\nin int index;\nin float side;\n\nout float vH;\nflat out int vI;\nout vec3 vPos;\nout vec3 vNormal;\nout float vX;\n\nvec3 bezier3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    float tt = t * t;\n    float uu = u * u;\n\n    vec3 p = uu * p0;\n    p += 2.0 * u * t * p1;\n    p += tt * p2;\n\n    return p;\n}\n\nvec3 bezierGradient3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    vec3 gradient = 2.0 * u * (p1 - p0) + 2.0 * t * (p2 - p1);\n    return gradient;\n}\n\nfloat random(float x) {\n  float r = fract(sin(x * 12.34) * 1234.5678);\n  return r * 2.0 - 1.0;\n}\n\nfloat noise(vec3 st) {\n  vec2 offset = vec2(st.z, 0.0);\n  return texture(iChannel0, fract(st.xy + offset)).r * 2.0 - 1.0;\n}\n\nvec2 random2(vec2 st){\n  float d1 = dot(st, vec2(12.3, 32.1));\n  float d2 = dot(st, vec2(45.6, 65.4));\n  \n  st = vec2(d1, d2);\n  return fract(sin(st) * 78.9) * 2.0 - 1.0;\n}\n\nmat3 rotationXMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      1.0, 0, 0,\n      0, cosAngle, sinAngle,\n      0, -sinAngle, cosAngle\n    );\n}\n\nmat3 rotationYMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      vec3(cosAngle, 0, -sinAngle),\n      vec3(0, 1, 0),\n      vec3(sinAngle, 0, cosAngle)\n    );\n}\n\nvoid main() {\n  int i = index / 20;\n  int vi = index % 10;\n  \n  float h = float(vi / 2) / 4.0;\n  float xSide = mod(float(vi), 2.0);\n  float zSide = ((index % 20) / 10 == 1) ? 1.0 : -1.0;\n  float hash = random(float(i)) * 0.5 + 0.5;\n  vec2 worldPos = random2(vec2(hash)) * 9.0;\n  mat3 rotateY = rotationYMatrix(random(float(i)) * 3.14);\n\n  float windStength = noise(vec3(worldPos * 0.02, 0.0) + iTime * 0.1) * h * 2.0;\n  mat3  windRot = rotationXMatrix(windStength);\n\n  float leanAnimation = noise(vec3(worldPos, iTime * 0.3));\n  float lean = hash * 0.25 + leanAnimation;\n  \n  vec3 curve = bezier3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.8, 0.0),\n    vec3(0.0, cos(lean), sin(lean)),\n    h\n  );\n\n  vec3 grad = bezierGradient3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.5, 0.0),\n    vec3(0.0, cos(lean), sin(lean)),\n    h\n  );\n  \n  float dx = xSide * 0.14 - 0.07;\n  dx *= mix(1.0, 0.0, pow(h, 3.0));\n  \n  vec3 pos = windRot * rotateY * vec3(dx, curve.y * 1.5, curve.z);\n  pos += vec3(worldPos.x, 0.0, worldPos.y);\n  \n  vPos = pos;\n  vNormal = normalize(windRot * rotateY * zSide * vec3(0.0, grad.z, -grad.y));\n  vH = h;\n  vX = xSide > 0.0 ? 1.0 : -1.0;\n  \n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n",
                                "defaultFragmentShader": "in float vH;\nflat in int vI;\nin vec3 vPos;\nin vec3 vNormal;\nin float vX;\n\nlayout(location = 0) out vec4 colorBuffer;\nlayout(location = 1) out vec4 normalBuffer;\nlayout(location = 2) out vec4 posBuffer;\n\nfloat random(float x) {\n   float r = fract(sin(x * 12.34) * 1234.5678);\n   return r;\n}\n\nvoid main() {\n  float t = random(float(vI)) * 0.5 + 0.5;\n\n  float h = vH * 0.7 + 0.3;\n  vec3 color = mix(vec3(0.4, 0.8, 0.2) * h, vec3(0.8, 0.4, 0.2) * h, t);\n  \n  colorBuffer = vec4(color * (1.0 - abs(vX) * 0.3), 1.0);\n  normalBuffer = vec4(vNormal, 1.0);\n  posBuffer = vec4(vPos.xyz, 1.0);\n}",
                                "defaultPostProcessShader": "uniform float iTime;\nuniform vec2 iResolution;\nuniform mat4 inverseViewMatrix;\n\nuniform sampler2D iRTBuffer0;\nuniform sampler2D iRTBuffer1;\nuniform sampler2D iRTBuffer2;\nuniform sampler2D iDepthBuffer;\n\nout vec4 FragColor;\n\nvec3 getViewPos() {\n  return (inverseViewMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz;  \n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  vec4 fragColor  = texture(iRTBuffer0, uv);\n  vec3 fragNormal = normalize(texture(iRTBuffer1, uv).xyz);\n  float fragSpec  = texture(iRTBuffer1, uv).w;\n  vec3 fragPos    = texture(iRTBuffer2, uv).xyz;\n  vec3 viewPos    = getViewPos();\n  vec3 lightPos    = vec3(0.0, 4.0, 0.0);\n  vec3 lightClr    = vec3(1.0, 0.9, 0.8);\n  vec3 fogColor    = vec3(0.4, 0.4, 0.3);\n  \n  vec3 lightDir = normalize(lightPos - fragPos);\n  float diffuse = max(0.0, dot(fragNormal, lightDir));\n  \n  vec3 viewDir = normalize(viewPos - fragPos);\n  vec3 halfwayDir = normalize(lightDir + viewDir);\n  float specular = max(dot(fragNormal, halfwayDir), 0.0);\n  specular = pow(specular, fragSpec);\n\n  vec3 result = lightClr * (0.7 + diffuse + specular) * fragColor.rgb;\n  \n  FragColor = vec4(result.rgb, 1.0);\n}\n",
                                "defaultProperties": "RenderTargetsNumber = 3\nRenderTarget[0].dataType = DATA_TYPE.UNSIGNED_BYTE\nRenderTarget[0].pixelFormat = PIXEL_FORMAT.RGBA\nRenderTarget[1].dataType = DATA_TYPE.FLOAT\nRenderTarget[1].pixelFormat = PIXEL_FORMAT.RGBA\nRenderTarget[2].dataType = DATA_TYPE.FLOAT\nRenderTarget[2].pixelFormat = PIXEL_FORMAT.RGBA\nDepthTest = TRUE\nDepthWrite = TRUE\nBlending = Blending.NO",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": false,
                                "postProcessCodeEditable": true,
                                "propertiesEditable": true,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":0,\"y\":8,\"z\":10},\"rotation\":{\"x\":0.1,\"y\":0,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":45,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":\"14\",\"model\":null,\"meshes\":[{\"name\":\"main\",\"materialId\":0}],\"colorRGBA\":\"FFFFFF\",\"color\":null},{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":0.6,\"y\":0.6,\"z\":0.6},\"geometry\":\"10\",\"model\":\"Cow.glb\",\"meshes\":[{\"name\":\"Cow_1\",\"materialId\":1},{\"name\":\"Cow_2\",\"materialId\":1},{\"name\":\"Cow_3\",\"materialId\":1},{\"name\":\"Cow_4\",\"materialId\":1},{\"name\":\"Cow_5\",\"materialId\":1},{\"name\":\"Cow_6\",\"materialId\":1},{\"name\":\"Cow_7\",\"materialId\":1}],\"colorRGBA\":\"FFFFFF\",\"color\":null},{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":-1.57,\"y\":0,\"z\":0},\"scale\":{\"x\":50,\"y\":50,\"z\":1},\"geometry\":1,\"model\":null,\"meshes\":[{\"name\":\"main\",\"materialId\":1}],\"colorRGBA\":\"333320\",\"color\":3355424}],\"materials\":[{\"vertex\":\"uniform mat4 modelMatrix;\\nuniform mat4 viewMatrix;\\nuniform mat4 projectionMatrix;\\n\\nin vec3 position;\\nin vec3 normal;\\nin vec4 color;\\n\\nout vec4 vColor;\\nout vec3 vNormal;\\nout vec3 vPos;\\n\\nvoid main() {\\n  vColor = color;\\n  vNormal = normalize(mat3(transpose(inverse(modelMatrix))) * normal);\\n  vPos = (modelMatrix * vec4(position, 1.0)).xyz;\\n  \\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\\n}\",\"fragment\":\"in vec4 vColor;\\nin vec3 vNormal;\\nin vec3 vPos;\\n\\nlayout(location = 0) out vec4 colorBuffer;\\nlayout(location = 1) out vec4 normalBuffer;\\nlayout(location = 2) out vec4 posBuffer;\\n\\nvoid main() {\\n  colorBuffer = vColor;\\n  normalBuffer = vec4(normalize(vNormal), 1.0);\\n  posBuffer = vec4(vPos.xyz, 1.0);\\n}\\n\",\"properties\":\"DepthTest = TRUE\\nDepthWrite = TRUE\\nBlending = Blending.NO\"}],\"actions\":[{\"type\":0,\"speed\":0.25,\"pivot\":{\"x\":0,\"y\":-1,\"z\":0}}],\"backgroundRGBA\":\"506060\",\"background\":5267552,\"customDepthBufferTexture\":false,\"glslVersion\":\"3\"}",
                                "description": "**Fog** is a technique used in computer graphics to simulate the effect of fog in a scene. It helps to create a sense of depth and atmosphere by gradually blending objects with the fog color based on their distance from the camera. It can also be used to limit the view distance, reducing the number of objects that need to be rendered and thus *improving performance*.\n\n<br>\n\n### How Linear Fog Works:\n\n<br>\n\nLinear fog calculates the fog factor based on the distance between the camera and the object. The fog factor determines how much of the object's color is blended with the fog color. The formula for the fog factor in linear fog is:\n\n```\nfogFactor = 1.0 - (fogEnd − fragDistance) / (fogEnd − fogStart)\n```\n\nThe fog factor is then clamped to the range [0.0, 1.0] to ensure it stays within valid bounds.\n\n### Task \n\nEnhance a scene rendered using deferred shading by adding a linear fog effect. The fog should start at a distance of 8.0 units from the camera and become fully opaque at a distance of 13.0 units. Use `fogColor` for blending.",
                                "hints": [],
                                "restrictions": [],
                                "order": 10,
                                "cost": 5,
                                "threshold": 99,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [
                                    {
                                        "index": 0
                                    }
                                ],
                                "animated": true,
                                "animationSteps": 20,
                                "animationStepTime": 1000,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": false
                            },
                            "vertexShader": "uniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform float iTime;\nuniform sampler2D iChannel0;\n\nin int index;\nin float side;\n\nout float vH;\nflat out int vI;\nout vec3 vPos;\nout vec3 vNormal;\nout float vX;\n\nvec3 bezier3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    float tt = t * t;\n    float uu = u * u;\n\n    vec3 p = uu * p0;\n    p += 2.0 * u * t * p1;\n    p += tt * p2;\n\n    return p;\n}\n\nvec3 bezierGradient3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    vec3 gradient = 2.0 * u * (p1 - p0) + 2.0 * t * (p2 - p1);\n    return gradient;\n}\n\nfloat random(float x) {\n  float r = fract(sin(x * 12.34) * 1234.5678);\n  return r * 2.0 - 1.0;\n}\n\nfloat noise(vec3 st) {\n  vec2 offset = vec2(st.z, 0.0);\n  return texture(iChannel0, fract(st.xy + offset)).r * 2.0 - 1.0;\n}\n\nvec2 random2(vec2 st){\n  float d1 = dot(st, vec2(12.3, 32.1));\n  float d2 = dot(st, vec2(45.6, 65.4));\n  \n  st = vec2(d1, d2);\n  return fract(sin(st) * 78.9) * 2.0 - 1.0;\n}\n\nmat3 rotationXMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      1.0, 0, 0,\n      0, cosAngle, sinAngle,\n      0, -sinAngle, cosAngle\n    );\n}\n\nmat3 rotationYMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      vec3(cosAngle, 0, -sinAngle),\n      vec3(0, 1, 0),\n      vec3(sinAngle, 0, cosAngle)\n    );\n}\n\nvoid main() {\n  int i = index / 20;\n  int vi = index % 10;\n  \n  float h = float(vi / 2) / 4.0;\n  float xSide = mod(float(vi), 2.0);\n  float zSide = ((index % 20) / 10 == 1) ? 1.0 : -1.0;\n  float hash = random(float(i)) * 0.5 + 0.5;\n  vec2 worldPos = random2(vec2(hash)) * 9.0;\n  mat3 rotateY = rotationYMatrix(random(float(i)) * 3.14);\n\n  float windStength = noise(vec3(worldPos * 0.02, 0.0) + iTime * 0.1) * h * 2.0;\n  mat3  windRot = rotationXMatrix(windStength);\n\n  float leanAnimation = noise(vec3(worldPos, iTime * 0.3));\n  float lean = hash * 0.25 + leanAnimation;\n  \n  vec3 curve = bezier3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.8, 0.0),\n    vec3(0.0, cos(lean), sin(lean)),\n    h\n  );\n\n  vec3 grad = bezierGradient3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.5, 0.0),\n    vec3(0.0, cos(lean), sin(lean)),\n    h\n  );\n  \n  float dx = xSide * 0.14 - 0.07;\n  dx *= mix(1.0, 0.0, pow(h, 3.0));\n  \n  vec3 pos = windRot * rotateY * vec3(dx, curve.y * 1.5, curve.z);\n  pos += vec3(worldPos.x, 0.0, worldPos.y);\n  \n  vPos = pos;\n  vNormal = normalize(windRot * rotateY * zSide * vec3(0.0, grad.z, -grad.y));\n  vH = h;\n  vX = xSide > 0.0 ? 1.0 : -1.0;\n  \n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n",
                            "fragmentShader": "in float vH;\nflat in int vI;\nin vec3 vPos;\nin vec3 vNormal;\nin float vX;\n\nlayout(location = 0) out vec4 colorBuffer;\nlayout(location = 1) out vec4 normalBuffer;\nlayout(location = 2) out vec4 posBuffer;\n\nfloat random(float x) {\n   float r = fract(sin(x * 12.34) * 1234.5678);\n   return r;\n}\n\nvoid main() {\n  float t = random(float(vI)) * 0.5 + 0.5;\n\n  float h = vH * 0.7 + 0.3;\n  vec3 color = mix(vec3(0.4, 0.8, 0.2) * h, vec3(0.8, 0.4, 0.2) * h, t);\n  \n  colorBuffer = vec4(color * (1.0 - abs(vX) * 0.3), 1.0);\n  normalBuffer = vec4(vNormal, 1.0);\n  posBuffer = vec4(vPos.xyz, 1.0);\n}",
                            "postProcessShader": "uniform float iTime;\nuniform vec2 iResolution;\nuniform mat4 inverseViewMatrix;\n\nuniform sampler2D iRTBuffer0;\nuniform sampler2D iRTBuffer1;\nuniform sampler2D iRTBuffer2;\nuniform sampler2D iDepthBuffer;\n\nout vec4 FragColor;\n\nvec3 getViewPos() {\n  return (inverseViewMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz;  \n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  vec4 fragColor  = texture(iRTBuffer0, uv);\n  vec3 fragNormal = normalize(texture(iRTBuffer1, uv).xyz);\n  float fragSpec  = texture(iRTBuffer1, uv).w;\n  vec3 fragPos    = texture(iRTBuffer2, uv).xyz;\n  vec3 viewPos    = getViewPos();\n  vec3 lightPos    = vec3(0.0, 4.0, 0.0);\n  vec3 lightClr    = vec3(1.0, 0.9, 0.8);\n  vec3 fogColor    = vec3(0.4, 0.4, 0.3);\n  \n  vec3 lightDir = normalize(lightPos - fragPos);\n  float diffuse = max(0.0, dot(fragNormal, lightDir));\n  \n  vec3 viewDir = normalize(viewPos - fragPos);\n  vec3 halfwayDir = normalize(lightDir + viewDir);\n  float specular = max(dot(fragNormal, halfwayDir), 0.0);\n  specular = pow(specular, fragSpec);\n\n  vec3 result = lightClr * (0.7 + diffuse + specular) * fragColor.rgb;\n  \n  FragColor = vec4(result.rgb, 1.0);\n}\n",
                            "properties": "RenderTargetsNumber = 3\nRenderTarget[0].dataType = DATA_TYPE.UNSIGNED_BYTE\nRenderTarget[0].pixelFormat = PIXEL_FORMAT.RGBA\nRenderTarget[1].dataType = DATA_TYPE.FLOAT\nRenderTarget[1].pixelFormat = PIXEL_FORMAT.RGBA\nRenderTarget[2].dataType = DATA_TYPE.FLOAT\nRenderTarget[2].pixelFormat = PIXEL_FORMAT.RGBA\nDepthTest = TRUE\nDepthWrite = TRUE\nBlending = Blending.NO",
                            "defaultVertexShader": "uniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform float iTime;\nuniform sampler2D iChannel0;\n\nin int index;\nin float side;\n\nout float vH;\nflat out int vI;\nout vec3 vPos;\nout vec3 vNormal;\nout float vX;\n\nvec3 bezier3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    float tt = t * t;\n    float uu = u * u;\n\n    vec3 p = uu * p0;\n    p += 2.0 * u * t * p1;\n    p += tt * p2;\n\n    return p;\n}\n\nvec3 bezierGradient3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    vec3 gradient = 2.0 * u * (p1 - p0) + 2.0 * t * (p2 - p1);\n    return gradient;\n}\n\nfloat random(float x) {\n  float r = fract(sin(x * 12.34) * 1234.5678);\n  return r * 2.0 - 1.0;\n}\n\nfloat noise(vec3 st) {\n  vec2 offset = vec2(st.z, 0.0);\n  return texture(iChannel0, fract(st.xy + offset)).r * 2.0 - 1.0;\n}\n\nvec2 random2(vec2 st){\n  float d1 = dot(st, vec2(12.3, 32.1));\n  float d2 = dot(st, vec2(45.6, 65.4));\n  \n  st = vec2(d1, d2);\n  return fract(sin(st) * 78.9) * 2.0 - 1.0;\n}\n\nmat3 rotationXMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      1.0, 0, 0,\n      0, cosAngle, sinAngle,\n      0, -sinAngle, cosAngle\n    );\n}\n\nmat3 rotationYMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      vec3(cosAngle, 0, -sinAngle),\n      vec3(0, 1, 0),\n      vec3(sinAngle, 0, cosAngle)\n    );\n}\n\nvoid main() {\n  int i = index / 20;\n  int vi = index % 10;\n  \n  float h = float(vi / 2) / 4.0;\n  float xSide = mod(float(vi), 2.0);\n  float zSide = ((index % 20) / 10 == 1) ? 1.0 : -1.0;\n  float hash = random(float(i)) * 0.5 + 0.5;\n  vec2 worldPos = random2(vec2(hash)) * 9.0;\n  mat3 rotateY = rotationYMatrix(random(float(i)) * 3.14);\n\n  float windStength = noise(vec3(worldPos * 0.02, 0.0) + iTime * 0.1) * h * 2.0;\n  mat3  windRot = rotationXMatrix(windStength);\n\n  float leanAnimation = noise(vec3(worldPos, iTime * 0.3));\n  float lean = hash * 0.25 + leanAnimation;\n  \n  vec3 curve = bezier3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.8, 0.0),\n    vec3(0.0, cos(lean), sin(lean)),\n    h\n  );\n\n  vec3 grad = bezierGradient3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.5, 0.0),\n    vec3(0.0, cos(lean), sin(lean)),\n    h\n  );\n  \n  float dx = xSide * 0.14 - 0.07;\n  dx *= mix(1.0, 0.0, pow(h, 3.0));\n  \n  vec3 pos = windRot * rotateY * vec3(dx, curve.y * 1.5, curve.z);\n  pos += vec3(worldPos.x, 0.0, worldPos.y);\n  \n  vPos = pos;\n  vNormal = normalize(windRot * rotateY * zSide * vec3(0.0, grad.z, -grad.y));\n  vH = h;\n  vX = xSide > 0.0 ? 1.0 : -1.0;\n  \n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n",
                            "defaultFragmentShader": "in float vH;\nflat in int vI;\nin vec3 vPos;\nin vec3 vNormal;\nin float vX;\n\nlayout(location = 0) out vec4 colorBuffer;\nlayout(location = 1) out vec4 normalBuffer;\nlayout(location = 2) out vec4 posBuffer;\n\nfloat random(float x) {\n   float r = fract(sin(x * 12.34) * 1234.5678);\n   return r;\n}\n\nvoid main() {\n  float t = random(float(vI)) * 0.5 + 0.5;\n\n  float h = vH * 0.7 + 0.3;\n  vec3 color = mix(vec3(0.4, 0.8, 0.2) * h, vec3(0.8, 0.4, 0.2) * h, t);\n  \n  colorBuffer = vec4(color * (1.0 - abs(vX) * 0.3), 1.0);\n  normalBuffer = vec4(vNormal, 1.0);\n  posBuffer = vec4(vPos.xyz, 1.0);\n}",
                            "defaultPostProcessShader": "uniform float iTime;\nuniform vec2 iResolution;\nuniform mat4 inverseViewMatrix;\n\nuniform sampler2D iRTBuffer0;\nuniform sampler2D iRTBuffer1;\nuniform sampler2D iRTBuffer2;\nuniform sampler2D iDepthBuffer;\n\nout vec4 FragColor;\n\nvec3 getViewPos() {\n  return (inverseViewMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz;  \n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  vec4 fragColor  = texture(iRTBuffer0, uv);\n  vec3 fragNormal = normalize(texture(iRTBuffer1, uv).xyz);\n  float fragSpec  = texture(iRTBuffer1, uv).w;\n  vec3 fragPos    = texture(iRTBuffer2, uv).xyz;\n  vec3 viewPos    = getViewPos();\n  vec3 lightPos    = vec3(0.0, 4.0, 0.0);\n  vec3 lightClr    = vec3(1.0, 0.9, 0.8);\n  vec3 fogColor    = vec3(0.4, 0.4, 0.3);\n  \n  vec3 lightDir = normalize(lightPos - fragPos);\n  float diffuse = max(0.0, dot(fragNormal, lightDir));\n  \n  vec3 viewDir = normalize(viewPos - fragPos);\n  vec3 halfwayDir = normalize(lightDir + viewDir);\n  float specular = max(dot(fragNormal, halfwayDir), 0.0);\n  specular = pow(specular, fragSpec);\n\n  vec3 result = lightClr * (0.7 + diffuse + specular) * fragColor.rgb;\n  \n  FragColor = vec4(result.rgb, 1.0);\n}\n",
                            "defaultProperties": "RenderTargetsNumber = 3\nRenderTarget[0].dataType = DATA_TYPE.UNSIGNED_BYTE\nRenderTarget[0].pixelFormat = PIXEL_FORMAT.RGBA\nRenderTarget[1].dataType = DATA_TYPE.FLOAT\nRenderTarget[1].pixelFormat = PIXEL_FORMAT.RGBA\nRenderTarget[2].dataType = DATA_TYPE.FLOAT\nRenderTarget[2].pixelFormat = PIXEL_FORMAT.RGBA\nDepthTest = TRUE\nDepthWrite = TRUE\nBlending = Blending.NO",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 197,
                        "slug": "exponential-fog",
                        "moduleId": 11,
                        "name": "Exponential Fog",
                        "order": 11,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": 0,
                        "premium": false,
                        "child": {
                            "task": {
                                "id": 197,
                                "slug": "exponential-fog",
                                "moduleId": 11,
                                "name": "Exponential Fog",
                                "vertexShader": "uniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform float iTime;\nuniform sampler2D iChannel0;\n\nin int index;\nin float side;\n\nout float vH;\nflat out int vI;\nout vec3 vPos;\nout vec3 vNormal;\nout float vX;\n\nvec3 bezier3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    float tt = t * t;\n    float uu = u * u;\n\n    vec3 p = uu * p0;\n    p += 2.0 * u * t * p1;\n    p += tt * p2;\n\n    return p;\n}\n\nvec3 bezierGradient3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    vec3 gradient = 2.0 * u * (p1 - p0) + 2.0 * t * (p2 - p1);\n    return gradient;\n}\n\nfloat random(float x) {\n  float r = fract(sin(x * 12.34) * 1234.5678);\n  return r * 2.0 - 1.0;\n}\n\nfloat noise(vec3 st) {\n  vec2 offset = vec2(st.z, 0.0);\n  return texture(iChannel0, fract(st.xy + offset)).r * 2.0 - 1.0;\n}\n\nvec2 random2(vec2 st){\n  float d1 = dot(st, vec2(12.3, 32.1));\n  float d2 = dot(st, vec2(45.6, 65.4));\n  \n  st = vec2(d1, d2);\n  return fract(sin(st) * 78.9) * 2.0 - 1.0;\n}\n\nmat3 rotationXMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      1.0, 0, 0,\n      0, cosAngle, sinAngle,\n      0, -sinAngle, cosAngle\n    );\n}\n\nmat3 rotationYMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      vec3(cosAngle, 0, -sinAngle),\n      vec3(0, 1, 0),\n      vec3(sinAngle, 0, cosAngle)\n    );\n}\n\nvoid main() {\n  int i = index / 20;\n  int vi = index % 10;\n  \n  float h = float(vi / 2) / 4.0;\n  float xSide = mod(float(vi), 2.0);\n  float zSide = ((index % 20) / 10 == 1) ? 1.0 : -1.0;\n  float hash = random(float(i)) * 0.5 + 0.5;\n  vec2 worldPos = random2(vec2(hash)) * 9.0;\n  mat3 rotateY = rotationYMatrix(random(float(i)) * 3.14);\n\n  float windStength = noise(vec3(worldPos * 0.02, 0.0) + iTime * 0.1) * h * 2.0;\n  mat3  windRot = rotationXMatrix(windStength);\n\n  float leanAnimation = noise(vec3(worldPos, iTime * 0.3));\n  float lean = hash * 0.25 + leanAnimation;\n  \n  vec3 curve = bezier3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.8, 0.0),\n    vec3(0.0, cos(lean), sin(lean)),\n    h\n  );\n\n  vec3 grad = bezierGradient3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.5, 0.0),\n    vec3(0.0, cos(lean), sin(lean)),\n    h\n  );\n  \n  float dx = xSide * 0.14 - 0.07;\n  dx *= mix(1.0, 0.0, pow(h, 3.0));\n  \n  vec3 pos = windRot * rotateY * vec3(dx, curve.y * 1.5, curve.z);\n  pos += vec3(worldPos.x, 0.0, worldPos.y);\n  \n  vPos = pos;\n  vNormal = normalize(windRot * rotateY * zSide * vec3(0.0, grad.z, -grad.y));\n  vH = h;\n  vX = xSide > 0.0 ? 1.0 : -1.0;\n  \n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n",
                                "fragmentShader": "in float vH;\nflat in int vI;\nin vec3 vPos;\nin vec3 vNormal;\nin float vX;\n\nlayout(location = 0) out vec4 colorBuffer;\nlayout(location = 1) out vec4 normalBuffer;\nlayout(location = 2) out vec4 posBuffer;\n\nfloat random(float x) {\n   float r = fract(sin(x * 12.34) * 1234.5678);\n   return r;\n}\n\nvoid main() {\n  float t = random(float(vI)) * 0.5 + 0.5;\n\n  float h = vH * 0.7 + 0.3;\n  vec3 color = mix(vec3(0.4, 0.8, 0.2) * h, vec3(0.8, 0.4, 0.2) * h, t);\n  \n  colorBuffer = vec4(color * (1.0 - abs(vX) * 0.3), 1.0);\n  normalBuffer = vec4(vNormal, 1.0);\n  posBuffer = vec4(vPos.xyz, 1.0);\n}",
                                "postProcessShader": "uniform float iTime;\nuniform vec2 iResolution;\nuniform mat4 inverseViewMatrix;\n\nuniform sampler2D iRTBuffer0;\nuniform sampler2D iRTBuffer1;\nuniform sampler2D iRTBuffer2;\nuniform sampler2D iDepthBuffer;\n\nout vec4 FragColor;\n\nvec3 getViewPos() {\n  return (inverseViewMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz;  \n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  vec4 fragColor  = texture(iRTBuffer0, uv);\n  vec3 fragNormal = normalize(texture(iRTBuffer1, uv).xyz);\n  float fragSpec  = texture(iRTBuffer1, uv).w;\n  vec3 fragPos    = texture(iRTBuffer2, uv).xyz;\n  vec3 viewPos    = getViewPos();\n  vec3 lightPos    = vec3(0.0, 4.0, 0.0);\n  vec3 lightClr    = vec3(1.0, 0.9, 0.8);\n  vec3 fogColor    = vec3(0.4, 0.4, 0.3);\n  \n  vec3 lightDir = normalize(lightPos - fragPos);\n  float diffuse = max(0.0, dot(fragNormal, lightDir));\n  \n  vec3 viewDir = normalize(viewPos - fragPos);\n  vec3 halfwayDir = normalize(lightDir + viewDir);\n  float specular = max(dot(fragNormal, halfwayDir), 0.0);\n  specular = pow(specular, fragSpec);\n\n  vec3 result = lightClr * (0.7 + diffuse + specular) * fragColor.rgb;\n\n  float fogFar = 13.0;\n  float fogNear = 8.0;\n  float fragDist = distance(viewPos, fragPos);\n  \n  float fogDencity = 4.605 / (fogFar - fogNear);\n  float fog = 1.0 - exp(-1.0 * fogDencity * (fragDist - fogNear));\n  fog = clamp(fog, 0.0, 1.0);\n\n  result = mix(result, fogColor, fog);\n  \n  FragColor = vec4(result.rgb, 1.0);\n}\n",
                                "properties": "RenderTargetsNumber = 3\nRenderTarget[0].dataType = DATA_TYPE.UNSIGNED_BYTE\nRenderTarget[0].pixelFormat = PIXEL_FORMAT.RGBA\nRenderTarget[1].dataType = DATA_TYPE.FLOAT\nRenderTarget[1].pixelFormat = PIXEL_FORMAT.RGBA\nRenderTarget[2].dataType = DATA_TYPE.FLOAT\nRenderTarget[2].pixelFormat = PIXEL_FORMAT.RGBA\nDepthTest = TRUE\nDepthWrite = TRUE\nBlending = Blending.NO",
                                "defaultVertexShader": "uniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform float iTime;\nuniform sampler2D iChannel0;\n\nin int index;\nin float side;\n\nout float vH;\nflat out int vI;\nout vec3 vPos;\nout vec3 vNormal;\nout float vX;\n\nvec3 bezier3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    float tt = t * t;\n    float uu = u * u;\n\n    vec3 p = uu * p0;\n    p += 2.0 * u * t * p1;\n    p += tt * p2;\n\n    return p;\n}\n\nvec3 bezierGradient3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    vec3 gradient = 2.0 * u * (p1 - p0) + 2.0 * t * (p2 - p1);\n    return gradient;\n}\n\nfloat random(float x) {\n  float r = fract(sin(x * 12.34) * 1234.5678);\n  return r * 2.0 - 1.0;\n}\n\nfloat noise(vec3 st) {\n  vec2 offset = vec2(st.z, 0.0);\n  return texture(iChannel0, fract(st.xy + offset)).r * 2.0 - 1.0;\n}\n\nvec2 random2(vec2 st){\n  float d1 = dot(st, vec2(12.3, 32.1));\n  float d2 = dot(st, vec2(45.6, 65.4));\n  \n  st = vec2(d1, d2);\n  return fract(sin(st) * 78.9) * 2.0 - 1.0;\n}\n\nmat3 rotationXMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      1.0, 0, 0,\n      0, cosAngle, sinAngle,\n      0, -sinAngle, cosAngle\n    );\n}\n\nmat3 rotationYMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      vec3(cosAngle, 0, -sinAngle),\n      vec3(0, 1, 0),\n      vec3(sinAngle, 0, cosAngle)\n    );\n}\n\nvoid main() {\n  int i = index / 20;\n  int vi = index % 10;\n  \n  float h = float(vi / 2) / 4.0;\n  float xSide = mod(float(vi), 2.0);\n  float zSide = ((index % 20) / 10 == 1) ? 1.0 : -1.0;\n  float hash = random(float(i)) * 0.5 + 0.5;\n  vec2 worldPos = random2(vec2(hash)) * 9.0;\n  mat3 rotateY = rotationYMatrix(random(float(i)) * 3.14);\n\n  float windStength = noise(vec3(worldPos * 0.02, 0.0) + iTime * 0.1) * h * 2.0;\n  mat3  windRot = rotationXMatrix(windStength);\n\n  float leanAnimation = noise(vec3(worldPos, iTime * 0.3));\n  float lean = hash * 0.25 + leanAnimation;\n  \n  vec3 curve = bezier3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.8, 0.0),\n    vec3(0.0, cos(lean), sin(lean)),\n    h\n  );\n\n  vec3 grad = bezierGradient3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.5, 0.0),\n    vec3(0.0, cos(lean), sin(lean)),\n    h\n  );\n  \n  float dx = xSide * 0.14 - 0.07;\n  dx *= mix(1.0, 0.0, pow(h, 3.0));\n  \n  vec3 pos = windRot * rotateY * vec3(dx, curve.y * 1.5, curve.z);\n  pos += vec3(worldPos.x, 0.0, worldPos.y);\n  \n  vPos = pos;\n  vNormal = normalize(windRot * rotateY * zSide * vec3(0.0, grad.z, -grad.y));\n  vH = h;\n  vX = xSide > 0.0 ? 1.0 : -1.0;\n  \n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n",
                                "defaultFragmentShader": "in float vH;\nflat in int vI;\nin vec3 vPos;\nin vec3 vNormal;\nin float vX;\n\nlayout(location = 0) out vec4 colorBuffer;\nlayout(location = 1) out vec4 normalBuffer;\nlayout(location = 2) out vec4 posBuffer;\n\nfloat random(float x) {\n   float r = fract(sin(x * 12.34) * 1234.5678);\n   return r;\n}\n\nvoid main() {\n  float t = random(float(vI)) * 0.5 + 0.5;\n\n  float h = vH * 0.7 + 0.3;\n  vec3 color = mix(vec3(0.4, 0.8, 0.2) * h, vec3(0.8, 0.4, 0.2) * h, t);\n  \n  colorBuffer = vec4(color * (1.0 - abs(vX) * 0.3), 1.0);\n  normalBuffer = vec4(vNormal, 1.0);\n  posBuffer = vec4(vPos.xyz, 1.0);\n}",
                                "defaultPostProcessShader": "uniform float iTime;\nuniform vec2 iResolution;\nuniform mat4 inverseViewMatrix;\n\nuniform sampler2D iRTBuffer0;\nuniform sampler2D iRTBuffer1;\nuniform sampler2D iRTBuffer2;\nuniform sampler2D iDepthBuffer;\n\nout vec4 FragColor;\n\nvec3 getViewPos() {\n  return (inverseViewMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz;  \n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  vec4 fragColor  = texture(iRTBuffer0, uv);\n  vec3 fragNormal = normalize(texture(iRTBuffer1, uv).xyz);\n  float fragSpec  = texture(iRTBuffer1, uv).w;\n  vec3 fragPos    = texture(iRTBuffer2, uv).xyz;\n  vec3 viewPos    = getViewPos();\n  vec3 lightPos    = vec3(0.0, 4.0, 0.0);\n  vec3 lightClr    = vec3(1.0, 0.9, 0.8);\n  vec3 fogColor    = vec3(0.4, 0.4, 0.3);\n  \n  vec3 lightDir = normalize(lightPos - fragPos);\n  float diffuse = max(0.0, dot(fragNormal, lightDir));\n  \n  vec3 viewDir = normalize(viewPos - fragPos);\n  vec3 halfwayDir = normalize(lightDir + viewDir);\n  float specular = max(dot(fragNormal, halfwayDir), 0.0);\n  specular = pow(specular, fragSpec);\n\n  vec3 result = lightClr * (0.7 + diffuse + specular) * fragColor.rgb;\n  \n  FragColor = vec4(result.rgb, 1.0);\n}\n",
                                "defaultProperties": "RenderTargetsNumber = 3\nRenderTarget[0].dataType = DATA_TYPE.UNSIGNED_BYTE\nRenderTarget[0].pixelFormat = PIXEL_FORMAT.RGBA\nRenderTarget[1].dataType = DATA_TYPE.FLOAT\nRenderTarget[1].pixelFormat = PIXEL_FORMAT.RGBA\nRenderTarget[2].dataType = DATA_TYPE.FLOAT\nRenderTarget[2].pixelFormat = PIXEL_FORMAT.RGBA\nDepthTest = TRUE\nDepthWrite = TRUE\nBlending = Blending.NO",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": false,
                                "postProcessCodeEditable": true,
                                "propertiesEditable": true,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":0,\"y\":8,\"z\":10},\"rotation\":{\"x\":0.1,\"y\":0,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":45,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":\"14\",\"model\":null,\"meshes\":[{\"name\":\"main\",\"materialId\":0}],\"colorRGBA\":\"FFFFFF\",\"color\":null},{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":0.6,\"y\":0.6,\"z\":0.6},\"geometry\":\"10\",\"model\":\"Cow.glb\",\"meshes\":[{\"name\":\"Cow_1\",\"materialId\":1},{\"name\":\"Cow_2\",\"materialId\":1},{\"name\":\"Cow_3\",\"materialId\":1},{\"name\":\"Cow_4\",\"materialId\":1},{\"name\":\"Cow_5\",\"materialId\":1},{\"name\":\"Cow_6\",\"materialId\":1},{\"name\":\"Cow_7\",\"materialId\":1}],\"colorRGBA\":\"FFFFFF\",\"color\":null},{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":-1.57,\"y\":0,\"z\":0},\"scale\":{\"x\":50,\"y\":50,\"z\":1},\"geometry\":1,\"model\":null,\"meshes\":[{\"name\":\"main\",\"materialId\":1}],\"colorRGBA\":\"333320\",\"color\":3355424}],\"materials\":[{\"vertex\":\"uniform mat4 modelMatrix;\\nuniform mat4 viewMatrix;\\nuniform mat4 projectionMatrix;\\n\\nin vec3 position;\\nin vec3 normal;\\nin vec4 color;\\n\\nout vec4 vColor;\\nout vec3 vNormal;\\nout vec3 vPos;\\n\\nvoid main() {\\n  vColor = color;\\n  vNormal = normalize(mat3(transpose(inverse(modelMatrix))) * normal);\\n  vPos = (modelMatrix * vec4(position, 1.0)).xyz;\\n  \\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\\n}\",\"fragment\":\"in vec4 vColor;\\nin vec3 vNormal;\\nin vec3 vPos;\\n\\nlayout(location = 0) out vec4 colorBuffer;\\nlayout(location = 1) out vec4 normalBuffer;\\nlayout(location = 2) out vec4 posBuffer;\\n\\nvoid main() {\\n  colorBuffer = vColor;\\n  normalBuffer = vec4(normalize(vNormal), 1.0);\\n  posBuffer = vec4(vPos.xyz, 1.0);\\n}\\n\",\"properties\":\"DepthTest = TRUE\\nDepthWrite = TRUE\\nBlending = Blending.NO\"}],\"actions\":[{\"type\":0,\"speed\":0.25,\"pivot\":{\"x\":0,\"y\":-1,\"z\":0}}],\"backgroundRGBA\":\"506060\",\"background\":5267552,\"customDepthBufferTexture\":false,\"glslVersion\":\"3\"}",
                                "description": "Unlike linear fog, which increases linearly with distance, **exponential fog** increases exponentially, providing a more natural and realistic appearance. In the real world, fog density often increases exponentially with distance.\n\n<br>\n\n### How Exponential Fog Works\n\n<br>\n\nExponential fog calculates the fog factor based on dencity parameter and the distance between the camera and the object. The fog factor determines how much of the object's color is blended with the fog color:\n\n```\nfogFactor = 1.0 − exp(−density * fragDistance)\n```\n\nThe fog factor is then clamped to the range [0.0, 1.0] to ensure it stays within valid bounds.\n\n<br>\n\n### Far Far Distance\n\n<br>\n\nSometimes, it is more convenient to specify the far fog distance rather than the density value. This is because the far fog distance directly relates to the visual effect you want to achieve in your scene. By specifying the distance at which the fog becomes nearly opaque, you can easily control how the fog interacts with objects at various distances, making it simpler to achieve the desired atmospheric effect without having to manually adjust the density value.\n\n<br>\n\nTo determine the fog density, we need to establish the distance at which the fog becomes nearly opaque. Typically, this is the distance where the fog intensity reaches 99% of its maximum value, i.e., `fogFactor = 0.99`.\n\n<br>\n\nBy substituting this value into the equation, we get:\n\n```\n0.99 = 1.0 − exp(−density * fogFar)\n```\n\nsolving this equation for `density`:\n\n```\nexp(−density * fogFar) = 0.01\n```\n\ntaking the natural logarithm of both sides:\n\n```\n−density * fogFar= ln(0.01)\n```\n\nsolving for `denicity`:\n\n```\ndensity = -ln(0.01) / fogFar\n```\n\nThe natural logarithm of 0.01 (`ln(0.01)`) is approximately -4.605. Therefore, the formula for fog density becomes:\n\n```\ndensity ≈ 4.605 / fogFar\n```\n\n### Task\n\nModify the exponential fog calculation so that the fog effect starts only at a distance of 8.0 units from the camera. Before reaching this distance, the fog factor will be 0, meaning no fog effect is applied. The fog become fully opaque at a distance of 13.0 units.",
                                "hints": [],
                                "restrictions": [],
                                "order": 11,
                                "cost": 5,
                                "threshold": 99,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [
                                    {
                                        "index": 0
                                    }
                                ],
                                "animated": true,
                                "animationSteps": 20,
                                "animationStepTime": 1000,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": false
                            },
                            "vertexShader": "uniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform float iTime;\nuniform sampler2D iChannel0;\n\nin int index;\nin float side;\n\nout float vH;\nflat out int vI;\nout vec3 vPos;\nout vec3 vNormal;\nout float vX;\n\nvec3 bezier3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    float tt = t * t;\n    float uu = u * u;\n\n    vec3 p = uu * p0;\n    p += 2.0 * u * t * p1;\n    p += tt * p2;\n\n    return p;\n}\n\nvec3 bezierGradient3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    vec3 gradient = 2.0 * u * (p1 - p0) + 2.0 * t * (p2 - p1);\n    return gradient;\n}\n\nfloat random(float x) {\n  float r = fract(sin(x * 12.34) * 1234.5678);\n  return r * 2.0 - 1.0;\n}\n\nfloat noise(vec3 st) {\n  vec2 offset = vec2(st.z, 0.0);\n  return texture(iChannel0, fract(st.xy + offset)).r * 2.0 - 1.0;\n}\n\nvec2 random2(vec2 st){\n  float d1 = dot(st, vec2(12.3, 32.1));\n  float d2 = dot(st, vec2(45.6, 65.4));\n  \n  st = vec2(d1, d2);\n  return fract(sin(st) * 78.9) * 2.0 - 1.0;\n}\n\nmat3 rotationXMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      1.0, 0, 0,\n      0, cosAngle, sinAngle,\n      0, -sinAngle, cosAngle\n    );\n}\n\nmat3 rotationYMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      vec3(cosAngle, 0, -sinAngle),\n      vec3(0, 1, 0),\n      vec3(sinAngle, 0, cosAngle)\n    );\n}\n\nvoid main() {\n  int i = index / 20;\n  int vi = index % 10;\n  \n  float h = float(vi / 2) / 4.0;\n  float xSide = mod(float(vi), 2.0);\n  float zSide = ((index % 20) / 10 == 1) ? 1.0 : -1.0;\n  float hash = random(float(i)) * 0.5 + 0.5;\n  vec2 worldPos = random2(vec2(hash)) * 9.0;\n  mat3 rotateY = rotationYMatrix(random(float(i)) * 3.14);\n\n  float windStength = noise(vec3(worldPos * 0.02, 0.0) + iTime * 0.1) * h * 2.0;\n  mat3  windRot = rotationXMatrix(windStength);\n\n  float leanAnimation = noise(vec3(worldPos, iTime * 0.3));\n  float lean = hash * 0.25 + leanAnimation;\n  \n  vec3 curve = bezier3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.8, 0.0),\n    vec3(0.0, cos(lean), sin(lean)),\n    h\n  );\n\n  vec3 grad = bezierGradient3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.5, 0.0),\n    vec3(0.0, cos(lean), sin(lean)),\n    h\n  );\n  \n  float dx = xSide * 0.14 - 0.07;\n  dx *= mix(1.0, 0.0, pow(h, 3.0));\n  \n  vec3 pos = windRot * rotateY * vec3(dx, curve.y * 1.5, curve.z);\n  pos += vec3(worldPos.x, 0.0, worldPos.y);\n  \n  vPos = pos;\n  vNormal = normalize(windRot * rotateY * zSide * vec3(0.0, grad.z, -grad.y));\n  vH = h;\n  vX = xSide > 0.0 ? 1.0 : -1.0;\n  \n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n",
                            "fragmentShader": "in float vH;\nflat in int vI;\nin vec3 vPos;\nin vec3 vNormal;\nin float vX;\n\nlayout(location = 0) out vec4 colorBuffer;\nlayout(location = 1) out vec4 normalBuffer;\nlayout(location = 2) out vec4 posBuffer;\n\nfloat random(float x) {\n   float r = fract(sin(x * 12.34) * 1234.5678);\n   return r;\n}\n\nvoid main() {\n  float t = random(float(vI)) * 0.5 + 0.5;\n\n  float h = vH * 0.7 + 0.3;\n  vec3 color = mix(vec3(0.4, 0.8, 0.2) * h, vec3(0.8, 0.4, 0.2) * h, t);\n  \n  colorBuffer = vec4(color * (1.0 - abs(vX) * 0.3), 1.0);\n  normalBuffer = vec4(vNormal, 1.0);\n  posBuffer = vec4(vPos.xyz, 1.0);\n}",
                            "postProcessShader": "uniform float iTime;\nuniform vec2 iResolution;\nuniform mat4 inverseViewMatrix;\n\nuniform sampler2D iRTBuffer0;\nuniform sampler2D iRTBuffer1;\nuniform sampler2D iRTBuffer2;\nuniform sampler2D iDepthBuffer;\n\nout vec4 FragColor;\n\nvec3 getViewPos() {\n  return (inverseViewMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz;  \n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  vec4 fragColor  = texture(iRTBuffer0, uv);\n  vec3 fragNormal = normalize(texture(iRTBuffer1, uv).xyz);\n  float fragSpec  = texture(iRTBuffer1, uv).w;\n  vec3 fragPos    = texture(iRTBuffer2, uv).xyz;\n  vec3 viewPos    = getViewPos();\n  vec3 lightPos    = vec3(0.0, 4.0, 0.0);\n  vec3 lightClr    = vec3(1.0, 0.9, 0.8);\n  vec3 fogColor    = vec3(0.4, 0.4, 0.3);\n  \n  vec3 lightDir = normalize(lightPos - fragPos);\n  float diffuse = max(0.0, dot(fragNormal, lightDir));\n  \n  vec3 viewDir = normalize(viewPos - fragPos);\n  vec3 halfwayDir = normalize(lightDir + viewDir);\n  float specular = max(dot(fragNormal, halfwayDir), 0.0);\n  specular = pow(specular, fragSpec);\n\n  vec3 result = lightClr * (0.7 + diffuse + specular) * fragColor.rgb;\n  \n  FragColor = vec4(result.rgb, 1.0);\n}\n",
                            "properties": "RenderTargetsNumber = 3\nRenderTarget[0].dataType = DATA_TYPE.UNSIGNED_BYTE\nRenderTarget[0].pixelFormat = PIXEL_FORMAT.RGBA\nRenderTarget[1].dataType = DATA_TYPE.FLOAT\nRenderTarget[1].pixelFormat = PIXEL_FORMAT.RGBA\nRenderTarget[2].dataType = DATA_TYPE.FLOAT\nRenderTarget[2].pixelFormat = PIXEL_FORMAT.RGBA\nDepthTest = TRUE\nDepthWrite = TRUE\nBlending = Blending.NO",
                            "defaultVertexShader": "uniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform float iTime;\nuniform sampler2D iChannel0;\n\nin int index;\nin float side;\n\nout float vH;\nflat out int vI;\nout vec3 vPos;\nout vec3 vNormal;\nout float vX;\n\nvec3 bezier3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    float tt = t * t;\n    float uu = u * u;\n\n    vec3 p = uu * p0;\n    p += 2.0 * u * t * p1;\n    p += tt * p2;\n\n    return p;\n}\n\nvec3 bezierGradient3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    vec3 gradient = 2.0 * u * (p1 - p0) + 2.0 * t * (p2 - p1);\n    return gradient;\n}\n\nfloat random(float x) {\n  float r = fract(sin(x * 12.34) * 1234.5678);\n  return r * 2.0 - 1.0;\n}\n\nfloat noise(vec3 st) {\n  vec2 offset = vec2(st.z, 0.0);\n  return texture(iChannel0, fract(st.xy + offset)).r * 2.0 - 1.0;\n}\n\nvec2 random2(vec2 st){\n  float d1 = dot(st, vec2(12.3, 32.1));\n  float d2 = dot(st, vec2(45.6, 65.4));\n  \n  st = vec2(d1, d2);\n  return fract(sin(st) * 78.9) * 2.0 - 1.0;\n}\n\nmat3 rotationXMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      1.0, 0, 0,\n      0, cosAngle, sinAngle,\n      0, -sinAngle, cosAngle\n    );\n}\n\nmat3 rotationYMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      vec3(cosAngle, 0, -sinAngle),\n      vec3(0, 1, 0),\n      vec3(sinAngle, 0, cosAngle)\n    );\n}\n\nvoid main() {\n  int i = index / 20;\n  int vi = index % 10;\n  \n  float h = float(vi / 2) / 4.0;\n  float xSide = mod(float(vi), 2.0);\n  float zSide = ((index % 20) / 10 == 1) ? 1.0 : -1.0;\n  float hash = random(float(i)) * 0.5 + 0.5;\n  vec2 worldPos = random2(vec2(hash)) * 9.0;\n  mat3 rotateY = rotationYMatrix(random(float(i)) * 3.14);\n\n  float windStength = noise(vec3(worldPos * 0.02, 0.0) + iTime * 0.1) * h * 2.0;\n  mat3  windRot = rotationXMatrix(windStength);\n\n  float leanAnimation = noise(vec3(worldPos, iTime * 0.3));\n  float lean = hash * 0.25 + leanAnimation;\n  \n  vec3 curve = bezier3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.8, 0.0),\n    vec3(0.0, cos(lean), sin(lean)),\n    h\n  );\n\n  vec3 grad = bezierGradient3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.5, 0.0),\n    vec3(0.0, cos(lean), sin(lean)),\n    h\n  );\n  \n  float dx = xSide * 0.14 - 0.07;\n  dx *= mix(1.0, 0.0, pow(h, 3.0));\n  \n  vec3 pos = windRot * rotateY * vec3(dx, curve.y * 1.5, curve.z);\n  pos += vec3(worldPos.x, 0.0, worldPos.y);\n  \n  vPos = pos;\n  vNormal = normalize(windRot * rotateY * zSide * vec3(0.0, grad.z, -grad.y));\n  vH = h;\n  vX = xSide > 0.0 ? 1.0 : -1.0;\n  \n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n",
                            "defaultFragmentShader": "in float vH;\nflat in int vI;\nin vec3 vPos;\nin vec3 vNormal;\nin float vX;\n\nlayout(location = 0) out vec4 colorBuffer;\nlayout(location = 1) out vec4 normalBuffer;\nlayout(location = 2) out vec4 posBuffer;\n\nfloat random(float x) {\n   float r = fract(sin(x * 12.34) * 1234.5678);\n   return r;\n}\n\nvoid main() {\n  float t = random(float(vI)) * 0.5 + 0.5;\n\n  float h = vH * 0.7 + 0.3;\n  vec3 color = mix(vec3(0.4, 0.8, 0.2) * h, vec3(0.8, 0.4, 0.2) * h, t);\n  \n  colorBuffer = vec4(color * (1.0 - abs(vX) * 0.3), 1.0);\n  normalBuffer = vec4(vNormal, 1.0);\n  posBuffer = vec4(vPos.xyz, 1.0);\n}",
                            "defaultPostProcessShader": "uniform float iTime;\nuniform vec2 iResolution;\nuniform mat4 inverseViewMatrix;\n\nuniform sampler2D iRTBuffer0;\nuniform sampler2D iRTBuffer1;\nuniform sampler2D iRTBuffer2;\nuniform sampler2D iDepthBuffer;\n\nout vec4 FragColor;\n\nvec3 getViewPos() {\n  return (inverseViewMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz;  \n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  vec4 fragColor  = texture(iRTBuffer0, uv);\n  vec3 fragNormal = normalize(texture(iRTBuffer1, uv).xyz);\n  float fragSpec  = texture(iRTBuffer1, uv).w;\n  vec3 fragPos    = texture(iRTBuffer2, uv).xyz;\n  vec3 viewPos    = getViewPos();\n  vec3 lightPos    = vec3(0.0, 4.0, 0.0);\n  vec3 lightClr    = vec3(1.0, 0.9, 0.8);\n  vec3 fogColor    = vec3(0.4, 0.4, 0.3);\n  \n  vec3 lightDir = normalize(lightPos - fragPos);\n  float diffuse = max(0.0, dot(fragNormal, lightDir));\n  \n  vec3 viewDir = normalize(viewPos - fragPos);\n  vec3 halfwayDir = normalize(lightDir + viewDir);\n  float specular = max(dot(fragNormal, halfwayDir), 0.0);\n  specular = pow(specular, fragSpec);\n\n  vec3 result = lightClr * (0.7 + diffuse + specular) * fragColor.rgb;\n  \n  FragColor = vec4(result.rgb, 1.0);\n}\n",
                            "defaultProperties": "RenderTargetsNumber = 3\nRenderTarget[0].dataType = DATA_TYPE.UNSIGNED_BYTE\nRenderTarget[0].pixelFormat = PIXEL_FORMAT.RGBA\nRenderTarget[1].dataType = DATA_TYPE.FLOAT\nRenderTarget[1].pixelFormat = PIXEL_FORMAT.RGBA\nRenderTarget[2].dataType = DATA_TYPE.FLOAT\nRenderTarget[2].pixelFormat = PIXEL_FORMAT.RGBA\nDepthTest = TRUE\nDepthWrite = TRUE\nBlending = Blending.NO",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 198,
                        "slug": "height-fog",
                        "moduleId": 11,
                        "name": "Height Fog",
                        "order": 12,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": 0,
                        "premium": false,
                        "child": {
                            "task": {
                                "id": 198,
                                "slug": "height-fog",
                                "moduleId": 11,
                                "name": "Height Fog",
                                "vertexShader": "uniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform float iTime;\nuniform sampler2D iChannel0;\n\nin int index;\nin float side;\n\nout float vH;\nflat out int vI;\nout vec3 vPos;\nout vec3 vNormal;\nout float vX;\n\nvec3 bezier3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    float tt = t * t;\n    float uu = u * u;\n\n    vec3 p = uu * p0;\n    p += 2.0 * u * t * p1;\n    p += tt * p2;\n\n    return p;\n}\n\nvec3 bezierGradient3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    vec3 gradient = 2.0 * u * (p1 - p0) + 2.0 * t * (p2 - p1);\n    return gradient;\n}\n\nfloat random(float x) {\n  float r = fract(sin(x * 12.34) * 1234.5678);\n  return r * 2.0 - 1.0;\n}\n\nfloat noise(vec3 st) {\n  vec2 offset = vec2(st.z, 0.0);\n  return texture(iChannel0, fract(st.xy + offset)).r * 2.0 - 1.0;\n}\n\nvec2 random2(vec2 st){\n  float d1 = dot(st, vec2(12.3, 32.1));\n  float d2 = dot(st, vec2(45.6, 65.4));\n  \n  st = vec2(d1, d2);\n  return fract(sin(st) * 78.9) * 2.0 - 1.0;\n}\n\nmat3 rotationXMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      1.0, 0, 0,\n      0, cosAngle, sinAngle,\n      0, -sinAngle, cosAngle\n    );\n}\n\nmat3 rotationYMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      vec3(cosAngle, 0, -sinAngle),\n      vec3(0, 1, 0),\n      vec3(sinAngle, 0, cosAngle)\n    );\n}\n\nvoid main() {\n  int i = index / 20;\n  int vi = index % 10;\n  \n  float h = float(vi / 2) / 4.0;\n  float xSide = mod(float(vi), 2.0);\n  float zSide = ((index % 20) / 10 == 1) ? 1.0 : -1.0;\n  float hash = random(float(i)) * 0.5 + 0.5;\n  vec2 worldPos = random2(vec2(hash)) * 9.0;\n  mat3 rotateY = rotationYMatrix(random(float(i)) * 3.14);\n\n  float windStength = noise(vec3(worldPos * 0.02, 0.0) + iTime * 0.1) * h * 2.0;\n  mat3  windRot = rotationXMatrix(windStength);\n\n  float leanAnimation = noise(vec3(worldPos, iTime * 0.3));\n  float lean = hash * 0.25 + leanAnimation;\n  \n  vec3 curve = bezier3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.8, 0.0),\n    vec3(0.0, cos(lean), sin(lean)),\n    h\n  );\n\n  vec3 grad = bezierGradient3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.5, 0.0),\n    vec3(0.0, cos(lean), sin(lean)),\n    h\n  );\n  \n  float dx = xSide * 0.14 - 0.07;\n  dx *= mix(1.0, 0.0, pow(h, 3.0));\n\n  float height = step(0.0, noise(vec3(worldPos.xy * 0.5, 0.0)));\n  float y = noise(vec3(worldPos.xy * 0.01, 0.0)) * 6.0;\n  vec3 pos = windRot * rotateY * vec3(dx, curve.y * 1.5, curve.z);\n  pos += vec3(worldPos.x, y, worldPos.y);\n  \n  vPos = pos;\n  vNormal = normalize(windRot * rotateY * zSide * vec3(0.0, grad.z, -grad.y));\n  vH = h;\n  vX = xSide > 0.0 ? 1.0 : -1.0;\n  \n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n",
                                "fragmentShader": "in float vH;\nflat in int vI;\nin vec3 vPos;\nin vec3 vNormal;\nin float vX;\n\nlayout(location = 0) out vec4 colorBuffer;\nlayout(location = 1) out vec4 normalBuffer;\nlayout(location = 2) out vec4 posBuffer;\n\nfloat random(float x) {\n   float r = fract(sin(x * 12.34) * 1234.5678);\n   return r;\n}\n\nvoid main() {\n  float t = random(float(vI)) * 0.5 + 0.5;\n\n  float h = vH * 0.7 + 0.3;\n  vec3 color = mix(vec3(0.4, 0.8, 0.2) * h, vec3(0.8, 0.4, 0.2) * h, t);\n  \n  colorBuffer = vec4(color * (1.0 - abs(vX) * 0.3), 1.0);\n  normalBuffer = vec4(vNormal, 1.0);\n  posBuffer = vec4(vPos.xyz, 1.0);\n}",
                                "postProcessShader": "uniform float iTime;\nuniform vec2 iResolution;\nuniform mat4 inverseViewMatrix;\n\nuniform sampler2D iRTBuffer0;\nuniform sampler2D iRTBuffer1;\nuniform sampler2D iRTBuffer2;\nuniform sampler2D iDepthBuffer;\n\nout vec4 FragColor;\n\nvec3 getViewPos() {\n  return (inverseViewMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz;  \n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  vec4 fragColor  = texture(iRTBuffer0, uv);\n  vec3 fragNormal = normalize(texture(iRTBuffer1, uv).xyz);\n  float fragSpec  = texture(iRTBuffer1, uv).w;\n  vec3 fragPos    = texture(iRTBuffer2, uv).xyz;\n  vec3 viewPos    = getViewPos();\n  vec3 lightPos    = vec3(0.0, 10.0, 0.0);\n  vec3 lightClr    = vec3(1.0, 0.9, 0.8);\n  vec3 fogColor    = vec3(0.4, 0.4, 0.3);\n  \n  vec3 lightDir = normalize(lightPos - fragPos);\n  float diffuse = max(0.0, dot(fragNormal, lightDir));\n  \n  vec3 viewDir = normalize(viewPos - fragPos);\n  vec3 halfwayDir = normalize(lightDir + viewDir);\n  float specular = max(dot(fragNormal, halfwayDir), 0.0);\n  specular = pow(specular, fragSpec);\n\n  vec3 result = lightClr * (0.7 + diffuse + specular) * fragColor.rgb;\n\n  float fogOriginY = 0.0;\n  float fogFar = 9.0;\n  float fogDencity = 4.605 / (fogFar - fogOriginY);\n  float fog = exp(-fogDencity * (fragPos.y - fogOriginY));\n  fog = clamp(fog, 0.0, 1.0);\n\n  result = mix(result, fogColor, fog);\n  \n  FragColor = vec4(result.rgb, 1.0);\n}\n",
                                "properties": "RenderTargetsNumber = 3\nRenderTarget[0].dataType = DATA_TYPE.UNSIGNED_BYTE\nRenderTarget[0].pixelFormat = PIXEL_FORMAT.RGBA\nRenderTarget[1].dataType = DATA_TYPE.FLOAT\nRenderTarget[1].pixelFormat = PIXEL_FORMAT.RGBA\nRenderTarget[2].dataType = DATA_TYPE.FLOAT\nRenderTarget[2].pixelFormat = PIXEL_FORMAT.RGBA\nDepthTest = TRUE\nDepthWrite = TRUE\nBlending = Blending.NO",
                                "defaultVertexShader": "uniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform float iTime;\nuniform sampler2D iChannel0;\n\nin int index;\nin float side;\n\nout float vH;\nflat out int vI;\nout vec3 vPos;\nout vec3 vNormal;\nout float vX;\n\nvec3 bezier3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    float tt = t * t;\n    float uu = u * u;\n\n    vec3 p = uu * p0;\n    p += 2.0 * u * t * p1;\n    p += tt * p2;\n\n    return p;\n}\n\nvec3 bezierGradient3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    vec3 gradient = 2.0 * u * (p1 - p0) + 2.0 * t * (p2 - p1);\n    return gradient;\n}\n\nfloat random(float x) {\n  float r = fract(sin(x * 12.34) * 1234.5678);\n  return r * 2.0 - 1.0;\n}\n\nfloat noise(vec3 st) {\n  vec2 offset = vec2(st.z, 0.0);\n  return texture(iChannel0, fract(st.xy + offset)).r * 2.0 - 1.0;\n}\n\nvec2 random2(vec2 st){\n  float d1 = dot(st, vec2(12.3, 32.1));\n  float d2 = dot(st, vec2(45.6, 65.4));\n  \n  st = vec2(d1, d2);\n  return fract(sin(st) * 78.9) * 2.0 - 1.0;\n}\n\nmat3 rotationXMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      1.0, 0, 0,\n      0, cosAngle, sinAngle,\n      0, -sinAngle, cosAngle\n    );\n}\n\nmat3 rotationYMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      vec3(cosAngle, 0, -sinAngle),\n      vec3(0, 1, 0),\n      vec3(sinAngle, 0, cosAngle)\n    );\n}\n\nvoid main() {\n  int i = index / 20;\n  int vi = index % 10;\n  \n  float h = float(vi / 2) / 4.0;\n  float xSide = mod(float(vi), 2.0);\n  float zSide = ((index % 20) / 10 == 1) ? 1.0 : -1.0;\n  float hash = random(float(i)) * 0.5 + 0.5;\n  vec2 worldPos = random2(vec2(hash)) * 9.0;\n  mat3 rotateY = rotationYMatrix(random(float(i)) * 3.14);\n\n  float windStength = noise(vec3(worldPos * 0.02, 0.0) + iTime * 0.1) * h * 2.0;\n  mat3  windRot = rotationXMatrix(windStength);\n\n  float leanAnimation = noise(vec3(worldPos, iTime * 0.3));\n  float lean = hash * 0.25 + leanAnimation;\n  \n  vec3 curve = bezier3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.8, 0.0),\n    vec3(0.0, cos(lean), sin(lean)),\n    h\n  );\n\n  vec3 grad = bezierGradient3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.5, 0.0),\n    vec3(0.0, cos(lean), sin(lean)),\n    h\n  );\n  \n  float dx = xSide * 0.14 - 0.07;\n  dx *= mix(1.0, 0.0, pow(h, 3.0));\n\n  float height = step(0.0, noise(vec3(worldPos.xy * 0.5, 0.0)));\n  float y = noise(vec3(worldPos.xy * 0.01, 0.0)) * 6.0;\n  vec3 pos = windRot * rotateY * vec3(dx, curve.y * 1.5, curve.z);\n  pos += vec3(worldPos.x, y, worldPos.y);\n  \n  vPos = pos;\n  vNormal = normalize(windRot * rotateY * zSide * vec3(0.0, grad.z, -grad.y));\n  vH = h;\n  vX = xSide > 0.0 ? 1.0 : -1.0;\n  \n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n",
                                "defaultFragmentShader": "in float vH;\nflat in int vI;\nin vec3 vPos;\nin vec3 vNormal;\nin float vX;\n\nlayout(location = 0) out vec4 colorBuffer;\nlayout(location = 1) out vec4 normalBuffer;\nlayout(location = 2) out vec4 posBuffer;\n\nfloat random(float x) {\n   float r = fract(sin(x * 12.34) * 1234.5678);\n   return r;\n}\n\nvoid main() {\n  float t = random(float(vI)) * 0.5 + 0.5;\n\n  float h = vH * 0.7 + 0.3;\n  vec3 color = mix(vec3(0.4, 0.8, 0.2) * h, vec3(0.8, 0.4, 0.2) * h, t);\n  \n  colorBuffer = vec4(color * (1.0 - abs(vX) * 0.3), 1.0);\n  normalBuffer = vec4(vNormal, 1.0);\n  posBuffer = vec4(vPos.xyz, 1.0);\n}",
                                "defaultPostProcessShader": "uniform float iTime;\nuniform vec2 iResolution;\nuniform mat4 inverseViewMatrix;\n\nuniform sampler2D iRTBuffer0;\nuniform sampler2D iRTBuffer1;\nuniform sampler2D iRTBuffer2;\nuniform sampler2D iDepthBuffer;\n\nout vec4 FragColor;\n\nvec3 getViewPos() {\n  return (inverseViewMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz;  \n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  vec4 fragColor  = texture(iRTBuffer0, uv);\n  vec3 fragNormal = normalize(texture(iRTBuffer1, uv).xyz);\n  float fragSpec  = texture(iRTBuffer1, uv).w;\n  vec3 fragPos    = texture(iRTBuffer2, uv).xyz;\n  vec3 viewPos    = getViewPos();\n  vec3 lightPos    = vec3(0.0, 10.0, 0.0);\n  vec3 lightClr    = vec3(1.0, 0.9, 0.8);\n  vec3 fogColor    = vec3(0.4, 0.4, 0.3);\n  \n  vec3 lightDir = normalize(lightPos - fragPos);\n  float diffuse = max(0.0, dot(fragNormal, lightDir));\n  \n  vec3 viewDir = normalize(viewPos - fragPos);\n  vec3 halfwayDir = normalize(lightDir + viewDir);\n  float specular = max(dot(fragNormal, halfwayDir), 0.0);\n  specular = pow(specular, fragSpec);\n\n  vec3 result = lightClr * (0.7 + diffuse + specular) * fragColor.rgb;\n  \n  FragColor = vec4(result.rgb, 1.0);\n}\n",
                                "defaultProperties": "RenderTargetsNumber = 3\nRenderTarget[0].dataType = DATA_TYPE.UNSIGNED_BYTE\nRenderTarget[0].pixelFormat = PIXEL_FORMAT.RGBA\nRenderTarget[1].dataType = DATA_TYPE.FLOAT\nRenderTarget[1].pixelFormat = PIXEL_FORMAT.RGBA\nRenderTarget[2].dataType = DATA_TYPE.FLOAT\nRenderTarget[2].pixelFormat = PIXEL_FORMAT.RGBA\nDepthTest = TRUE\nDepthWrite = TRUE\nBlending = Blending.NO",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": false,
                                "postProcessCodeEditable": true,
                                "propertiesEditable": true,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":0,\"y\":10,\"z\":17},\"rotation\":{\"x\":-0.6,\"y\":0,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":45,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":\"14\",\"model\":null,\"meshes\":[{\"name\":\"main\",\"materialId\":0}],\"colorRGBA\":\"FFFFFF\",\"color\":null},{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":-0.25,\"y\":3.14,\"z\":0},\"scale\":{\"x\":0.6,\"y\":0.6,\"z\":0.6},\"geometry\":\"10\",\"model\":\"Cow.glb\",\"meshes\":[{\"name\":\"Cow_1\",\"materialId\":1},{\"name\":\"Cow_2\",\"materialId\":1},{\"name\":\"Cow_3\",\"materialId\":1},{\"name\":\"Cow_4\",\"materialId\":1},{\"name\":\"Cow_5\",\"materialId\":1},{\"name\":\"Cow_6\",\"materialId\":1},{\"name\":\"Cow_7\",\"materialId\":1}],\"colorRGBA\":\"FFFFFF\",\"color\":null},{\"position\":{\"x\":0,\"y\":-10,\"z\":0},\"rotation\":{\"x\":-1.57,\"y\":0,\"z\":0},\"scale\":{\"x\":1000,\"y\":1000,\"z\":1000},\"geometry\":1,\"model\":null,\"meshes\":[{\"name\":\"main\",\"materialId\":2}],\"colorRGBA\":\"506060\",\"color\":5267552},{\"position\":{\"x\":6,\"y\":-1.5,\"z\":2},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1.5,\"y\":1.5,\"z\":1.5},\"geometry\":\"10\",\"model\":\"tree-green.glb\",\"meshes\":[{\"name\":\"Tree_1_1\",\"materialId\":1},{\"name\":\"Tree_1_2\",\"materialId\":1}],\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"materials\":[{\"vertex\":\"uniform mat4 modelMatrix;\\nuniform mat4 viewMatrix;\\nuniform mat4 projectionMatrix;\\n\\nin vec3 position;\\nin vec3 normal;\\nin vec4 color;\\n\\nout vec4 vColor;\\nout vec3 vNormal;\\nout vec3 vPos;\\n\\nvoid main() {\\n  vColor = color;\\n  vNormal = normalize(mat3(transpose(inverse(modelMatrix))) * normal);\\n  vPos = (modelMatrix * vec4(position, 1.0)).xyz;\\n  \\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\\n}\",\"fragment\":\"in vec4 vColor;\\nin vec3 vNormal;\\nin vec3 vPos;\\n\\nlayout(location = 0) out vec4 colorBuffer;\\nlayout(location = 1) out vec4 normalBuffer;\\nlayout(location = 2) out vec4 posBuffer;\\n\\nvoid main() {\\n  colorBuffer = vColor;\\n  normalBuffer = vec4(normalize(vNormal), 1.0);\\n  posBuffer = vec4(vPos.xyz, 1.0);\\n}\\n\",\"properties\":\"DepthTest = TRUE\\nDepthWrite = TRUE\\nBlending = Blending.NO\"},{\"vertex\":\"uniform mat4 modelMatrix;\\nuniform mat4 viewMatrix;\\nuniform mat4 projectionMatrix;\\n\\nin vec3 position;\\nin vec3 normal;\\nin vec4 color;\\n\\nout vec4 vColor;\\nout vec3 vNormal;\\nout vec3 vPos;\\n\\nvoid main() {\\n  vColor = color;\\n  vNormal = normalize(mat3(transpose(inverse(modelMatrix))) * normal);\\n  vPos = (modelMatrix * vec4(position, 1.0)).xyz;\\n  \\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\\n}\",\"fragment\":\"in vec4 vColor;\\nin vec3 vNormal;\\nin vec3 vPos;\\n\\nlayout(location = 0) out vec4 colorBuffer;\\nlayout(location = 1) out vec4 normalBuffer;\\nlayout(location = 2) out vec4 posBuffer;\\n\\nvoid main() {\\n  colorBuffer = vColor;\\n  normalBuffer = vec4(normalize(vNormal) * -1.0, 1.0);\\n  posBuffer = vec4(vPos.x, -1000.0, vPos.z, 1.0);\\n}\\n\",\"properties\":\"\"}],\"actions\":[{\"type\":0,\"speed\":0.5,\"pivot\":{\"x\":0,\"y\":-1,\"z\":0}}],\"backgroundRGBA\":\"506060\",\"background\":5267552,\"customDepthBufferTexture\":false,\"glslVersion\":\"3\"}",
                                "description": "**Height Fog** is a technique used in computer graphics to simulate fog that varies in density based on the height of the terrain or objects in the scene. This type of fog is particularly useful for creating realistic atmospheric effects where fog is denser in lower areas, such as valleys or near the ground, and becomes less dense at higher altitudes, such as on hills or mountains.\n\n<br>\n\n### How Height Fog Works\n\n<br>\n\nThe fog is calculated using an exponential function that depends on the height of the fragment. The formula for the fog factor in exponential height fog is:\n\n```\nfog = exp(-(1.0 / density) * (fragPosY - fogOriginY));\n```\n\nThe fog factor is then clamped to the range [0.0, 1.0] to ensure it stays within valid bounds. `fogOriginY` - the height at which the fog starts to decrease.\n\n<br>\n\nWhen the fragment's Y position is below the fog origin height, the fog is 1.0. As the fragment's Y position increases above the fog origin height, the fog density decreases, leading to clearer visibility.\n\n### Task\nEnhance a scene rendered using deferred shading by adding a height fog effect. The fog should start at a height of 0.0 units and become completely opaque at a height of 9.0 units. Use `fogColor` for blending.",
                                "hints": [],
                                "restrictions": [],
                                "order": 12,
                                "cost": 5,
                                "threshold": 99,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [
                                    {
                                        "index": 0
                                    }
                                ],
                                "animated": true,
                                "animationSteps": 20,
                                "animationStepTime": 1000,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": false
                            },
                            "vertexShader": "uniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform float iTime;\nuniform sampler2D iChannel0;\n\nin int index;\nin float side;\n\nout float vH;\nflat out int vI;\nout vec3 vPos;\nout vec3 vNormal;\nout float vX;\n\nvec3 bezier3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    float tt = t * t;\n    float uu = u * u;\n\n    vec3 p = uu * p0;\n    p += 2.0 * u * t * p1;\n    p += tt * p2;\n\n    return p;\n}\n\nvec3 bezierGradient3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    vec3 gradient = 2.0 * u * (p1 - p0) + 2.0 * t * (p2 - p1);\n    return gradient;\n}\n\nfloat random(float x) {\n  float r = fract(sin(x * 12.34) * 1234.5678);\n  return r * 2.0 - 1.0;\n}\n\nfloat noise(vec3 st) {\n  vec2 offset = vec2(st.z, 0.0);\n  return texture(iChannel0, fract(st.xy + offset)).r * 2.0 - 1.0;\n}\n\nvec2 random2(vec2 st){\n  float d1 = dot(st, vec2(12.3, 32.1));\n  float d2 = dot(st, vec2(45.6, 65.4));\n  \n  st = vec2(d1, d2);\n  return fract(sin(st) * 78.9) * 2.0 - 1.0;\n}\n\nmat3 rotationXMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      1.0, 0, 0,\n      0, cosAngle, sinAngle,\n      0, -sinAngle, cosAngle\n    );\n}\n\nmat3 rotationYMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      vec3(cosAngle, 0, -sinAngle),\n      vec3(0, 1, 0),\n      vec3(sinAngle, 0, cosAngle)\n    );\n}\n\nvoid main() {\n  int i = index / 20;\n  int vi = index % 10;\n  \n  float h = float(vi / 2) / 4.0;\n  float xSide = mod(float(vi), 2.0);\n  float zSide = ((index % 20) / 10 == 1) ? 1.0 : -1.0;\n  float hash = random(float(i)) * 0.5 + 0.5;\n  vec2 worldPos = random2(vec2(hash)) * 9.0;\n  mat3 rotateY = rotationYMatrix(random(float(i)) * 3.14);\n\n  float windStength = noise(vec3(worldPos * 0.02, 0.0) + iTime * 0.1) * h * 2.0;\n  mat3  windRot = rotationXMatrix(windStength);\n\n  float leanAnimation = noise(vec3(worldPos, iTime * 0.3));\n  float lean = hash * 0.25 + leanAnimation;\n  \n  vec3 curve = bezier3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.8, 0.0),\n    vec3(0.0, cos(lean), sin(lean)),\n    h\n  );\n\n  vec3 grad = bezierGradient3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.5, 0.0),\n    vec3(0.0, cos(lean), sin(lean)),\n    h\n  );\n  \n  float dx = xSide * 0.14 - 0.07;\n  dx *= mix(1.0, 0.0, pow(h, 3.0));\n\n  float height = step(0.0, noise(vec3(worldPos.xy * 0.5, 0.0)));\n  float y = noise(vec3(worldPos.xy * 0.01, 0.0)) * 6.0;\n  vec3 pos = windRot * rotateY * vec3(dx, curve.y * 1.5, curve.z);\n  pos += vec3(worldPos.x, y, worldPos.y);\n  \n  vPos = pos;\n  vNormal = normalize(windRot * rotateY * zSide * vec3(0.0, grad.z, -grad.y));\n  vH = h;\n  vX = xSide > 0.0 ? 1.0 : -1.0;\n  \n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n",
                            "fragmentShader": "in float vH;\nflat in int vI;\nin vec3 vPos;\nin vec3 vNormal;\nin float vX;\n\nlayout(location = 0) out vec4 colorBuffer;\nlayout(location = 1) out vec4 normalBuffer;\nlayout(location = 2) out vec4 posBuffer;\n\nfloat random(float x) {\n   float r = fract(sin(x * 12.34) * 1234.5678);\n   return r;\n}\n\nvoid main() {\n  float t = random(float(vI)) * 0.5 + 0.5;\n\n  float h = vH * 0.7 + 0.3;\n  vec3 color = mix(vec3(0.4, 0.8, 0.2) * h, vec3(0.8, 0.4, 0.2) * h, t);\n  \n  colorBuffer = vec4(color * (1.0 - abs(vX) * 0.3), 1.0);\n  normalBuffer = vec4(vNormal, 1.0);\n  posBuffer = vec4(vPos.xyz, 1.0);\n}",
                            "postProcessShader": "uniform float iTime;\nuniform vec2 iResolution;\nuniform mat4 inverseViewMatrix;\n\nuniform sampler2D iRTBuffer0;\nuniform sampler2D iRTBuffer1;\nuniform sampler2D iRTBuffer2;\nuniform sampler2D iDepthBuffer;\n\nout vec4 FragColor;\n\nvec3 getViewPos() {\n  return (inverseViewMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz;  \n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  vec4 fragColor  = texture(iRTBuffer0, uv);\n  vec3 fragNormal = normalize(texture(iRTBuffer1, uv).xyz);\n  float fragSpec  = texture(iRTBuffer1, uv).w;\n  vec3 fragPos    = texture(iRTBuffer2, uv).xyz;\n  vec3 viewPos    = getViewPos();\n  vec3 lightPos    = vec3(0.0, 10.0, 0.0);\n  vec3 lightClr    = vec3(1.0, 0.9, 0.8);\n  vec3 fogColor    = vec3(0.4, 0.4, 0.3);\n  \n  vec3 lightDir = normalize(lightPos - fragPos);\n  float diffuse = max(0.0, dot(fragNormal, lightDir));\n  \n  vec3 viewDir = normalize(viewPos - fragPos);\n  vec3 halfwayDir = normalize(lightDir + viewDir);\n  float specular = max(dot(fragNormal, halfwayDir), 0.0);\n  specular = pow(specular, fragSpec);\n\n  vec3 result = lightClr * (0.7 + diffuse + specular) * fragColor.rgb;\n  \n  FragColor = vec4(result.rgb, 1.0);\n}\n",
                            "properties": "RenderTargetsNumber = 3\nRenderTarget[0].dataType = DATA_TYPE.UNSIGNED_BYTE\nRenderTarget[0].pixelFormat = PIXEL_FORMAT.RGBA\nRenderTarget[1].dataType = DATA_TYPE.FLOAT\nRenderTarget[1].pixelFormat = PIXEL_FORMAT.RGBA\nRenderTarget[2].dataType = DATA_TYPE.FLOAT\nRenderTarget[2].pixelFormat = PIXEL_FORMAT.RGBA\nDepthTest = TRUE\nDepthWrite = TRUE\nBlending = Blending.NO",
                            "defaultVertexShader": "uniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform float iTime;\nuniform sampler2D iChannel0;\n\nin int index;\nin float side;\n\nout float vH;\nflat out int vI;\nout vec3 vPos;\nout vec3 vNormal;\nout float vX;\n\nvec3 bezier3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    float tt = t * t;\n    float uu = u * u;\n\n    vec3 p = uu * p0;\n    p += 2.0 * u * t * p1;\n    p += tt * p2;\n\n    return p;\n}\n\nvec3 bezierGradient3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    vec3 gradient = 2.0 * u * (p1 - p0) + 2.0 * t * (p2 - p1);\n    return gradient;\n}\n\nfloat random(float x) {\n  float r = fract(sin(x * 12.34) * 1234.5678);\n  return r * 2.0 - 1.0;\n}\n\nfloat noise(vec3 st) {\n  vec2 offset = vec2(st.z, 0.0);\n  return texture(iChannel0, fract(st.xy + offset)).r * 2.0 - 1.0;\n}\n\nvec2 random2(vec2 st){\n  float d1 = dot(st, vec2(12.3, 32.1));\n  float d2 = dot(st, vec2(45.6, 65.4));\n  \n  st = vec2(d1, d2);\n  return fract(sin(st) * 78.9) * 2.0 - 1.0;\n}\n\nmat3 rotationXMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      1.0, 0, 0,\n      0, cosAngle, sinAngle,\n      0, -sinAngle, cosAngle\n    );\n}\n\nmat3 rotationYMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      vec3(cosAngle, 0, -sinAngle),\n      vec3(0, 1, 0),\n      vec3(sinAngle, 0, cosAngle)\n    );\n}\n\nvoid main() {\n  int i = index / 20;\n  int vi = index % 10;\n  \n  float h = float(vi / 2) / 4.0;\n  float xSide = mod(float(vi), 2.0);\n  float zSide = ((index % 20) / 10 == 1) ? 1.0 : -1.0;\n  float hash = random(float(i)) * 0.5 + 0.5;\n  vec2 worldPos = random2(vec2(hash)) * 9.0;\n  mat3 rotateY = rotationYMatrix(random(float(i)) * 3.14);\n\n  float windStength = noise(vec3(worldPos * 0.02, 0.0) + iTime * 0.1) * h * 2.0;\n  mat3  windRot = rotationXMatrix(windStength);\n\n  float leanAnimation = noise(vec3(worldPos, iTime * 0.3));\n  float lean = hash * 0.25 + leanAnimation;\n  \n  vec3 curve = bezier3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.8, 0.0),\n    vec3(0.0, cos(lean), sin(lean)),\n    h\n  );\n\n  vec3 grad = bezierGradient3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.5, 0.0),\n    vec3(0.0, cos(lean), sin(lean)),\n    h\n  );\n  \n  float dx = xSide * 0.14 - 0.07;\n  dx *= mix(1.0, 0.0, pow(h, 3.0));\n\n  float height = step(0.0, noise(vec3(worldPos.xy * 0.5, 0.0)));\n  float y = noise(vec3(worldPos.xy * 0.01, 0.0)) * 6.0;\n  vec3 pos = windRot * rotateY * vec3(dx, curve.y * 1.5, curve.z);\n  pos += vec3(worldPos.x, y, worldPos.y);\n  \n  vPos = pos;\n  vNormal = normalize(windRot * rotateY * zSide * vec3(0.0, grad.z, -grad.y));\n  vH = h;\n  vX = xSide > 0.0 ? 1.0 : -1.0;\n  \n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n",
                            "defaultFragmentShader": "in float vH;\nflat in int vI;\nin vec3 vPos;\nin vec3 vNormal;\nin float vX;\n\nlayout(location = 0) out vec4 colorBuffer;\nlayout(location = 1) out vec4 normalBuffer;\nlayout(location = 2) out vec4 posBuffer;\n\nfloat random(float x) {\n   float r = fract(sin(x * 12.34) * 1234.5678);\n   return r;\n}\n\nvoid main() {\n  float t = random(float(vI)) * 0.5 + 0.5;\n\n  float h = vH * 0.7 + 0.3;\n  vec3 color = mix(vec3(0.4, 0.8, 0.2) * h, vec3(0.8, 0.4, 0.2) * h, t);\n  \n  colorBuffer = vec4(color * (1.0 - abs(vX) * 0.3), 1.0);\n  normalBuffer = vec4(vNormal, 1.0);\n  posBuffer = vec4(vPos.xyz, 1.0);\n}",
                            "defaultPostProcessShader": "uniform float iTime;\nuniform vec2 iResolution;\nuniform mat4 inverseViewMatrix;\n\nuniform sampler2D iRTBuffer0;\nuniform sampler2D iRTBuffer1;\nuniform sampler2D iRTBuffer2;\nuniform sampler2D iDepthBuffer;\n\nout vec4 FragColor;\n\nvec3 getViewPos() {\n  return (inverseViewMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz;  \n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  vec4 fragColor  = texture(iRTBuffer0, uv);\n  vec3 fragNormal = normalize(texture(iRTBuffer1, uv).xyz);\n  float fragSpec  = texture(iRTBuffer1, uv).w;\n  vec3 fragPos    = texture(iRTBuffer2, uv).xyz;\n  vec3 viewPos    = getViewPos();\n  vec3 lightPos    = vec3(0.0, 10.0, 0.0);\n  vec3 lightClr    = vec3(1.0, 0.9, 0.8);\n  vec3 fogColor    = vec3(0.4, 0.4, 0.3);\n  \n  vec3 lightDir = normalize(lightPos - fragPos);\n  float diffuse = max(0.0, dot(fragNormal, lightDir));\n  \n  vec3 viewDir = normalize(viewPos - fragPos);\n  vec3 halfwayDir = normalize(lightDir + viewDir);\n  float specular = max(dot(fragNormal, halfwayDir), 0.0);\n  specular = pow(specular, fragSpec);\n\n  vec3 result = lightClr * (0.7 + diffuse + specular) * fragColor.rgb;\n  \n  FragColor = vec4(result.rgb, 1.0);\n}\n",
                            "defaultProperties": "RenderTargetsNumber = 3\nRenderTarget[0].dataType = DATA_TYPE.UNSIGNED_BYTE\nRenderTarget[0].pixelFormat = PIXEL_FORMAT.RGBA\nRenderTarget[1].dataType = DATA_TYPE.FLOAT\nRenderTarget[1].pixelFormat = PIXEL_FORMAT.RGBA\nRenderTarget[2].dataType = DATA_TYPE.FLOAT\nRenderTarget[2].pixelFormat = PIXEL_FORMAT.RGBA\nDepthTest = TRUE\nDepthWrite = TRUE\nBlending = Blending.NO",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 199,
                        "slug": "camera-height-based-fog",
                        "moduleId": 11,
                        "name": "Camera Height Based Fog",
                        "order": 13,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": 0,
                        "premium": false,
                        "child": {
                            "task": {
                                "id": 199,
                                "slug": "camera-height-based-fog",
                                "moduleId": 11,
                                "name": "Camera Height Based Fog",
                                "vertexShader": "uniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform float iTime;\nuniform sampler2D iChannel0;\n\nin int index;\nin float side;\n\nout float vH;\nflat out int vI;\nout vec3 vPos;\nout vec3 vNormal;\nout float vX;\n\nvec3 bezier3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    float tt = t * t;\n    float uu = u * u;\n\n    vec3 p = uu * p0;\n    p += 2.0 * u * t * p1;\n    p += tt * p2;\n\n    return p;\n}\n\nvec3 bezierGradient3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    vec3 gradient = 2.0 * u * (p1 - p0) + 2.0 * t * (p2 - p1);\n    return gradient;\n}\n\nfloat random(float x) {\n  float r = fract(sin(x * 12.34) * 1234.5678);\n  return r * 2.0 - 1.0;\n}\n\nfloat noise(vec3 st) {\n  vec2 offset = vec2(st.z, 0.0);\n  return texture(iChannel0, fract(st.xy + offset)).r * 2.0 - 1.0;\n}\n\nvec2 random2(vec2 st){\n  float d1 = dot(st, vec2(12.3, 32.1));\n  float d2 = dot(st, vec2(45.6, 65.4));\n  \n  st = vec2(d1, d2);\n  return fract(sin(st) * 78.9) * 2.0 - 1.0;\n}\n\nmat3 rotationXMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      1.0, 0, 0,\n      0, cosAngle, sinAngle,\n      0, -sinAngle, cosAngle\n    );\n}\n\nmat3 rotationYMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      vec3(cosAngle, 0, -sinAngle),\n      vec3(0, 1, 0),\n      vec3(sinAngle, 0, cosAngle)\n    );\n}\n\nvoid main() {\n  int i = index / 20;\n  int vi = index % 10;\n  \n  float h = float(vi / 2) / 4.0;\n  float xSide = mod(float(vi), 2.0);\n  float zSide = ((index % 20) / 10 == 1) ? 1.0 : -1.0;\n  float hash = random(float(i)) * 0.5 + 0.5;\n  vec2 worldPos = random2(vec2(hash)) * 9.0;\n  mat3 rotateY = rotationYMatrix(random(float(i)) * 3.14);\n\n  float windStength = noise(vec3(worldPos * 0.02, 0.0) + iTime * 0.1) * h * 2.0;\n  mat3  windRot = rotationXMatrix(windStength);\n\n  float leanAnimation = noise(vec3(worldPos, iTime * 0.3));\n  float lean = hash * 0.25 + leanAnimation;\n  \n  vec3 curve = bezier3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.8, 0.0),\n    vec3(0.0, cos(lean), sin(lean)),\n    h\n  );\n\n  vec3 grad = bezierGradient3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.5, 0.0),\n    vec3(0.0, cos(lean), sin(lean)),\n    h\n  );\n  \n  float dx = xSide * 0.14 - 0.07;\n  dx *= mix(1.0, 0.0, pow(h, 3.0));\n  \n  vec3 pos = windRot * rotateY * vec3(dx, curve.y * 1.5, curve.z);\n  pos += vec3(worldPos.x, 0.0, worldPos.y);\n  \n  vPos = pos;\n  vNormal = normalize(windRot * rotateY * zSide * vec3(0.0, grad.z, -grad.y));\n  vH = h;\n  vX = xSide > 0.0 ? 1.0 : -1.0;\n  \n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n",
                                "fragmentShader": "in float vH;\nflat in int vI;\nin vec3 vPos;\nin vec3 vNormal;\nin float vX;\n\nlayout(location = 0) out vec4 colorBuffer;\nlayout(location = 1) out vec4 normalBuffer;\nlayout(location = 2) out vec4 posBuffer;\n\nfloat random(float x) {\n   float r = fract(sin(x * 12.34) * 1234.5678);\n   return r;\n}\n\nvoid main() {\n  float t = random(float(vI)) * 0.5 + 0.5;\n\n  float h = vH * 0.7 + 0.3;\n  vec3 color = mix(vec3(0.4, 0.8, 0.2) * h, vec3(0.8, 0.4, 0.2) * h, t);\n  \n  colorBuffer = vec4(color * (1.0 - abs(vX) * 0.3), 1.0);\n  normalBuffer = vec4(vNormal, 1.0);\n  posBuffer = vec4(vPos.xyz, 1.0);\n}",
                                "postProcessShader": "uniform float iTime;\nuniform vec2 iResolution;\nuniform mat4 inverseViewMatrix;\n\nuniform sampler2D iRTBuffer0;\nuniform sampler2D iRTBuffer1;\nuniform sampler2D iRTBuffer2;\nuniform sampler2D iDepthBuffer;\n\nout vec4 FragColor;\n\nvec3 getViewPos() {\n  return (inverseViewMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz;  \n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  vec4 fragColor  = texture(iRTBuffer0, uv);\n  vec3 fragNormal = normalize(texture(iRTBuffer1, uv).xyz);\n  float fragSpec  = texture(iRTBuffer1, uv).w;\n  vec3 fragPos    = texture(iRTBuffer2, uv).xyz;\n  vec3 viewPos    = getViewPos();\n  vec3 lightPos    = vec3(0.0, 4.0, 0.0);\n  vec3 lightClr    = vec3(1.0, 0.9, 0.8);\n  vec3 fogColor    = vec3(0.4, 0.4, 0.3);\n  \n  vec3 lightDir = normalize(lightPos - fragPos);\n  float diffuse = max(0.0, dot(fragNormal, lightDir));\n  \n  vec3 viewDir = normalize(viewPos - fragPos);\n  vec3 halfwayDir = normalize(lightDir + viewDir);\n  float specular = max(dot(fragNormal, halfwayDir), 0.0);\n  specular = pow(specular, fragSpec);\n\n  vec3 result = lightClr * (0.7 + diffuse + specular) * fragColor.rgb;\n\n  float fogFar = 10.0;\n  float fogDensity = 4.605 / (fogFar * fogFar);\n  float distanceY = fragPos.y - viewPos.y;\n  float fog = 1.0 - exp(-fogDensity * distanceY * distanceY);\n  fog = clamp(fog, 0.0, 1.0);\n\n  result = mix(result, fogColor, fog);\n  \n  FragColor = vec4(result.rgb, 1.0);\n}\n",
                                "properties": "RenderTargetsNumber = 3\nRenderTarget[0].dataType = DATA_TYPE.UNSIGNED_BYTE\nRenderTarget[0].pixelFormat = PIXEL_FORMAT.RGBA\nRenderTarget[1].dataType = DATA_TYPE.FLOAT\nRenderTarget[1].pixelFormat = PIXEL_FORMAT.RGBA\nRenderTarget[2].dataType = DATA_TYPE.FLOAT\nRenderTarget[2].pixelFormat = PIXEL_FORMAT.RGBA\nDepthTest = TRUE\nDepthWrite = TRUE\nBlending = Blending.NO",
                                "defaultVertexShader": "uniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform float iTime;\nuniform sampler2D iChannel0;\n\nin int index;\nin float side;\n\nout float vH;\nflat out int vI;\nout vec3 vPos;\nout vec3 vNormal;\nout float vX;\n\nvec3 bezier3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    float tt = t * t;\n    float uu = u * u;\n\n    vec3 p = uu * p0;\n    p += 2.0 * u * t * p1;\n    p += tt * p2;\n\n    return p;\n}\n\nvec3 bezierGradient3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    vec3 gradient = 2.0 * u * (p1 - p0) + 2.0 * t * (p2 - p1);\n    return gradient;\n}\n\nfloat random(float x) {\n  float r = fract(sin(x * 12.34) * 1234.5678);\n  return r * 2.0 - 1.0;\n}\n\nfloat noise(vec3 st) {\n  vec2 offset = vec2(st.z, 0.0);\n  return texture(iChannel0, fract(st.xy + offset)).r * 2.0 - 1.0;\n}\n\nvec2 random2(vec2 st){\n  float d1 = dot(st, vec2(12.3, 32.1));\n  float d2 = dot(st, vec2(45.6, 65.4));\n  \n  st = vec2(d1, d2);\n  return fract(sin(st) * 78.9) * 2.0 - 1.0;\n}\n\nmat3 rotationXMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      1.0, 0, 0,\n      0, cosAngle, sinAngle,\n      0, -sinAngle, cosAngle\n    );\n}\n\nmat3 rotationYMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      vec3(cosAngle, 0, -sinAngle),\n      vec3(0, 1, 0),\n      vec3(sinAngle, 0, cosAngle)\n    );\n}\n\nvoid main() {\n  int i = index / 20;\n  int vi = index % 10;\n  \n  float h = float(vi / 2) / 4.0;\n  float xSide = mod(float(vi), 2.0);\n  float zSide = ((index % 20) / 10 == 1) ? 1.0 : -1.0;\n  float hash = random(float(i)) * 0.5 + 0.5;\n  vec2 worldPos = random2(vec2(hash)) * 9.0;\n  mat3 rotateY = rotationYMatrix(random(float(i)) * 3.14);\n\n  float windStength = noise(vec3(worldPos * 0.02, 0.0) + iTime * 0.1) * h * 2.0;\n  mat3  windRot = rotationXMatrix(windStength);\n\n  float leanAnimation = noise(vec3(worldPos, iTime * 0.3));\n  float lean = hash * 0.25 + leanAnimation;\n  \n  vec3 curve = bezier3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.8, 0.0),\n    vec3(0.0, cos(lean), sin(lean)),\n    h\n  );\n\n  vec3 grad = bezierGradient3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.5, 0.0),\n    vec3(0.0, cos(lean), sin(lean)),\n    h\n  );\n  \n  float dx = xSide * 0.14 - 0.07;\n  dx *= mix(1.0, 0.0, pow(h, 3.0));\n  \n  vec3 pos = windRot * rotateY * vec3(dx, curve.y * 1.5, curve.z);\n  pos += vec3(worldPos.x, 0.0, worldPos.y);\n  \n  vPos = pos;\n  vNormal = normalize(windRot * rotateY * zSide * vec3(0.0, grad.z, -grad.y));\n  vH = h;\n  vX = xSide > 0.0 ? 1.0 : -1.0;\n  \n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n",
                                "defaultFragmentShader": "in float vH;\nflat in int vI;\nin vec3 vPos;\nin vec3 vNormal;\nin float vX;\n\nlayout(location = 0) out vec4 colorBuffer;\nlayout(location = 1) out vec4 normalBuffer;\nlayout(location = 2) out vec4 posBuffer;\n\nfloat random(float x) {\n   float r = fract(sin(x * 12.34) * 1234.5678);\n   return r;\n}\n\nvoid main() {\n  float t = random(float(vI)) * 0.5 + 0.5;\n\n  float h = vH * 0.7 + 0.3;\n  vec3 color = mix(vec3(0.4, 0.8, 0.2) * h, vec3(0.8, 0.4, 0.2) * h, t);\n  \n  colorBuffer = vec4(color * (1.0 - abs(vX) * 0.3), 1.0);\n  normalBuffer = vec4(vNormal, 1.0);\n  posBuffer = vec4(vPos.xyz, 1.0);\n}",
                                "defaultPostProcessShader": "uniform float iTime;\nuniform vec2 iResolution;\nuniform mat4 inverseViewMatrix;\n\nuniform sampler2D iRTBuffer0;\nuniform sampler2D iRTBuffer1;\nuniform sampler2D iRTBuffer2;\nuniform sampler2D iDepthBuffer;\n\nout vec4 FragColor;\n\nvec3 getViewPos() {\n  return (inverseViewMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz;  \n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  vec4 fragColor  = texture(iRTBuffer0, uv);\n  vec3 fragNormal = normalize(texture(iRTBuffer1, uv).xyz);\n  float fragSpec  = texture(iRTBuffer1, uv).w;\n  vec3 fragPos    = texture(iRTBuffer2, uv).xyz;\n  vec3 viewPos    = getViewPos();\n  vec3 lightPos    = vec3(0.0, 4.0, 0.0);\n  vec3 lightClr    = vec3(1.0, 0.9, 0.8);\n  vec3 fogColor    = vec3(0.4, 0.4, 0.3);\n  \n  vec3 lightDir = normalize(lightPos - fragPos);\n  float diffuse = max(0.0, dot(fragNormal, lightDir));\n  \n  vec3 viewDir = normalize(viewPos - fragPos);\n  vec3 halfwayDir = normalize(lightDir + viewDir);\n  float specular = max(dot(fragNormal, halfwayDir), 0.0);\n  specular = pow(specular, fragSpec);\n\n  vec3 result = lightClr * (0.7 + diffuse + specular) * fragColor.rgb;\n  \n  FragColor = vec4(result.rgb, 1.0);\n}\n",
                                "defaultProperties": "RenderTargetsNumber = 3\nRenderTarget[0].dataType = DATA_TYPE.UNSIGNED_BYTE\nRenderTarget[0].pixelFormat = PIXEL_FORMAT.RGBA\nRenderTarget[1].dataType = DATA_TYPE.FLOAT\nRenderTarget[1].pixelFormat = PIXEL_FORMAT.RGBA\nRenderTarget[2].dataType = DATA_TYPE.FLOAT\nRenderTarget[2].pixelFormat = PIXEL_FORMAT.RGBA\nDepthTest = TRUE\nDepthWrite = TRUE\nBlending = Blending.NO",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": false,
                                "postProcessCodeEditable": true,
                                "propertiesEditable": true,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":0,\"y\":14,\"z\":22},\"rotation\":{\"x\":0.1,\"y\":0,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":45,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":\"14\",\"model\":null,\"meshes\":[{\"name\":\"main\",\"materialId\":0}],\"colorRGBA\":\"FFFFFF\",\"color\":null},{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":0.6,\"y\":0.6,\"z\":0.6},\"geometry\":\"10\",\"model\":\"Cow.glb\",\"meshes\":[{\"name\":\"Cow_1\",\"materialId\":1},{\"name\":\"Cow_2\",\"materialId\":1},{\"name\":\"Cow_3\",\"materialId\":1},{\"name\":\"Cow_4\",\"materialId\":1},{\"name\":\"Cow_5\",\"materialId\":1},{\"name\":\"Cow_6\",\"materialId\":1},{\"name\":\"Cow_7\",\"materialId\":1}],\"colorRGBA\":\"FFFFFF\",\"color\":null},{\"position\":{\"x\":0,\"y\":0,\"z\":-50},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1000,\"y\":1000,\"z\":1000},\"geometry\":1,\"model\":null,\"meshes\":[{\"name\":\"main\",\"materialId\":2}],\"colorRGBA\":\"506060\",\"color\":5267552},{\"position\":{\"x\":4,\"y\":0,\"z\":-3},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":2.5,\"y\":2.5,\"z\":2.5},\"geometry\":\"10\",\"model\":\"tree-green.glb\",\"meshes\":[{\"name\":\"Tree_1_1\",\"materialId\":1},{\"name\":\"Tree_1_2\",\"materialId\":1}],\"colorRGBA\":\"FFFFFF\",\"color\":null},{\"position\":{\"x\":-5,\"y\":0,\"z\":5},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":4,\"y\":4,\"z\":4},\"geometry\":\"10\",\"model\":\"tree-no-leaves.glb\",\"meshes\":[{\"name\":\"CommonTree_Dead_Snow_3_1\",\"materialId\":1},{\"name\":\"CommonTree_Dead_Snow_3_2\",\"materialId\":1}],\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"materials\":[{\"vertex\":\"uniform mat4 modelMatrix;\\nuniform mat4 viewMatrix;\\nuniform mat4 projectionMatrix;\\n\\nin vec3 position;\\nin vec3 normal;\\nin vec4 color;\\n\\nout vec4 vColor;\\nout vec3 vNormal;\\nout vec3 vPos;\\n\\nvoid main() {\\n  vColor = color;\\n  vNormal = normalize(mat3(transpose(inverse(modelMatrix))) * normal);\\n  vPos = (modelMatrix * vec4(position, 1.0)).xyz;\\n  \\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\\n}\",\"fragment\":\"in vec4 vColor;\\nin vec3 vNormal;\\nin vec3 vPos;\\n\\nlayout(location = 0) out vec4 colorBuffer;\\nlayout(location = 1) out vec4 normalBuffer;\\nlayout(location = 2) out vec4 posBuffer;\\n\\nvoid main() {\\n  colorBuffer = vColor;\\n  normalBuffer = vec4(normalize(vNormal), 1.0);\\n  posBuffer = vec4(vPos.xyz, 1.0);\\n}\\n\",\"properties\":\"DepthTest = TRUE\\nDepthWrite = TRUE\\nBlending = Blending.NO\"},{\"vertex\":\"uniform mat4 modelMatrix;\\nuniform mat4 viewMatrix;\\nuniform mat4 projectionMatrix;\\n\\nin vec3 position;\\nin vec3 normal;\\nin vec4 color;\\n\\nout vec4 vColor;\\nout vec3 vNormal;\\nout vec3 vPos;\\n\\nvoid main() {\\n  vColor = color;\\n  vNormal = normalize(mat3(transpose(inverse(modelMatrix))) * normal);\\n  vPos = (modelMatrix * vec4(position, 1.0)).xyz;\\n  \\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\\n}\",\"fragment\":\"in vec4 vColor;\\nin vec3 vNormal;\\nin vec3 vPos;\\n\\nlayout(location = 0) out vec4 colorBuffer;\\nlayout(location = 1) out vec4 normalBuffer;\\nlayout(location = 2) out vec4 posBuffer;\\n\\nvoid main() {\\n  colorBuffer = vColor;\\n  normalBuffer = vec4(normalize(vNormal) * -1.0, 1.0);\\n  posBuffer = vec4(vPos.x, -1000.0, vPos.z, 1.0);\\n}\\n\",\"properties\":\"\"}],\"actions\":[{\"type\":1,\"time\":4000,\"distance\":{\"x\":0,\"y\":-12,\"z\":-4},\"pivot\":{\"x\":0,\"y\":6,\"z\":0}}],\"backgroundRGBA\":\"506060\",\"background\":5267552,\"customDepthBufferTexture\":false,\"glslVersion\":\"3\"}",
                                "description": "Fog based on fragment and camera height is a technique used in computer graphics to simulate atmospheric effects where the fog density varies with the height of the camera and the fragment being rendered. This method creates a more realistic and immersive environment, especially in scenes with varying terrain elevations.\n\n<br>\n\n### How It Works\n\n<br>\n\nThe fog density is calculated using the heights of both the fragment and the camera:\n\n```\nfogFactor = 1.0 - exp(-density * distanceY * distanceY);\n```\n\nThe greater the height difference between the camera and the object, the denser the fog. The fog factor is then clamped to the range [0.0, 1.0] to ensure it stays within valid bounds.\n\n### Task\nEnhance a scene rendered using deferred shading by adding a camera based height fog effect. The fog density should increase with the height difference between the camera and objects. The fog should become fully opaque at a distance of 10 units from the camera. Use `fogColor` for blending.",
                                "hints": [],
                                "restrictions": [],
                                "order": 13,
                                "cost": 5,
                                "threshold": 99,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [
                                    {
                                        "index": 0
                                    }
                                ],
                                "animated": true,
                                "animationSteps": 20,
                                "animationStepTime": 1000,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": false
                            },
                            "vertexShader": "uniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform float iTime;\nuniform sampler2D iChannel0;\n\nin int index;\nin float side;\n\nout float vH;\nflat out int vI;\nout vec3 vPos;\nout vec3 vNormal;\nout float vX;\n\nvec3 bezier3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    float tt = t * t;\n    float uu = u * u;\n\n    vec3 p = uu * p0;\n    p += 2.0 * u * t * p1;\n    p += tt * p2;\n\n    return p;\n}\n\nvec3 bezierGradient3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    vec3 gradient = 2.0 * u * (p1 - p0) + 2.0 * t * (p2 - p1);\n    return gradient;\n}\n\nfloat random(float x) {\n  float r = fract(sin(x * 12.34) * 1234.5678);\n  return r * 2.0 - 1.0;\n}\n\nfloat noise(vec3 st) {\n  vec2 offset = vec2(st.z, 0.0);\n  return texture(iChannel0, fract(st.xy + offset)).r * 2.0 - 1.0;\n}\n\nvec2 random2(vec2 st){\n  float d1 = dot(st, vec2(12.3, 32.1));\n  float d2 = dot(st, vec2(45.6, 65.4));\n  \n  st = vec2(d1, d2);\n  return fract(sin(st) * 78.9) * 2.0 - 1.0;\n}\n\nmat3 rotationXMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      1.0, 0, 0,\n      0, cosAngle, sinAngle,\n      0, -sinAngle, cosAngle\n    );\n}\n\nmat3 rotationYMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      vec3(cosAngle, 0, -sinAngle),\n      vec3(0, 1, 0),\n      vec3(sinAngle, 0, cosAngle)\n    );\n}\n\nvoid main() {\n  int i = index / 20;\n  int vi = index % 10;\n  \n  float h = float(vi / 2) / 4.0;\n  float xSide = mod(float(vi), 2.0);\n  float zSide = ((index % 20) / 10 == 1) ? 1.0 : -1.0;\n  float hash = random(float(i)) * 0.5 + 0.5;\n  vec2 worldPos = random2(vec2(hash)) * 9.0;\n  mat3 rotateY = rotationYMatrix(random(float(i)) * 3.14);\n\n  float windStength = noise(vec3(worldPos * 0.02, 0.0) + iTime * 0.1) * h * 2.0;\n  mat3  windRot = rotationXMatrix(windStength);\n\n  float leanAnimation = noise(vec3(worldPos, iTime * 0.3));\n  float lean = hash * 0.25 + leanAnimation;\n  \n  vec3 curve = bezier3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.8, 0.0),\n    vec3(0.0, cos(lean), sin(lean)),\n    h\n  );\n\n  vec3 grad = bezierGradient3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.5, 0.0),\n    vec3(0.0, cos(lean), sin(lean)),\n    h\n  );\n  \n  float dx = xSide * 0.14 - 0.07;\n  dx *= mix(1.0, 0.0, pow(h, 3.0));\n  \n  vec3 pos = windRot * rotateY * vec3(dx, curve.y * 1.5, curve.z);\n  pos += vec3(worldPos.x, 0.0, worldPos.y);\n  \n  vPos = pos;\n  vNormal = normalize(windRot * rotateY * zSide * vec3(0.0, grad.z, -grad.y));\n  vH = h;\n  vX = xSide > 0.0 ? 1.0 : -1.0;\n  \n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n",
                            "fragmentShader": "in float vH;\nflat in int vI;\nin vec3 vPos;\nin vec3 vNormal;\nin float vX;\n\nlayout(location = 0) out vec4 colorBuffer;\nlayout(location = 1) out vec4 normalBuffer;\nlayout(location = 2) out vec4 posBuffer;\n\nfloat random(float x) {\n   float r = fract(sin(x * 12.34) * 1234.5678);\n   return r;\n}\n\nvoid main() {\n  float t = random(float(vI)) * 0.5 + 0.5;\n\n  float h = vH * 0.7 + 0.3;\n  vec3 color = mix(vec3(0.4, 0.8, 0.2) * h, vec3(0.8, 0.4, 0.2) * h, t);\n  \n  colorBuffer = vec4(color * (1.0 - abs(vX) * 0.3), 1.0);\n  normalBuffer = vec4(vNormal, 1.0);\n  posBuffer = vec4(vPos.xyz, 1.0);\n}",
                            "postProcessShader": "uniform float iTime;\nuniform vec2 iResolution;\nuniform mat4 inverseViewMatrix;\n\nuniform sampler2D iRTBuffer0;\nuniform sampler2D iRTBuffer1;\nuniform sampler2D iRTBuffer2;\nuniform sampler2D iDepthBuffer;\n\nout vec4 FragColor;\n\nvec3 getViewPos() {\n  return (inverseViewMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz;  \n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  vec4 fragColor  = texture(iRTBuffer0, uv);\n  vec3 fragNormal = normalize(texture(iRTBuffer1, uv).xyz);\n  float fragSpec  = texture(iRTBuffer1, uv).w;\n  vec3 fragPos    = texture(iRTBuffer2, uv).xyz;\n  vec3 viewPos    = getViewPos();\n  vec3 lightPos    = vec3(0.0, 4.0, 0.0);\n  vec3 lightClr    = vec3(1.0, 0.9, 0.8);\n  vec3 fogColor    = vec3(0.4, 0.4, 0.3);\n  \n  vec3 lightDir = normalize(lightPos - fragPos);\n  float diffuse = max(0.0, dot(fragNormal, lightDir));\n  \n  vec3 viewDir = normalize(viewPos - fragPos);\n  vec3 halfwayDir = normalize(lightDir + viewDir);\n  float specular = max(dot(fragNormal, halfwayDir), 0.0);\n  specular = pow(specular, fragSpec);\n\n  vec3 result = lightClr * (0.7 + diffuse + specular) * fragColor.rgb;\n  \n  FragColor = vec4(result.rgb, 1.0);\n}\n",
                            "properties": "RenderTargetsNumber = 3\nRenderTarget[0].dataType = DATA_TYPE.UNSIGNED_BYTE\nRenderTarget[0].pixelFormat = PIXEL_FORMAT.RGBA\nRenderTarget[1].dataType = DATA_TYPE.FLOAT\nRenderTarget[1].pixelFormat = PIXEL_FORMAT.RGBA\nRenderTarget[2].dataType = DATA_TYPE.FLOAT\nRenderTarget[2].pixelFormat = PIXEL_FORMAT.RGBA\nDepthTest = TRUE\nDepthWrite = TRUE\nBlending = Blending.NO",
                            "defaultVertexShader": "uniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform float iTime;\nuniform sampler2D iChannel0;\n\nin int index;\nin float side;\n\nout float vH;\nflat out int vI;\nout vec3 vPos;\nout vec3 vNormal;\nout float vX;\n\nvec3 bezier3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    float tt = t * t;\n    float uu = u * u;\n\n    vec3 p = uu * p0;\n    p += 2.0 * u * t * p1;\n    p += tt * p2;\n\n    return p;\n}\n\nvec3 bezierGradient3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    vec3 gradient = 2.0 * u * (p1 - p0) + 2.0 * t * (p2 - p1);\n    return gradient;\n}\n\nfloat random(float x) {\n  float r = fract(sin(x * 12.34) * 1234.5678);\n  return r * 2.0 - 1.0;\n}\n\nfloat noise(vec3 st) {\n  vec2 offset = vec2(st.z, 0.0);\n  return texture(iChannel0, fract(st.xy + offset)).r * 2.0 - 1.0;\n}\n\nvec2 random2(vec2 st){\n  float d1 = dot(st, vec2(12.3, 32.1));\n  float d2 = dot(st, vec2(45.6, 65.4));\n  \n  st = vec2(d1, d2);\n  return fract(sin(st) * 78.9) * 2.0 - 1.0;\n}\n\nmat3 rotationXMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      1.0, 0, 0,\n      0, cosAngle, sinAngle,\n      0, -sinAngle, cosAngle\n    );\n}\n\nmat3 rotationYMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      vec3(cosAngle, 0, -sinAngle),\n      vec3(0, 1, 0),\n      vec3(sinAngle, 0, cosAngle)\n    );\n}\n\nvoid main() {\n  int i = index / 20;\n  int vi = index % 10;\n  \n  float h = float(vi / 2) / 4.0;\n  float xSide = mod(float(vi), 2.0);\n  float zSide = ((index % 20) / 10 == 1) ? 1.0 : -1.0;\n  float hash = random(float(i)) * 0.5 + 0.5;\n  vec2 worldPos = random2(vec2(hash)) * 9.0;\n  mat3 rotateY = rotationYMatrix(random(float(i)) * 3.14);\n\n  float windStength = noise(vec3(worldPos * 0.02, 0.0) + iTime * 0.1) * h * 2.0;\n  mat3  windRot = rotationXMatrix(windStength);\n\n  float leanAnimation = noise(vec3(worldPos, iTime * 0.3));\n  float lean = hash * 0.25 + leanAnimation;\n  \n  vec3 curve = bezier3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.8, 0.0),\n    vec3(0.0, cos(lean), sin(lean)),\n    h\n  );\n\n  vec3 grad = bezierGradient3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.5, 0.0),\n    vec3(0.0, cos(lean), sin(lean)),\n    h\n  );\n  \n  float dx = xSide * 0.14 - 0.07;\n  dx *= mix(1.0, 0.0, pow(h, 3.0));\n  \n  vec3 pos = windRot * rotateY * vec3(dx, curve.y * 1.5, curve.z);\n  pos += vec3(worldPos.x, 0.0, worldPos.y);\n  \n  vPos = pos;\n  vNormal = normalize(windRot * rotateY * zSide * vec3(0.0, grad.z, -grad.y));\n  vH = h;\n  vX = xSide > 0.0 ? 1.0 : -1.0;\n  \n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n",
                            "defaultFragmentShader": "in float vH;\nflat in int vI;\nin vec3 vPos;\nin vec3 vNormal;\nin float vX;\n\nlayout(location = 0) out vec4 colorBuffer;\nlayout(location = 1) out vec4 normalBuffer;\nlayout(location = 2) out vec4 posBuffer;\n\nfloat random(float x) {\n   float r = fract(sin(x * 12.34) * 1234.5678);\n   return r;\n}\n\nvoid main() {\n  float t = random(float(vI)) * 0.5 + 0.5;\n\n  float h = vH * 0.7 + 0.3;\n  vec3 color = mix(vec3(0.4, 0.8, 0.2) * h, vec3(0.8, 0.4, 0.2) * h, t);\n  \n  colorBuffer = vec4(color * (1.0 - abs(vX) * 0.3), 1.0);\n  normalBuffer = vec4(vNormal, 1.0);\n  posBuffer = vec4(vPos.xyz, 1.0);\n}",
                            "defaultPostProcessShader": "uniform float iTime;\nuniform vec2 iResolution;\nuniform mat4 inverseViewMatrix;\n\nuniform sampler2D iRTBuffer0;\nuniform sampler2D iRTBuffer1;\nuniform sampler2D iRTBuffer2;\nuniform sampler2D iDepthBuffer;\n\nout vec4 FragColor;\n\nvec3 getViewPos() {\n  return (inverseViewMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz;  \n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  vec4 fragColor  = texture(iRTBuffer0, uv);\n  vec3 fragNormal = normalize(texture(iRTBuffer1, uv).xyz);\n  float fragSpec  = texture(iRTBuffer1, uv).w;\n  vec3 fragPos    = texture(iRTBuffer2, uv).xyz;\n  vec3 viewPos    = getViewPos();\n  vec3 lightPos    = vec3(0.0, 4.0, 0.0);\n  vec3 lightClr    = vec3(1.0, 0.9, 0.8);\n  vec3 fogColor    = vec3(0.4, 0.4, 0.3);\n  \n  vec3 lightDir = normalize(lightPos - fragPos);\n  float diffuse = max(0.0, dot(fragNormal, lightDir));\n  \n  vec3 viewDir = normalize(viewPos - fragPos);\n  vec3 halfwayDir = normalize(lightDir + viewDir);\n  float specular = max(dot(fragNormal, halfwayDir), 0.0);\n  specular = pow(specular, fragSpec);\n\n  vec3 result = lightClr * (0.7 + diffuse + specular) * fragColor.rgb;\n  \n  FragColor = vec4(result.rgb, 1.0);\n}\n",
                            "defaultProperties": "RenderTargetsNumber = 3\nRenderTarget[0].dataType = DATA_TYPE.UNSIGNED_BYTE\nRenderTarget[0].pixelFormat = PIXEL_FORMAT.RGBA\nRenderTarget[1].dataType = DATA_TYPE.FLOAT\nRenderTarget[1].pixelFormat = PIXEL_FORMAT.RGBA\nRenderTarget[2].dataType = DATA_TYPE.FLOAT\nRenderTarget[2].pixelFormat = PIXEL_FORMAT.RGBA\nDepthTest = TRUE\nDepthWrite = TRUE\nBlending = Blending.NO",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 192,
                        "slug": "screen-space-reflections",
                        "moduleId": 11,
                        "name": "Screen Space Reflections",
                        "order": 14,
                        "cost": 10,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 192,
                                "slug": "screen-space-reflections",
                                "moduleId": 11,
                                "name": "Screen Space Reflections",
                                "vertexShader": "uniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\nin int id;\nin vec3 position;\nin vec3 normal;\nin vec4 color;\n\nflat out int vId;\nout vec4 vColor;\nout vec3 vNormal;\nout vec3 vPos;\n\nvoid main() {\n  vId = id;\n  vPos = (viewMatrix * modelMatrix * vec4(position, 1.0)).xyz;\n  vColor = color;\n  vNormal = normalize(mat3(transpose(inverse(viewMatrix * modelMatrix))) * normal);\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}",
                                "fragmentShader": "flat in int vId;\nin vec4 vColor;\nin vec3 vNormal;\nin vec3 vPos;\n\nlayout(location = 0) out vec4 colorBuffer;\nlayout(location = 1) out vec4 normalBuffer;\n\nvoid main() {\n  vec3 lightColor = vec3(1.0, 1.0, 0.75);\n  vec3 lightPos = vec3(1.0, 3.0, 2.0);\n  vec3 lightDir = normalize(lightPos - vPos);\n  \n  float ambient = 0.2;\n  float diffuse = dot(vNormal, lightDir);\n  \n  colorBuffer = vec4(lightColor * (ambient + diffuse), 1.0) * vColor;\n  normalBuffer = vec4(vNormal, vId > 0 ? 0.0 : 1.0);\n}\n",
                                "postProcessShader": "uniform vec2 iResolution;\nuniform mat4 projectionMatrix;\nuniform mat4 inverseProjectionMatrix;\nuniform mat4 inverseViewMatrix;\nuniform sampler2D iRTBuffer0;\nuniform sampler2D iRTBuffer1;\nuniform sampler2D iDepthBuffer;\n\nout vec4 FragColor;\n\nvec3 getViewPosition(vec2 uv, float depth) {\n  vec4 position = vec4(1.0); \n  position.x = uv.x * 2.0 - 1.0; \n  position.y = uv.y * 2.0 - 1.0; \n  position.z = depth * 2.0 - 1.0; \n  position = inverseProjectionMatrix * position; \n  position /= position.w;\n  return position.xyz;\n}\n\nvec3 getUV(vec3 viewPos) {\n  vec4 pos = projectionMatrix * vec4(viewPos, 1.0f);\n  return pos.xyz / pos.w * 0.5 + 0.5;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  float depth = texture(iDepthBuffer, uv).r;\n  vec3 pos = getViewPosition(uv, depth);\n  vec3 normal = normalize(texture(iRTBuffer1, uv).xyz);\n\n  vec3 viewDir = normalize(pos);\n  vec3 reflectDir = normalize(reflect(viewDir, normal));\n  vec4 reflection = vec4(0.0);\n\n  float L = 0.0;\n  pos += normal * 0.1;\n  \n  for(int i = 0; i < 100; i++) {\n    vec3 nextPos = pos + reflectDir * (0.01 * float(i));\n    vec3 nextUV = getUV(nextPos);\n    float sampleDepth = texture(iDepthBuffer, nextUV.xy).r;\n\n    //Terminate testing points that are out of the screen space\n    if (nextUV.x < 0.0 || nextUV.x > 1.0 || nextUV.y < 0.0 || nextUV.y > 1.0) {\n      reflection = texture(iRTBuffer0, uv);\n      break;\n    }\n\n    //If the testing point is below the surface and not too much below\n    if (abs(sampleDepth - nextUV.z) < 0.001) {\n\n      //Terminate intersections that are out of range\n      if (nextUV.z < 0.0 || nextUV.z > 1.0) {\n        reflection = texture(iRTBuffer0, uv);\n        break;\n      }\n      \n      //Simply return scene color of the intersection point.\n      reflection = texture(iRTBuffer0, nextUV.xy);\n      L = 1.0 - distance(pos, nextPos);\n      L = clamp(L, 0.0, 1.0);\n      break;\n    }\n  }\n\n  float fresnel = 1.0 - max(0.0, normal.z);\n  float reflectStrength = step(0.1, texture(iRTBuffer1, uv).w);\n\n  FragColor = mix(texture(iRTBuffer0, uv), reflection, fresnel * L * reflectStrength);\n}\n",
                                "properties": "RenderTargetsNumber = 2\nRenderTarget[0].dataType = DATA_TYPE.UNSIGNED_BYTE\nRenderTarget[0].pixelFormat = PIXEL_FORMAT.RGBA\nRenderTarget[1].dataType = DATA_TYPE.FLOAT\nRenderTarget[1].pixelFormat = PIXEL_FORMAT.RGBA\nDepthTest = TRUE\nDepthWrite = TRUE\nBlending = Blending.NO",
                                "defaultVertexShader": "uniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\nin int id;\nin vec3 position;\nin vec3 normal;\nin vec4 color;\n\nflat out int vId;\nout vec4 vColor;\nout vec3 vNormal;\nout vec3 vPos;\n\nvoid main() {\n  vId = id;\n  vPos = (viewMatrix * modelMatrix * vec4(position, 1.0)).xyz;\n  vColor = color;\n  vNormal = normalize(mat3(transpose(inverse(viewMatrix * modelMatrix))) * normal);\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}",
                                "defaultFragmentShader": "flat in int vId;\nin vec4 vColor;\nin vec3 vNormal;\nin vec3 vPos;\n\nlayout(location = 0) out vec4 colorBuffer;\nlayout(location = 1) out vec4 normalBuffer;\n\nvoid main() {\n  vec3 lightColor = vec3(1.0, 1.0, 0.75);\n  vec3 lightPos = vec3(1.0, 3.0, 2.0);\n  vec3 lightDir = normalize(lightPos - vPos);\n  \n  float ambient = 0.2;\n  float diffuse = dot(vNormal, lightDir);\n  \n  colorBuffer = vec4(lightColor * (ambient + diffuse), 1.0) * vColor;\n  normalBuffer = vec4(vNormal, vId > 0 ? 0.0 : 1.0);\n}\n",
                                "defaultPostProcessShader": "uniform vec2 iResolution;\nuniform mat4 projectionMatrix;\nuniform mat4 inverseProjectionMatrix;\nuniform mat4 inverseViewMatrix;\nuniform sampler2D iRTBuffer0;\nuniform sampler2D iRTBuffer1;\nuniform sampler2D iDepthBuffer;\n\nout vec4 FragColor;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  float depth = texture(iDepthBuffer, uv).r;\n  vec3 normal = normalize(texture(iRTBuffer1, uv).xyz);\n\n  FragColor = texture(iRTBuffer0, uv);\n}\n",
                                "defaultProperties": "RenderTargetsNumber = 2\nRenderTarget[0].dataType = DATA_TYPE.UNSIGNED_BYTE\nRenderTarget[0].pixelFormat = PIXEL_FORMAT.RGBA\nRenderTarget[1].dataType = DATA_TYPE.FLOAT\nRenderTarget[1].pixelFormat = PIXEL_FORMAT.RGBA\nDepthTest = TRUE\nDepthWrite = TRUE",
                                "vertexCodeEditable": true,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": true,
                                "propertiesEditable": true,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":0,\"y\":0.5,\"z\":1.5},\"rotation\":{\"x\":-0.25,\"y\":0,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":45,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":-1.57,\"y\":0,\"z\":0},\"scale\":{\"x\":50,\"y\":50,\"z\":1},\"geometry\":1,\"model\":null,\"meshes\":[{\"name\":\"main\",\"materialId\":0}],\"colorRGBA\":\"222222\",\"color\":2236962},{\"position\":{\"x\":0,\"y\":-0.01,\"z\":0},\"rotation\":{\"x\":0,\"y\":1.57,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":\"10\",\"model\":\"Candle.glb\",\"meshes\":[{\"name\":\"Candle\",\"materialId\":0},{\"name\":\"Flame\",\"materialId\":0},{\"name\":\"Rope\",\"materialId\":0}],\"colorRGBA\":\"FFFFFF\",\"color\":null},{\"position\":{\"x\":1,\"y\":0.4,\"z\":-0.5},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":0.5,\"y\":0.5,\"z\":0.5},\"geometry\":\"3\",\"model\":null,\"meshes\":[{\"name\":\"main\",\"materialId\":0}],\"colorRGBA\":\"3030EE\",\"color\":3158254},{\"position\":{\"x\":-0.9,\"y\":0,\"z\":-0.7},\"rotation\":{\"x\":0,\"y\":-0.4,\"z\":0},\"scale\":{\"x\":0.2,\"y\":1.2,\"z\":1},\"geometry\":\"2\",\"model\":null,\"meshes\":[{\"name\":\"main\",\"materialId\":0}],\"colorRGBA\":\"EE3030\",\"color\":15609904}],\"materials\":[],\"actions\":[],\"backgroundRGBA\":\"8888CC\",\"background\":8947916,\"customDepthBufferTexture\":false,\"glslVersion\":\"3\"}",
                                "description": "TBD\n\n### Task\n\nTBD",
                                "hints": [],
                                "restrictions": [],
                                "order": 14,
                                "cost": 10,
                                "threshold": 99,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "uniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\nin int id;\nin vec3 position;\nin vec3 normal;\nin vec4 color;\n\nflat out int vId;\nout vec4 vColor;\nout vec3 vNormal;\nout vec3 vPos;\n\nvoid main() {\n  vId = id;\n  vPos = (viewMatrix * modelMatrix * vec4(position, 1.0)).xyz;\n  vColor = color;\n  vNormal = normalize(mat3(transpose(inverse(viewMatrix * modelMatrix))) * normal);\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}",
                            "fragmentShader": "flat in int vId;\nin vec4 vColor;\nin vec3 vNormal;\nin vec3 vPos;\n\nlayout(location = 0) out vec4 colorBuffer;\nlayout(location = 1) out vec4 normalBuffer;\n\nvoid main() {\n  vec3 lightColor = vec3(1.0, 1.0, 0.75);\n  vec3 lightPos = vec3(1.0, 3.0, 2.0);\n  vec3 lightDir = normalize(lightPos - vPos);\n  \n  float ambient = 0.2;\n  float diffuse = dot(vNormal, lightDir);\n  \n  colorBuffer = vec4(lightColor * (ambient + diffuse), 1.0) * vColor;\n  normalBuffer = vec4(vNormal, vId > 0 ? 0.0 : 1.0);\n}\n",
                            "postProcessShader": "uniform vec2 iResolution;\nuniform mat4 projectionMatrix;\nuniform mat4 inverseProjectionMatrix;\nuniform mat4 inverseViewMatrix;\nuniform sampler2D iRTBuffer0;\nuniform sampler2D iRTBuffer1;\nuniform sampler2D iDepthBuffer;\n\nout vec4 FragColor;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  float depth = texture(iDepthBuffer, uv).r;\n  vec3 normal = normalize(texture(iRTBuffer1, uv).xyz);\n\n  FragColor = texture(iRTBuffer0, uv);\n}\n",
                            "properties": "RenderTargetsNumber = 2\nRenderTarget[0].dataType = DATA_TYPE.UNSIGNED_BYTE\nRenderTarget[0].pixelFormat = PIXEL_FORMAT.RGBA\nRenderTarget[1].dataType = DATA_TYPE.FLOAT\nRenderTarget[1].pixelFormat = PIXEL_FORMAT.RGBA\nDepthTest = TRUE\nDepthWrite = TRUE",
                            "defaultVertexShader": "uniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\nin int id;\nin vec3 position;\nin vec3 normal;\nin vec4 color;\n\nflat out int vId;\nout vec4 vColor;\nout vec3 vNormal;\nout vec3 vPos;\n\nvoid main() {\n  vId = id;\n  vPos = (viewMatrix * modelMatrix * vec4(position, 1.0)).xyz;\n  vColor = color;\n  vNormal = normalize(mat3(transpose(inverse(viewMatrix * modelMatrix))) * normal);\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}",
                            "defaultFragmentShader": "flat in int vId;\nin vec4 vColor;\nin vec3 vNormal;\nin vec3 vPos;\n\nlayout(location = 0) out vec4 colorBuffer;\nlayout(location = 1) out vec4 normalBuffer;\n\nvoid main() {\n  vec3 lightColor = vec3(1.0, 1.0, 0.75);\n  vec3 lightPos = vec3(1.0, 3.0, 2.0);\n  vec3 lightDir = normalize(lightPos - vPos);\n  \n  float ambient = 0.2;\n  float diffuse = dot(vNormal, lightDir);\n  \n  colorBuffer = vec4(lightColor * (ambient + diffuse), 1.0) * vColor;\n  normalBuffer = vec4(vNormal, vId > 0 ? 0.0 : 1.0);\n}\n",
                            "defaultPostProcessShader": "uniform vec2 iResolution;\nuniform mat4 projectionMatrix;\nuniform mat4 inverseProjectionMatrix;\nuniform mat4 inverseViewMatrix;\nuniform sampler2D iRTBuffer0;\nuniform sampler2D iRTBuffer1;\nuniform sampler2D iDepthBuffer;\n\nout vec4 FragColor;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  float depth = texture(iDepthBuffer, uv).r;\n  vec3 normal = normalize(texture(iRTBuffer1, uv).xyz);\n\n  FragColor = texture(iRTBuffer0, uv);\n}\n",
                            "defaultProperties": "RenderTargetsNumber = 2\nRenderTarget[0].dataType = DATA_TYPE.UNSIGNED_BYTE\nRenderTarget[0].pixelFormat = PIXEL_FORMAT.RGBA\nRenderTarget[1].dataType = DATA_TYPE.FLOAT\nRenderTarget[1].pixelFormat = PIXEL_FORMAT.RGBA\nDepthTest = TRUE\nDepthWrite = TRUE",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 193,
                        "slug": "ssao",
                        "moduleId": 11,
                        "name": "SSAO",
                        "order": 15,
                        "cost": 10,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": 0,
                        "premium": false,
                        "child": {
                            "task": {
                                "id": 193,
                                "slug": "ssao",
                                "moduleId": 11,
                                "name": "SSAO",
                                "vertexShader": "uniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\nin int id;\nin vec3 position;\nin vec3 normal;\nin vec4 color;\n\nflat out int vId;\nout vec4 vColor;\nout vec3 vNormal;\nout vec3 vPos;\n\nvoid main() {\n  vId = id;\n  vColor = color;\n  vNormal = normalize(mat3(transpose(inverse(viewMatrix * modelMatrix))) * normal);\n  vPos = (viewMatrix * modelMatrix * vec4(position, 1.0)).xyz;\n  \n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}",
                                "fragmentShader": "flat in int vId;\nin vec4 vColor;\nin vec3 vNormal;\nin vec3 vPos;\n\nlayout(location = 0) out vec4 colorBuffer;\nlayout(location = 1) out vec4 normalBuffer;\nlayout(location = 2) out vec4 posBuffer;\n\nvoid main() {\n  colorBuffer = vColor;\n  normalBuffer = vec4(normalize(vNormal), pow(4.0, 1.0 + mod(float(vId), 3.0)));\n  posBuffer = vec4(vPos.xyz, 1.0);\n}\n",
                                "postProcessShader": "uniform vec2 iResolution;\nuniform mat4 inverseViewMatrix;\nuniform mat4 projectionMatrix;\n\nuniform sampler2D iRTBuffer0;   // color\nuniform sampler2D iRTBuffer1;   // normal + specular\nuniform sampler2D iRTBuffer2;   // position\nuniform sampler2D iDepthBuffer; // depth\n\nout vec4 FragColor;\n\nfloat random(vec2 point) {\n  const float SEED = 1234.5678;\n  float d = dot(point, vec2(SEED, SEED));\n  float r = fract(sin(d) * SEED);\n  r = r * 2.0 - 1.0; \n  return r;\n}\n\nfloat random01(vec2 point) {\n  return random(point) * 0.5 + 0.5;\n}\n\nvec3 randomVec(vec3 normal) {\n  vec3 v = vec3(random(normal.xy), random(normal.yz), random(normal.zx));\n  return normalize(v);\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  vec3 fragPos    = texture(iRTBuffer2, uv).xyz;\n  vec3 fragNormal = normalize(texture(iRTBuffer1, uv).xyz);\n  float fragDepth = texture(iDepthBuffer, uv).x;\n  vec4 fragColor  = texture(iRTBuffer0, uv);\n\n  float occlusion = 0.0;\n  int kernelSize = 64;\n  float radius = 0.2;\n  float bias = 0.025;\n  for(int i = 0; i < kernelSize; i++) {\n      float scale = float(i) / 64.0;\n      scale = mix(0.1f, 1.0f, scale * scale);\n    \n      vec3 offset = fragNormal + 0.5 * randomVec(fragNormal + float(1 + i));\n      vec3 s = fragPos + offset * radius * scale; \n\n      vec4 sp = vec4(s, 1.0);\n      sp = projectionMatrix * sp;   // переход из видового  клиповое\n      sp.xyz /= sp.w;               // перспективное деление \n      sp.xyz  = sp.xyz * 0.5 + 0.5; // преобразование к интервалу [0., 1.] \n\n      float sDepth = texture(iRTBuffer2, sp.xy).z; \n\n      float rangeCheck = smoothstep(0.0, 1.0, radius / abs(fragPos.z - sDepth));\n      occlusion += (sDepth >= s.z + bias ? 1.0 : 0.0) * rangeCheck; \n  }  \n  occlusion = 1.0 - (occlusion / float(kernelSize)); \n  \n  FragColor = vec4(vec3(occlusion), 1.0);\n}\n",
                                "properties": "RenderTargetsNumber = 3\nRenderTarget[0].dataType = DATA_TYPE.UNSIGNED_BYTE\nRenderTarget[0].pixelFormat = PIXEL_FORMAT.RGBA\nRenderTarget[1].dataType = DATA_TYPE.FLOAT\nRenderTarget[1].pixelFormat = PIXEL_FORMAT.RGBA\nRenderTarget[2].dataType = DATA_TYPE.FLOAT\nRenderTarget[2].pixelFormat = PIXEL_FORMAT.RGBA\nDepthTest = TRUE\nDepthWrite = TRUE\nBlending = Blending.NO",
                                "defaultVertexShader": "uniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\nin int id;\nin vec3 position;\nin vec3 normal;\nin vec4 color;\n\nflat out int vId;\nout vec4 vColor;\nout vec3 vNormal;\nout vec3 vPos;\n\nvoid main() {\n  vId = id;\n  vColor = color;\n  vNormal = normalize(mat3(transpose(inverse(viewMatrix * modelMatrix))) * normal);\n  vPos = (viewMatrix * modelMatrix * vec4(position, 1.0)).xyz;\n  \n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}",
                                "defaultFragmentShader": "flat in int vId;\nin vec4 vColor;\nin vec3 vNormal;\nin vec3 vPos;\n\nlayout(location = 0) out vec4 colorBuffer;\nlayout(location = 1) out vec4 normalBuffer;\nlayout(location = 2) out vec4 posBuffer;\n\nvoid main() {\n  colorBuffer = vColor;\n  normalBuffer = vec4(normalize(vNormal), pow(4.0, 1.0 + mod(float(vId), 3.0)));\n  posBuffer = vec4(vPos.xyz, 1.0);\n}\n",
                                "defaultPostProcessShader": "uniform vec2 iResolution;\nuniform mat4 inverseViewMatrix;\nuniform mat4 projectionMatrix;\n\nuniform sampler2D iRTBuffer0;   // color\nuniform sampler2D iRTBuffer1;   // normal + specular\nuniform sampler2D iRTBuffer2;   // position\nuniform sampler2D iDepthBuffer; // depth\n\nout vec4 FragColor;\n\nfloat random(vec2 point) {\n  const float SEED = 1234.5678;\n  float d = dot(point, vec2(SEED, SEED));\n  float r = fract(sin(d) * SEED);\n  r = r * 2.0 - 1.0; \n  return r;\n}\n\nfloat random01(vec2 point) {\n  return random(point) * 0.5 + 0.5;\n}\n\nvec3 randomVec(vec3 normal) {\n  vec3 v = vec3(random(normal.xy), random(normal.yz), random(normal.zx));\n  return normalize(v);\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  vec4 fragColor  = texture(iRTBuffer0, uv);\n  vec3 fragNormal = normalize(texture(iRTBuffer1, uv).xyz);\n  float fragSpec  = texture(iRTBuffer1, uv).w;\n  vec3 fragPos    = texture(iRTBuffer2, uv).xyz;\n  \n  FragColor = vec4(fragColor.rgb, 1.0);\n}\n",
                                "defaultProperties": "RenderTargetsNumber = 3\nRenderTarget[0].dataType = DATA_TYPE.UNSIGNED_BYTE\nRenderTarget[0].pixelFormat = PIXEL_FORMAT.RGBA\nRenderTarget[1].dataType = DATA_TYPE.FLOAT\nRenderTarget[1].pixelFormat = PIXEL_FORMAT.RGBA\nRenderTarget[2].dataType = DATA_TYPE.FLOAT\nRenderTarget[2].pixelFormat = PIXEL_FORMAT.RGBA\nDepthTest = TRUE\nDepthWrite = TRUE\nBlending = Blending.NO",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": false,
                                "postProcessCodeEditable": true,
                                "propertiesEditable": true,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":0,\"y\":10,\"z\":8},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":45,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":3,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":2,\"y\":2,\"z\":2},\"geometry\":\"2\",\"model\":null,\"meshes\":[{\"name\":\"main\",\"materialId\":0}],\"colorRGBA\":\"FFFFFF\",\"color\":null},{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":2,\"y\":2,\"z\":2},\"geometry\":\"2\",\"model\":null,\"meshes\":[{\"name\":\"main\",\"materialId\":0}],\"colorRGBA\":\"FFFFFF\",\"color\":null},{\"position\":{\"x\":-3,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":2,\"y\":2,\"z\":2},\"geometry\":\"2\",\"model\":null,\"meshes\":[{\"name\":\"main\",\"materialId\":0}],\"colorRGBA\":\"FFFFFF\",\"color\":null},{\"position\":{\"x\":3,\"y\":0,\"z\":3},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":2,\"y\":2,\"z\":2},\"geometry\":\"3\",\"model\":null,\"meshes\":[{\"name\":\"main\",\"materialId\":0}],\"colorRGBA\":\"FFFFFF\",\"color\":null},{\"position\":{\"x\":0,\"y\":0,\"z\":3},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":2,\"y\":2,\"z\":2},\"geometry\":\"3\",\"model\":null,\"meshes\":[{\"name\":\"main\",\"materialId\":0}],\"colorRGBA\":\"FFFFFF\",\"color\":null},{\"position\":{\"x\":-3,\"y\":0,\"z\":3},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":2,\"y\":2,\"z\":2},\"geometry\":\"3\",\"model\":null,\"meshes\":[{\"name\":\"main\",\"materialId\":0}],\"colorRGBA\":\"FFFFFF\",\"color\":null},{\"position\":{\"x\":3,\"y\":0,\"z\":-3},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":2,\"y\":2,\"z\":2},\"geometry\":\"3\",\"model\":null,\"meshes\":[{\"name\":\"main\",\"materialId\":0}],\"colorRGBA\":\"FFFFFF\",\"color\":null},{\"position\":{\"x\":0,\"y\":0,\"z\":-3},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":2,\"y\":2,\"z\":2},\"geometry\":\"3\",\"model\":null,\"meshes\":[{\"name\":\"main\",\"materialId\":0}],\"colorRGBA\":\"FFFFFF\",\"color\":null},{\"position\":{\"x\":-3,\"y\":0,\"z\":-3},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":2,\"y\":2,\"z\":2},\"geometry\":\"3\",\"model\":null,\"meshes\":[{\"name\":\"main\",\"materialId\":0}],\"colorRGBA\":\"FFFFFF\",\"color\":null},{\"position\":{\"x\":0,\"y\":-1,\"z\":0},\"rotation\":{\"x\":-1.57,\"y\":0,\"z\":0},\"scale\":{\"x\":20,\"y\":20,\"z\":1},\"geometry\":1,\"model\":null,\"meshes\":[{\"name\":\"main\",\"materialId\":0}],\"colorRGBA\":\"BBBBBB\",\"color\":12303291},{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":\"10\",\"model\":\"Cow.glb\",\"meshes\":[{\"name\":\"Cow_1\",\"materialId\":0},{\"name\":\"Cow_2\",\"materialId\":0},{\"name\":\"Cow_3\",\"materialId\":0},{\"name\":\"Cow_4\",\"materialId\":0},{\"name\":\"Cow_5\",\"materialId\":0},{\"name\":\"Cow_6\",\"materialId\":0},{\"name\":\"Cow_7\",\"materialId\":0}],\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"materials\":[],\"actions\":[{\"type\":0,\"speed\":1,\"pivot\":{\"x\":0,\"y\":-1,\"z\":0}}],\"backgroundRGBA\":\"111111\",\"background\":1118481,\"customDepthBufferTexture\":false,\"glslVersion\":\"3\"}",
                                "description": "TBD\n\n### Task\n\nTBD",
                                "hints": [],
                                "restrictions": [],
                                "order": 15,
                                "cost": 10,
                                "threshold": 99,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": true,
                                "animationSteps": 10,
                                "animationStepTime": 200,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": false
                            },
                            "vertexShader": "uniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\nin int id;\nin vec3 position;\nin vec3 normal;\nin vec4 color;\n\nflat out int vId;\nout vec4 vColor;\nout vec3 vNormal;\nout vec3 vPos;\n\nvoid main() {\n  vId = id;\n  vColor = color;\n  vNormal = normalize(mat3(transpose(inverse(viewMatrix * modelMatrix))) * normal);\n  vPos = (viewMatrix * modelMatrix * vec4(position, 1.0)).xyz;\n  \n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}",
                            "fragmentShader": "flat in int vId;\nin vec4 vColor;\nin vec3 vNormal;\nin vec3 vPos;\n\nlayout(location = 0) out vec4 colorBuffer;\nlayout(location = 1) out vec4 normalBuffer;\nlayout(location = 2) out vec4 posBuffer;\n\nvoid main() {\n  colorBuffer = vColor;\n  normalBuffer = vec4(normalize(vNormal), pow(4.0, 1.0 + mod(float(vId), 3.0)));\n  posBuffer = vec4(vPos.xyz, 1.0);\n}\n",
                            "postProcessShader": "uniform vec2 iResolution;\nuniform mat4 inverseViewMatrix;\nuniform mat4 projectionMatrix;\n\nuniform sampler2D iRTBuffer0;   // color\nuniform sampler2D iRTBuffer1;   // normal + specular\nuniform sampler2D iRTBuffer2;   // position\nuniform sampler2D iDepthBuffer; // depth\n\nout vec4 FragColor;\n\nfloat random(vec2 point) {\n  const float SEED = 1234.5678;\n  float d = dot(point, vec2(SEED, SEED));\n  float r = fract(sin(d) * SEED);\n  r = r * 2.0 - 1.0; \n  return r;\n}\n\nfloat random01(vec2 point) {\n  return random(point) * 0.5 + 0.5;\n}\n\nvec3 randomVec(vec3 normal) {\n  vec3 v = vec3(random(normal.xy), random(normal.yz), random(normal.zx));\n  return normalize(v);\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  vec4 fragColor  = texture(iRTBuffer0, uv);\n  vec3 fragNormal = normalize(texture(iRTBuffer1, uv).xyz);\n  float fragSpec  = texture(iRTBuffer1, uv).w;\n  vec3 fragPos    = texture(iRTBuffer2, uv).xyz;\n  \n  FragColor = vec4(fragColor.rgb, 1.0);\n}\n",
                            "properties": "RenderTargetsNumber = 3\nRenderTarget[0].dataType = DATA_TYPE.UNSIGNED_BYTE\nRenderTarget[0].pixelFormat = PIXEL_FORMAT.RGBA\nRenderTarget[1].dataType = DATA_TYPE.FLOAT\nRenderTarget[1].pixelFormat = PIXEL_FORMAT.RGBA\nRenderTarget[2].dataType = DATA_TYPE.FLOAT\nRenderTarget[2].pixelFormat = PIXEL_FORMAT.RGBA\nDepthTest = TRUE\nDepthWrite = TRUE\nBlending = Blending.NO",
                            "defaultVertexShader": "uniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\nin int id;\nin vec3 position;\nin vec3 normal;\nin vec4 color;\n\nflat out int vId;\nout vec4 vColor;\nout vec3 vNormal;\nout vec3 vPos;\n\nvoid main() {\n  vId = id;\n  vColor = color;\n  vNormal = normalize(mat3(transpose(inverse(viewMatrix * modelMatrix))) * normal);\n  vPos = (viewMatrix * modelMatrix * vec4(position, 1.0)).xyz;\n  \n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}",
                            "defaultFragmentShader": "flat in int vId;\nin vec4 vColor;\nin vec3 vNormal;\nin vec3 vPos;\n\nlayout(location = 0) out vec4 colorBuffer;\nlayout(location = 1) out vec4 normalBuffer;\nlayout(location = 2) out vec4 posBuffer;\n\nvoid main() {\n  colorBuffer = vColor;\n  normalBuffer = vec4(normalize(vNormal), pow(4.0, 1.0 + mod(float(vId), 3.0)));\n  posBuffer = vec4(vPos.xyz, 1.0);\n}\n",
                            "defaultPostProcessShader": "uniform vec2 iResolution;\nuniform mat4 inverseViewMatrix;\nuniform mat4 projectionMatrix;\n\nuniform sampler2D iRTBuffer0;   // color\nuniform sampler2D iRTBuffer1;   // normal + specular\nuniform sampler2D iRTBuffer2;   // position\nuniform sampler2D iDepthBuffer; // depth\n\nout vec4 FragColor;\n\nfloat random(vec2 point) {\n  const float SEED = 1234.5678;\n  float d = dot(point, vec2(SEED, SEED));\n  float r = fract(sin(d) * SEED);\n  r = r * 2.0 - 1.0; \n  return r;\n}\n\nfloat random01(vec2 point) {\n  return random(point) * 0.5 + 0.5;\n}\n\nvec3 randomVec(vec3 normal) {\n  vec3 v = vec3(random(normal.xy), random(normal.yz), random(normal.zx));\n  return normalize(v);\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  vec4 fragColor  = texture(iRTBuffer0, uv);\n  vec3 fragNormal = normalize(texture(iRTBuffer1, uv).xyz);\n  float fragSpec  = texture(iRTBuffer1, uv).w;\n  vec3 fragPos    = texture(iRTBuffer2, uv).xyz;\n  \n  FragColor = vec4(fragColor.rgb, 1.0);\n}\n",
                            "defaultProperties": "RenderTargetsNumber = 3\nRenderTarget[0].dataType = DATA_TYPE.UNSIGNED_BYTE\nRenderTarget[0].pixelFormat = PIXEL_FORMAT.RGBA\nRenderTarget[1].dataType = DATA_TYPE.FLOAT\nRenderTarget[1].pixelFormat = PIXEL_FORMAT.RGBA\nRenderTarget[2].dataType = DATA_TYPE.FLOAT\nRenderTarget[2].pixelFormat = PIXEL_FORMAT.RGBA\nDepthTest = TRUE\nDepthWrite = TRUE\nBlending = Blending.NO",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 201,
                        "slug": "depth-of-field",
                        "moduleId": 11,
                        "name": "Depth of Field",
                        "order": 17,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": 0,
                        "premium": false,
                        "child": {
                            "task": {
                                "id": 201,
                                "slug": "depth-of-field",
                                "moduleId": 11,
                                "name": "Depth of Field",
                                "vertexShader": "uniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform float iTime;\nuniform sampler2D iChannel0;\n\nin int index;\nin float side;\n\nout float vH;\nflat out int vI;\nout vec3 vPos;\nout vec3 vNormal;\nout float vX;\n\nvec3 bezier3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    float tt = t * t;\n    float uu = u * u;\n\n    vec3 p = uu * p0;\n    p += 2.0 * u * t * p1;\n    p += tt * p2;\n\n    return p;\n}\n\nvec3 bezierGradient3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    vec3 gradient = 2.0 * u * (p1 - p0) + 2.0 * t * (p2 - p1);\n    return gradient;\n}\n\nfloat random(float x) {\n  float r = fract(sin(x * 12.34) * 1234.5678);\n  return r * 2.0 - 1.0;\n}\n\nfloat noise(vec3 st) {\n  vec2 offset = vec2(st.z, 0.0);\n  return texture(iChannel0, fract(st.xy + offset)).r * 2.0 - 1.0;\n}\n\nvec2 random2(vec2 st){\n  float d1 = dot(st, vec2(12.3, 32.1));\n  float d2 = dot(st, vec2(45.6, 65.4));\n  \n  st = vec2(d1, d2);\n  return fract(sin(st) * 78.9) * 2.0 - 1.0;\n}\n\nmat3 rotationXMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      1.0, 0, 0,\n      0, cosAngle, sinAngle,\n      0, -sinAngle, cosAngle\n    );\n}\n\nmat3 rotationYMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      vec3(cosAngle, 0, -sinAngle),\n      vec3(0, 1, 0),\n      vec3(sinAngle, 0, cosAngle)\n    );\n}\n\nvoid main() {\n  int i = index / 20;\n  int vi = index % 10;\n  \n  float h = float(vi / 2) / 4.0;\n  float xSide = mod(float(vi), 2.0);\n  float zSide = ((index % 20) / 10 == 1) ? 1.0 : -1.0;\n  float hash = random(float(i)) * 0.5 + 0.5;\n  vec2 worldPos = random2(vec2(hash)) * 10.0;\n  mat3 rotateY = rotationYMatrix(random(float(i)) * 3.14);\n\n  float windStength = noise(vec3(worldPos * 0.02, 0.0) + iTime * 0.1) * h * 2.0;\n  mat3  windRot = rotationXMatrix(windStength);\n\n  float leanAnimation = noise(vec3(worldPos, iTime * 0.3));\n  float lean = hash * 0.25 + leanAnimation;\n  \n  vec3 curve = bezier3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.8, 0.0),\n    vec3(0.0, cos(lean), sin(lean)),\n    h\n  );\n\n  vec3 grad = bezierGradient3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.5, 0.0),\n    vec3(0.0, cos(lean), sin(lean)),\n    h\n  );\n  \n  float dx = xSide * 0.14 - 0.07;\n  dx *= mix(1.0, 0.0, pow(h, 3.0));\n\n  float height = step(0.0, noise(vec3(worldPos.xy * 0.5, 0.0)));\n  float y = noise(vec3(worldPos.xy * 0.01, 0.0)) * 3.0;\n  vec3 pos = windRot * rotateY * vec3(dx, curve.y * 2.0, curve.z);\n  pos += vec3(worldPos.x, y, worldPos.y);\n  \n  vPos = pos;\n  vNormal = normalize(windRot * rotateY * zSide * vec3(0.0, grad.z, -grad.y));\n  vH = h;\n  vX = xSide > 0.0 ? 1.0 : -1.0;\n  \n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n",
                                "fragmentShader": "in float vH;\nflat in int vI;\nin vec3 vPos;\nin vec3 vNormal;\nin float vX;\n\nlayout(location = 0) out vec4 colorBuffer;\nlayout(location = 1) out vec4 normalBuffer;\nlayout(location = 2) out vec4 posBuffer;\n\nfloat random(float x) {\n   float r = fract(sin(x * 12.34) * 1234.5678);\n   return r;\n}\n\nvoid main() {\n  float t = random(float(vI)) * 0.5 + 0.5;\n\n  float h = vH * 0.7 + 0.3;\n  vec3 color = mix(vec3(0.4, 0.8, 0.2), vec3(0.8, 0.4, 0.2) * 1.5, t) * h;\n  \n  colorBuffer = vec4(color * (1.0 - abs(vX) * 0.3) * vec3(1.0, 0.9, 0.8) * 1.2, 1.0);\n  normalBuffer = vec4(vNormal, 1.0);\n  posBuffer = vec4(vPos.xyz, 1.0);\n}",
                                "postProcessShader": "uniform float iTime;\nuniform vec2 iResolution;\nuniform mat4 inverseViewMatrix;\nuniform mat4 inverseProjectionMatrix;\nuniform mat4 viewMatrix;\n\nuniform sampler2D iRTBuffer0;\nuniform sampler2D iRTBuffer1;\nuniform sampler2D iRTBuffer2;\nuniform sampler2D iDepthBuffer;\n\nout vec4 FragColor;\n\nvec3 getViewPos() {\n  return (inverseViewMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz;  \n}\n\nvec3 getBluredSample(vec2 uv) {\n  vec3 color = vec3(0.0);\n  float w = 0.0;\n  for (float i = -3.0; i < 3.1; i += 1.0) {\n    for (float j = -3.0; j < 3.1; j += 1.0) {\n      float k = 1.0 / (abs(i) + abs(j) + 1.0);\n      w += k;\n      vec2 offset = vec2(i, j) / iResolution.xy * 2.0;\n      color += texture(iRTBuffer0, uv + offset).rgb * k;\n    }\n  }\n  return color / w;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  vec4 fragColor  = texture(iRTBuffer0, uv);\n  vec3 fragNormal = normalize(texture(iRTBuffer1, uv).xyz);\n  float fragSpec  = texture(iRTBuffer1, uv).w;\n  vec3 fragPos    = texture(iRTBuffer2, uv).xyz;\n  vec3 viewPos    = getViewPos();\n\n  float viewDist = abs(viewPos.z - fragPos.z);\n  float blurAmount = clamp((abs(viewDist - 15.0) - 3.0) / 2.0, 0.0, 1.0);\n  vec3 bluredSample = getBluredSample(uv);\n  \n  FragColor = vec4(mix(fragColor.rgb, bluredSample, blurAmount), 1.0);\n}\n",
                                "properties": "RenderTargetsNumber = 3\nRenderTarget[0].dataType = DATA_TYPE.UNSIGNED_BYTE\nRenderTarget[0].pixelFormat = PIXEL_FORMAT.RGBA\nRenderTarget[1].dataType = DATA_TYPE.FLOAT\nRenderTarget[1].pixelFormat = PIXEL_FORMAT.RGBA\nRenderTarget[2].dataType = DATA_TYPE.FLOAT\nRenderTarget[2].pixelFormat = PIXEL_FORMAT.RGBA\nDepthTest = TRUE\nDepthWrite = TRUE\nBlending = Blending.NO",
                                "defaultVertexShader": "uniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform float iTime;\nuniform sampler2D iChannel0;\n\nin int index;\nin float side;\n\nout float vH;\nflat out int vI;\nout vec3 vPos;\nout vec3 vNormal;\nout float vX;\n\nvec3 bezier3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    float tt = t * t;\n    float uu = u * u;\n\n    vec3 p = uu * p0;\n    p += 2.0 * u * t * p1;\n    p += tt * p2;\n\n    return p;\n}\n\nvec3 bezierGradient3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    vec3 gradient = 2.0 * u * (p1 - p0) + 2.0 * t * (p2 - p1);\n    return gradient;\n}\n\nfloat random(float x) {\n  float r = fract(sin(x * 12.34) * 1234.5678);\n  return r * 2.0 - 1.0;\n}\n\nfloat noise(vec3 st) {\n  vec2 offset = vec2(st.z, 0.0);\n  return texture(iChannel0, fract(st.xy + offset)).r * 2.0 - 1.0;\n}\n\nvec2 random2(vec2 st){\n  float d1 = dot(st, vec2(12.3, 32.1));\n  float d2 = dot(st, vec2(45.6, 65.4));\n  \n  st = vec2(d1, d2);\n  return fract(sin(st) * 78.9) * 2.0 - 1.0;\n}\n\nmat3 rotationXMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      1.0, 0, 0,\n      0, cosAngle, sinAngle,\n      0, -sinAngle, cosAngle\n    );\n}\n\nmat3 rotationYMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      vec3(cosAngle, 0, -sinAngle),\n      vec3(0, 1, 0),\n      vec3(sinAngle, 0, cosAngle)\n    );\n}\n\nvoid main() {\n  int i = index / 20;\n  int vi = index % 10;\n  \n  float h = float(vi / 2) / 4.0;\n  float xSide = mod(float(vi), 2.0);\n  float zSide = ((index % 20) / 10 == 1) ? 1.0 : -1.0;\n  float hash = random(float(i)) * 0.5 + 0.5;\n  vec2 worldPos = random2(vec2(hash)) * 10.0;\n  mat3 rotateY = rotationYMatrix(random(float(i)) * 3.14);\n\n  float windStength = noise(vec3(worldPos * 0.02, 0.0) + iTime * 0.1) * h * 2.0;\n  mat3  windRot = rotationXMatrix(windStength);\n\n  float leanAnimation = noise(vec3(worldPos, iTime * 0.3));\n  float lean = hash * 0.25 + leanAnimation;\n  \n  vec3 curve = bezier3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.8, 0.0),\n    vec3(0.0, cos(lean), sin(lean)),\n    h\n  );\n\n  vec3 grad = bezierGradient3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.5, 0.0),\n    vec3(0.0, cos(lean), sin(lean)),\n    h\n  );\n  \n  float dx = xSide * 0.14 - 0.07;\n  dx *= mix(1.0, 0.0, pow(h, 3.0));\n\n  float height = step(0.0, noise(vec3(worldPos.xy * 0.5, 0.0)));\n  float y = noise(vec3(worldPos.xy * 0.01, 0.0)) * 3.0;\n  vec3 pos = windRot * rotateY * vec3(dx, curve.y * 2.0, curve.z);\n  pos += vec3(worldPos.x, y, worldPos.y);\n  \n  vPos = pos;\n  vNormal = normalize(windRot * rotateY * zSide * vec3(0.0, grad.z, -grad.y));\n  vH = h;\n  vX = xSide > 0.0 ? 1.0 : -1.0;\n  \n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n",
                                "defaultFragmentShader": "in float vH;\nflat in int vI;\nin vec3 vPos;\nin vec3 vNormal;\nin float vX;\n\nlayout(location = 0) out vec4 colorBuffer;\nlayout(location = 1) out vec4 normalBuffer;\nlayout(location = 2) out vec4 posBuffer;\n\nfloat random(float x) {\n   float r = fract(sin(x * 12.34) * 1234.5678);\n   return r;\n}\n\nvoid main() {\n  float t = random(float(vI)) * 0.5 + 0.5;\n\n  float h = vH * 0.7 + 0.3;\n  vec3 color = mix(vec3(0.4, 0.8, 0.2), vec3(0.8, 0.4, 0.2) * 1.5, t) * h;\n  \n  colorBuffer = vec4(color * (1.0 - abs(vX) * 0.3) * vec3(1.0, 0.9, 0.8) * 1.2, 1.0);\n  normalBuffer = vec4(vNormal, 1.0);\n  posBuffer = vec4(vPos.xyz, 1.0);\n}",
                                "defaultPostProcessShader": "uniform float iTime;\nuniform vec2 iResolution;\nuniform mat4 inverseViewMatrix;\nuniform mat4 inverseProjectionMatrix;\nuniform mat4 viewMatrix;\n\nuniform sampler2D iRTBuffer0;\nuniform sampler2D iRTBuffer1;\nuniform sampler2D iRTBuffer2;\nuniform sampler2D iDepthBuffer;\n\nout vec4 FragColor;\n\nvec3 getViewPos() {\n  return (inverseViewMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz;  \n}\n\nvec3 getBluredSample(vec2 uv) {\n  vec3 color = vec3(0.0);\n  float w = 0.0;\n  for (float i = -3.0; i < 3.1; i += 1.0) {\n    for (float j = -3.0; j < 3.1; j += 1.0) {\n      float k = 1.0 / (abs(i) + abs(j) + 1.0);\n      w += k;\n      vec2 offset = vec2(i, j) / iResolution.xy * 2.0;\n      color += texture(iRTBuffer0, uv + offset).rgb * k * 2.0;\n    }\n  }\n  return color / w;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  vec4 fragColor  = texture(iRTBuffer0, uv);\n  vec3 fragNormal = normalize(texture(iRTBuffer1, uv).xyz);\n  float fragSpec  = texture(iRTBuffer1, uv).w;\n  vec3 fragPos    = texture(iRTBuffer2, uv).xyz;\n  vec3 viewPos    = getViewPos();\n  \n  FragColor = vec4(fragColor.rgb, 1.0);\n}\n",
                                "defaultProperties": "RenderTargetsNumber = 3\nRenderTarget[0].dataType = DATA_TYPE.UNSIGNED_BYTE\nRenderTarget[0].pixelFormat = PIXEL_FORMAT.RGBA\nRenderTarget[1].dataType = DATA_TYPE.FLOAT\nRenderTarget[1].pixelFormat = PIXEL_FORMAT.RGBA\nRenderTarget[2].dataType = DATA_TYPE.FLOAT\nRenderTarget[2].pixelFormat = PIXEL_FORMAT.RGBA\nDepthTest = TRUE\nDepthWrite = TRUE\nBlending = Blending.NO",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": false,
                                "postProcessCodeEditable": true,
                                "propertiesEditable": true,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":0,\"y\":4,\"z\":15},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":45,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":1,\"z\":0},\"rotation\":{\"x\":0.25,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":\"14\",\"model\":null,\"meshes\":[{\"name\":\"main\",\"materialId\":0}],\"colorRGBA\":\"FFFFFF\",\"color\":null},{\"position\":{\"x\":-2,\"y\":0,\"z\":-2},\"rotation\":{\"x\":0,\"y\":0.5,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":\"10\",\"model\":\"Cow.glb\",\"meshes\":[{\"name\":\"Cow_1\",\"materialId\":1},{\"name\":\"Cow_2\",\"materialId\":1},{\"name\":\"Cow_3\",\"materialId\":1},{\"name\":\"Cow_4\",\"materialId\":1},{\"name\":\"Cow_5\",\"materialId\":1},{\"name\":\"Cow_6\",\"materialId\":1},{\"name\":\"Cow_7\",\"materialId\":1}],\"colorRGBA\":\"FFFFFF\",\"color\":null},{\"position\":{\"x\":0,\"y\":-10,\"z\":-20},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1000,\"y\":1000,\"z\":1000},\"geometry\":1,\"model\":null,\"meshes\":[{\"name\":\"main\",\"materialId\":2}],\"colorRGBA\":\"506060\",\"color\":5267552},{\"position\":{\"x\":7,\"y\":0,\"z\":-8},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":2.2,\"y\":2.2,\"z\":2.2},\"geometry\":\"10\",\"model\":\"tree-green.glb\",\"meshes\":[{\"name\":\"Tree_1_1\",\"materialId\":1},{\"name\":\"Tree_1_2\",\"materialId\":1}],\"colorRGBA\":\"FFFFFF\",\"color\":null},{\"position\":{\"x\":-4,\"y\":0,\"z\":8},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":2,\"y\":2,\"z\":2},\"geometry\":\"10\",\"model\":\"tree-no-leaves.glb\",\"meshes\":[{\"name\":\"CommonTree_Dead_Snow_3_1\",\"materialId\":1},{\"name\":\"CommonTree_Dead_Snow_3_2\",\"materialId\":1}],\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"materials\":[{\"vertex\":\"uniform mat4 modelMatrix;\\nuniform mat4 viewMatrix;\\nuniform mat4 projectionMatrix;\\n\\nin vec3 position;\\nin vec3 normal;\\nin vec4 color;\\n\\nout vec4 vColor;\\nout vec3 vNormal;\\nout vec3 vPos;\\n\\nvoid main() {\\n  vColor = color;\\n  vNormal = normalize(mat3(transpose(inverse(modelMatrix))) * normal);\\n  vPos = (modelMatrix * vec4(position, 1.0)).xyz;\\n  \\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\\n}\",\"fragment\":\"uniform mat4 inverseViewMatrix;\\n\\nin vec4 vColor;\\nin vec3 vNormal;\\nin vec3 vPos;\\n\\nlayout(location = 0) out vec4 colorBuffer;\\nlayout(location = 1) out vec4 normalBuffer;\\nlayout(location = 2) out vec4 posBuffer;\\n\\nvec3 getViewPos() {\\n  return (inverseViewMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz;  \\n}\\n\\nvoid main() {\\n  vec3 fragPos  = vPos;\\n  vec3 fragNormal = normalize(vNormal);\\n  vec3 viewPos  = getViewPos();\\n  vec3 lightPos = vec3(0.0, 10.0, 0.0);\\n  vec3 lightClr = vec3(1.0, 0.9, 0.8);\\n  vec3 fogColor = vec3(0.4, 0.4, 0.3);\\n  \\n  vec3 lightDir = normalize(lightPos - fragPos);\\n  float diffuse = max(0.0, dot(fragNormal, lightDir));\\n  \\n  vec3 viewDir = normalize(viewPos - fragPos);\\n  vec3 halfwayDir = normalize(lightDir + viewDir);\\n  float specular = max(dot(fragNormal, halfwayDir), 0.0);\\n  specular = pow(specular, 1.0);\\n\\n  colorBuffer = vec4(lightClr * (0.7 + diffuse + specular) * vColor.rgb, 1.0);\\n  normalBuffer = vec4(fragNormal, 1.0);\\n  posBuffer = vec4(vPos.xyz, 1.0);\\n}\\n\",\"properties\":\"DepthTest = TRUE\\nDepthWrite = TRUE\\nBlending = Blending.NO\"},{\"vertex\":\"uniform mat4 modelMatrix;\\nuniform mat4 viewMatrix;\\nuniform mat4 projectionMatrix;\\n\\nin vec3 position;\\nin vec3 normal;\\nin vec4 color;\\n\\nout vec4 vColor;\\nout vec3 vNormal;\\nout vec3 vPos;\\n\\nvoid main() {\\n  vColor = color;\\n  vNormal = normalize(mat3(transpose(inverse(modelMatrix))) * normal);\\n  vPos = (modelMatrix * vec4(position, 1.0)).xyz;\\n  \\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\\n}\",\"fragment\":\"in vec4 vColor;\\nin vec3 vNormal;\\nin vec3 vPos;\\n\\nlayout(location = 0) out vec4 colorBuffer;\\nlayout(location = 1) out vec4 normalBuffer;\\nlayout(location = 2) out vec4 posBuffer;\\n\\nvoid main() {\\n  colorBuffer = vColor;\\n  normalBuffer = vec4(normalize(vNormal) * -1.0, 1.0);\\n  posBuffer = vec4(vPos.x, -1000.0, vPos.z, 1.0);\\n}\\n\",\"properties\":\"\"}],\"actions\":[],\"backgroundRGBA\":\"506060\",\"background\":5267552,\"customDepthBufferTexture\":false,\"glslVersion\":\"3\"}",
                                "description": "The depth of field (DoF) effect is used in computer graphics to create realistic blurring of objects that are out of focus. This effect mimics the behavior of real cameras, where only objects at a certain distance from the lens are in focus, while the rest are blurred.\n\n<br>\n\n### Main Steps to Create the Depth of Field Effect\n\n1. Generate a Depth Map: First, a depth map of the scene is rendered, which contains information about the distance of each pixel from the camera.\n\n2. Determine the Focal Distance: The focal distance is set, at which objects will be in focus. This distance can be fixed or dynamic, depending on the scene.\n\n3. Calculate the Blur: For each pixel, the amount of blur is calculated based on its depth and the focal distance. Pixels that are closer or farther from the focal distance will be more blurred.\n\n4. Apply the Blur: The blur is applied to the pixels using various methods, such as Gaussian blur or bokeh effect. This creates a smooth transition between the focused and unfocused areas.\n\n### Task",
                                "hints": [],
                                "restrictions": [],
                                "order": 17,
                                "cost": 5,
                                "threshold": 99,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [
                                    {
                                        "index": 0
                                    }
                                ],
                                "animated": true,
                                "animationSteps": 20,
                                "animationStepTime": 1000,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": false
                            },
                            "vertexShader": "uniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform float iTime;\nuniform sampler2D iChannel0;\n\nin int index;\nin float side;\n\nout float vH;\nflat out int vI;\nout vec3 vPos;\nout vec3 vNormal;\nout float vX;\n\nvec3 bezier3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    float tt = t * t;\n    float uu = u * u;\n\n    vec3 p = uu * p0;\n    p += 2.0 * u * t * p1;\n    p += tt * p2;\n\n    return p;\n}\n\nvec3 bezierGradient3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    vec3 gradient = 2.0 * u * (p1 - p0) + 2.0 * t * (p2 - p1);\n    return gradient;\n}\n\nfloat random(float x) {\n  float r = fract(sin(x * 12.34) * 1234.5678);\n  return r * 2.0 - 1.0;\n}\n\nfloat noise(vec3 st) {\n  vec2 offset = vec2(st.z, 0.0);\n  return texture(iChannel0, fract(st.xy + offset)).r * 2.0 - 1.0;\n}\n\nvec2 random2(vec2 st){\n  float d1 = dot(st, vec2(12.3, 32.1));\n  float d2 = dot(st, vec2(45.6, 65.4));\n  \n  st = vec2(d1, d2);\n  return fract(sin(st) * 78.9) * 2.0 - 1.0;\n}\n\nmat3 rotationXMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      1.0, 0, 0,\n      0, cosAngle, sinAngle,\n      0, -sinAngle, cosAngle\n    );\n}\n\nmat3 rotationYMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      vec3(cosAngle, 0, -sinAngle),\n      vec3(0, 1, 0),\n      vec3(sinAngle, 0, cosAngle)\n    );\n}\n\nvoid main() {\n  int i = index / 20;\n  int vi = index % 10;\n  \n  float h = float(vi / 2) / 4.0;\n  float xSide = mod(float(vi), 2.0);\n  float zSide = ((index % 20) / 10 == 1) ? 1.0 : -1.0;\n  float hash = random(float(i)) * 0.5 + 0.5;\n  vec2 worldPos = random2(vec2(hash)) * 10.0;\n  mat3 rotateY = rotationYMatrix(random(float(i)) * 3.14);\n\n  float windStength = noise(vec3(worldPos * 0.02, 0.0) + iTime * 0.1) * h * 2.0;\n  mat3  windRot = rotationXMatrix(windStength);\n\n  float leanAnimation = noise(vec3(worldPos, iTime * 0.3));\n  float lean = hash * 0.25 + leanAnimation;\n  \n  vec3 curve = bezier3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.8, 0.0),\n    vec3(0.0, cos(lean), sin(lean)),\n    h\n  );\n\n  vec3 grad = bezierGradient3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.5, 0.0),\n    vec3(0.0, cos(lean), sin(lean)),\n    h\n  );\n  \n  float dx = xSide * 0.14 - 0.07;\n  dx *= mix(1.0, 0.0, pow(h, 3.0));\n\n  float height = step(0.0, noise(vec3(worldPos.xy * 0.5, 0.0)));\n  float y = noise(vec3(worldPos.xy * 0.01, 0.0)) * 3.0;\n  vec3 pos = windRot * rotateY * vec3(dx, curve.y * 2.0, curve.z);\n  pos += vec3(worldPos.x, y, worldPos.y);\n  \n  vPos = pos;\n  vNormal = normalize(windRot * rotateY * zSide * vec3(0.0, grad.z, -grad.y));\n  vH = h;\n  vX = xSide > 0.0 ? 1.0 : -1.0;\n  \n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n",
                            "fragmentShader": "in float vH;\nflat in int vI;\nin vec3 vPos;\nin vec3 vNormal;\nin float vX;\n\nlayout(location = 0) out vec4 colorBuffer;\nlayout(location = 1) out vec4 normalBuffer;\nlayout(location = 2) out vec4 posBuffer;\n\nfloat random(float x) {\n   float r = fract(sin(x * 12.34) * 1234.5678);\n   return r;\n}\n\nvoid main() {\n  float t = random(float(vI)) * 0.5 + 0.5;\n\n  float h = vH * 0.7 + 0.3;\n  vec3 color = mix(vec3(0.4, 0.8, 0.2), vec3(0.8, 0.4, 0.2) * 1.5, t) * h;\n  \n  colorBuffer = vec4(color * (1.0 - abs(vX) * 0.3) * vec3(1.0, 0.9, 0.8) * 1.2, 1.0);\n  normalBuffer = vec4(vNormal, 1.0);\n  posBuffer = vec4(vPos.xyz, 1.0);\n}",
                            "postProcessShader": "uniform float iTime;\nuniform vec2 iResolution;\nuniform mat4 inverseViewMatrix;\nuniform mat4 inverseProjectionMatrix;\nuniform mat4 viewMatrix;\n\nuniform sampler2D iRTBuffer0;\nuniform sampler2D iRTBuffer1;\nuniform sampler2D iRTBuffer2;\nuniform sampler2D iDepthBuffer;\n\nout vec4 FragColor;\n\nvec3 getViewPos() {\n  return (inverseViewMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz;  \n}\n\nvec3 getBluredSample(vec2 uv) {\n  vec3 color = vec3(0.0);\n  float w = 0.0;\n  for (float i = -3.0; i < 3.1; i += 1.0) {\n    for (float j = -3.0; j < 3.1; j += 1.0) {\n      float k = 1.0 / (abs(i) + abs(j) + 1.0);\n      w += k;\n      vec2 offset = vec2(i, j) / iResolution.xy * 2.0;\n      color += texture(iRTBuffer0, uv + offset).rgb * k * 2.0;\n    }\n  }\n  return color / w;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  vec4 fragColor  = texture(iRTBuffer0, uv);\n  vec3 fragNormal = normalize(texture(iRTBuffer1, uv).xyz);\n  float fragSpec  = texture(iRTBuffer1, uv).w;\n  vec3 fragPos    = texture(iRTBuffer2, uv).xyz;\n  vec3 viewPos    = getViewPos();\n  \n  FragColor = vec4(fragColor.rgb, 1.0);\n}\n",
                            "properties": "RenderTargetsNumber = 3\nRenderTarget[0].dataType = DATA_TYPE.UNSIGNED_BYTE\nRenderTarget[0].pixelFormat = PIXEL_FORMAT.RGBA\nRenderTarget[1].dataType = DATA_TYPE.FLOAT\nRenderTarget[1].pixelFormat = PIXEL_FORMAT.RGBA\nRenderTarget[2].dataType = DATA_TYPE.FLOAT\nRenderTarget[2].pixelFormat = PIXEL_FORMAT.RGBA\nDepthTest = TRUE\nDepthWrite = TRUE\nBlending = Blending.NO",
                            "defaultVertexShader": "uniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform float iTime;\nuniform sampler2D iChannel0;\n\nin int index;\nin float side;\n\nout float vH;\nflat out int vI;\nout vec3 vPos;\nout vec3 vNormal;\nout float vX;\n\nvec3 bezier3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    float tt = t * t;\n    float uu = u * u;\n\n    vec3 p = uu * p0;\n    p += 2.0 * u * t * p1;\n    p += tt * p2;\n\n    return p;\n}\n\nvec3 bezierGradient3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    vec3 gradient = 2.0 * u * (p1 - p0) + 2.0 * t * (p2 - p1);\n    return gradient;\n}\n\nfloat random(float x) {\n  float r = fract(sin(x * 12.34) * 1234.5678);\n  return r * 2.0 - 1.0;\n}\n\nfloat noise(vec3 st) {\n  vec2 offset = vec2(st.z, 0.0);\n  return texture(iChannel0, fract(st.xy + offset)).r * 2.0 - 1.0;\n}\n\nvec2 random2(vec2 st){\n  float d1 = dot(st, vec2(12.3, 32.1));\n  float d2 = dot(st, vec2(45.6, 65.4));\n  \n  st = vec2(d1, d2);\n  return fract(sin(st) * 78.9) * 2.0 - 1.0;\n}\n\nmat3 rotationXMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      1.0, 0, 0,\n      0, cosAngle, sinAngle,\n      0, -sinAngle, cosAngle\n    );\n}\n\nmat3 rotationYMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      vec3(cosAngle, 0, -sinAngle),\n      vec3(0, 1, 0),\n      vec3(sinAngle, 0, cosAngle)\n    );\n}\n\nvoid main() {\n  int i = index / 20;\n  int vi = index % 10;\n  \n  float h = float(vi / 2) / 4.0;\n  float xSide = mod(float(vi), 2.0);\n  float zSide = ((index % 20) / 10 == 1) ? 1.0 : -1.0;\n  float hash = random(float(i)) * 0.5 + 0.5;\n  vec2 worldPos = random2(vec2(hash)) * 10.0;\n  mat3 rotateY = rotationYMatrix(random(float(i)) * 3.14);\n\n  float windStength = noise(vec3(worldPos * 0.02, 0.0) + iTime * 0.1) * h * 2.0;\n  mat3  windRot = rotationXMatrix(windStength);\n\n  float leanAnimation = noise(vec3(worldPos, iTime * 0.3));\n  float lean = hash * 0.25 + leanAnimation;\n  \n  vec3 curve = bezier3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.8, 0.0),\n    vec3(0.0, cos(lean), sin(lean)),\n    h\n  );\n\n  vec3 grad = bezierGradient3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.5, 0.0),\n    vec3(0.0, cos(lean), sin(lean)),\n    h\n  );\n  \n  float dx = xSide * 0.14 - 0.07;\n  dx *= mix(1.0, 0.0, pow(h, 3.0));\n\n  float height = step(0.0, noise(vec3(worldPos.xy * 0.5, 0.0)));\n  float y = noise(vec3(worldPos.xy * 0.01, 0.0)) * 3.0;\n  vec3 pos = windRot * rotateY * vec3(dx, curve.y * 2.0, curve.z);\n  pos += vec3(worldPos.x, y, worldPos.y);\n  \n  vPos = pos;\n  vNormal = normalize(windRot * rotateY * zSide * vec3(0.0, grad.z, -grad.y));\n  vH = h;\n  vX = xSide > 0.0 ? 1.0 : -1.0;\n  \n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n",
                            "defaultFragmentShader": "in float vH;\nflat in int vI;\nin vec3 vPos;\nin vec3 vNormal;\nin float vX;\n\nlayout(location = 0) out vec4 colorBuffer;\nlayout(location = 1) out vec4 normalBuffer;\nlayout(location = 2) out vec4 posBuffer;\n\nfloat random(float x) {\n   float r = fract(sin(x * 12.34) * 1234.5678);\n   return r;\n}\n\nvoid main() {\n  float t = random(float(vI)) * 0.5 + 0.5;\n\n  float h = vH * 0.7 + 0.3;\n  vec3 color = mix(vec3(0.4, 0.8, 0.2), vec3(0.8, 0.4, 0.2) * 1.5, t) * h;\n  \n  colorBuffer = vec4(color * (1.0 - abs(vX) * 0.3) * vec3(1.0, 0.9, 0.8) * 1.2, 1.0);\n  normalBuffer = vec4(vNormal, 1.0);\n  posBuffer = vec4(vPos.xyz, 1.0);\n}",
                            "defaultPostProcessShader": "uniform float iTime;\nuniform vec2 iResolution;\nuniform mat4 inverseViewMatrix;\nuniform mat4 inverseProjectionMatrix;\nuniform mat4 viewMatrix;\n\nuniform sampler2D iRTBuffer0;\nuniform sampler2D iRTBuffer1;\nuniform sampler2D iRTBuffer2;\nuniform sampler2D iDepthBuffer;\n\nout vec4 FragColor;\n\nvec3 getViewPos() {\n  return (inverseViewMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz;  \n}\n\nvec3 getBluredSample(vec2 uv) {\n  vec3 color = vec3(0.0);\n  float w = 0.0;\n  for (float i = -3.0; i < 3.1; i += 1.0) {\n    for (float j = -3.0; j < 3.1; j += 1.0) {\n      float k = 1.0 / (abs(i) + abs(j) + 1.0);\n      w += k;\n      vec2 offset = vec2(i, j) / iResolution.xy * 2.0;\n      color += texture(iRTBuffer0, uv + offset).rgb * k * 2.0;\n    }\n  }\n  return color / w;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  vec4 fragColor  = texture(iRTBuffer0, uv);\n  vec3 fragNormal = normalize(texture(iRTBuffer1, uv).xyz);\n  float fragSpec  = texture(iRTBuffer1, uv).w;\n  vec3 fragPos    = texture(iRTBuffer2, uv).xyz;\n  vec3 viewPos    = getViewPos();\n  \n  FragColor = vec4(fragColor.rgb, 1.0);\n}\n",
                            "defaultProperties": "RenderTargetsNumber = 3\nRenderTarget[0].dataType = DATA_TYPE.UNSIGNED_BYTE\nRenderTarget[0].pixelFormat = PIXEL_FORMAT.RGBA\nRenderTarget[1].dataType = DATA_TYPE.FLOAT\nRenderTarget[1].pixelFormat = PIXEL_FORMAT.RGBA\nRenderTarget[2].dataType = DATA_TYPE.FLOAT\nRenderTarget[2].pixelFormat = PIXEL_FORMAT.RGBA\nDepthTest = TRUE\nDepthWrite = TRUE\nBlending = Blending.NO",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    }
                ],
                "cover": true,
                "pageHeaderImage": true,
                "fullDesc": "Dive into the world of advanced rendering techniques with OpenGL 3, where you'll explore the powerful capabilities that bring modern graphics to life. You'll gain experience implementing techniques that improve the visual quality and performance of your graphics applications.",
                "skillsDesc": "Take advantage of the advanced features and capabilities of OpenGL 3.<br>Render to multiple textures simultaneously, enabling complex effects like deferred shading and post-processing.<br>Efficiently handle multiple light sources and complex lighting models.<br>Implement realistic reflections, adding depth and realism to your scenes.",
                "importanceDesc": "These techniques enhance visual quality, optimize performance, and add realism to scenes, making them more immersive and engaging. By gaining greater control over the rendering pipeline, you can implement complex effects and custom shaders tailored to your needs, ensuring your projects stand out in the competitive field of real-time graphics.",
                "certifiable": false,
                "images": [
                    "blending.png",
                    "MRT.png",
                    "deferred-shading.png",
                    "SSR.png"
                ]
            }
        },
        {
            "id": 10,
            "slug": "ray-tracing",
            "name": "Ray Tracing",
            "description": "Create highly realistic images by simulating the physical behavior of light.",
            "tasks": 5,
            "acceptedTasks": 0,
            "isOpen": false,
            "order": 8,
            "locked": false,
            "cover": true,
            "child": {
                "id": 10,
                "slug": "ray-tracing",
                "name": "Ray Tracing",
                "description": "Create highly realistic images by simulating the physical behavior of light.",
                "order": 8,
                "createdBy": {
                    "id": 3,
                    "name": "Alexander"
                },
                "locked": false,
                "tasks": [
                    {
                        "id": 117,
                        "slug": "ray",
                        "moduleId": 10,
                        "name": "Ray",
                        "order": 0,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": 0,
                        "premium": false,
                        "child": {
                            "task": {
                                "id": 117,
                                "slug": "ray",
                                "moduleId": 10,
                                "name": "Ray",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nvec3 getRayOrigin() {\n  // we move the ray origin around the circle\n  // to create the animation.\n  return vec3(cos(iTime) * 0.5, sin(iTime) * 0.5, 0.1);\n}\n\nvoid main() {\n  vec2 uv = vec2(gl_FragCoord.xy / iResolution);\n  uv = uv * 2.0 - 1.0;\n\n  vec3 rayOrigin = getRayOrigin();\n\n  vec3 ratio = vec3(iResolution.x / iResolution.y, 1.0, 1.0);\n  rayOrigin *= ratio;\n  \n  vec3 curPos = vec3(uv, 0.0) * ratio;\n  vec3 rayDir = normalize(curPos - rayOrigin);\n  float t = (rayOrigin.z) / abs(rayDir.z);\n  \n  float dist = length(rayDir.xyz * t);\n  \n  gl_FragColor = vec4(1.0 - dist, 0.0, 0.0, 1.0);\n}",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nvec3 getRayOrigin() {\n  // we move the ray origin around the circle\n  // to create the animation.\n  return vec3(cos(iTime) * 0.5, sin(iTime) * 0.5, 0.1);\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  vec3 rayOrigin = getRayOrigin();\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1,\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"backgroundRGBA\":\"FFFFFF\",\"background\":16777215}",
                                "description": "A ray is a line having an origin point **O** and extending to infinity in a given direction **D**:\n\n<br>\n\n![](/files/ray.png)\n\n```\nP(t) = O + D * t\n```\n\nwhere **t** is allowed to be greater than or equal to zero.\n\n\n### Task\nLet's assume that the lower left corner of the screen corresponds to `(-1.0, -1.0)` and the upper right corner is `(1.0, 1.0)`. The *z* coordinate is `0.0`:\n\n<br>\n\n![](/files/ray-screen.png)\n\n<br>\n\nA ray extends from the origin **O** to the point with coordinates of the current fragment:\n\n<br>\n\n![](/files/ray-to-fragment.png)\n\n<br>\n\nCalculate the length of the ray for each fragment and output the value as the red color channel. Consider the aspect ratio of the screen.",
                                "hints": [],
                                "restrictions": [],
                                "order": 0,
                                "cost": 5,
                                "threshold": 98,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": true,
                                "animationSteps": 6,
                                "animationStepTime": 1000,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": false
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nvec3 getRayOrigin() {\n  // we move the ray origin around the circle\n  // to create the animation.\n  return vec3(cos(iTime) * 0.5, sin(iTime) * 0.5, 0.1);\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  vec3 rayOrigin = getRayOrigin();\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nvec3 getRayOrigin() {\n  // we move the ray origin around the circle\n  // to create the animation.\n  return vec3(cos(iTime) * 0.5, sin(iTime) * 0.5, 0.1);\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  vec3 rayOrigin = getRayOrigin();\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 116,
                        "slug": "ray-plane-intersection",
                        "moduleId": 10,
                        "name": "Ray-plane intersection",
                        "order": 1,
                        "cost": 20,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": true,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 116,
                                "slug": "ray-plane-intersection",
                                "moduleId": 10,
                                "name": "Ray-plane intersection",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nconst vec3 shapeColor = vec3(1.0, 0.3, 0.3);\n\nvec3 rotateY(vec3 position, float angle) {\n  float x = +position.x * cos(angle) + position.z * sin(angle);\n  float z = -position.x * sin(angle) + position.z * cos(angle);\n  return vec3(x, position.y, z);\n}\n\nvoid main() {\n  vec2 uv = vec2(gl_FragCoord.xy / iResolution);\n  uv = uv * 2.0 - 1.0;\n  uv.x *= iResolution.x / iResolution.y;\n  \n  vec4 rayOrigin = vec4(0.0, 0.0, 2.0, 1.0);\n  vec4 rayDir = vec4(normalize(vec3(uv, -1.0)), 0.0);\n  \n  vec3 N = normalize(rotateY(vec3(0.0, 0.0, 1.0), iTime));\n  vec3 P = rotateY(vec3(-1.0, 1.0, 0.0), iTime);\n\n  float D = - dot(P, N);\n  vec4 L = vec4(N, D);\n  float t = - (dot(L, rayOrigin) / dot(L, rayDir));\n  \n  vec3 point = rayOrigin.xyz + rayDir.xyz * t;\n  point = rotateY(point, -iTime);\n\n  vec3 color = shapeColor;\n  color *= step(-1.0, point.x);\n  color *= 1.0 - step(1.0, point.x);\n  color *= step(-1.0, point.y);\n  color *= 1.0 - step(1.0, point.y);\n  \n  gl_FragColor = vec4(color, 1.0);\n}",
                                "postProcessShader": "",
                                "properties": "",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nconst vec3 shapeColor = vec3(1.0, 0.3, 0.3);\n\nvec3 rotateY(vec3 position, float angle) {\n  float x = +position.x * cos(angle) + position.z * sin(angle);\n  float z = -position.x * sin(angle) + position.z * cos(angle);\n  return vec3(x, position.y, z);\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  vec3 rayOrigin = vec3(0.0, 0.0, 2.0);\n\n  // Plane normal\n  vec3 N = normalize(rotateY(vec3(0.0, 0.0, 1.0), iTime));\n  \n  // Point on the plane\n  vec3 P = rotateY(vec3(-1.0, 1.0, 0.0), iTime);\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                                "defaultPostProcessShader": "",
                                "defaultProperties": "",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1,\"model\":null,\"meshes\":[{\"name\":\"main\",\"materialId\":0}],\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"materials\":[],\"actions\":[],\"backgroundRGBA\":\"FFFFFF\",\"background\":16777215,\"customDepthBufferTexture\":false,\"glslVersion\":1}",
                                "description": "Given a 3D point **P** and a normal vector **N**, the plane passing through the point **P** and perpendicular to the direction **N** can be defined as the set of points **Q** \n\n<br>\n\n![](/files/ray-plane-intersection-plane.png)\n\n<br>\n\nsuch that: \n\n```\nN * (Q - P) = 0\n```\n\nWe can find the point where the ray intersects the plane\n\n<br>\n\n![](/files/ray-plane-intersection-ray.png)\n\n<br>\n\nby solving the equation:\n\n```\nN * (P(t) - P) = 0\n```\n\n### Task\nLet's assume that the lower left corner of the screen corresponds to the (-1.0, -1.0), the upper right is (1.0, 1.0). The *z* coordinate is 1. And there is a ray from the `rayOrigin` to the point with coordinates of the current fragment:\n\n<br>\n\n![](/files/ray-plane-intersection-task.png)\n\n<br>\n\nGiven a plane defined by the point `P` and the normal vector `N`.\n\n<br>\n\nCalculate the point of the ray-plane intersection (take into account the aspect ratio). Display only that part of the plane that is within -1 and 1 on the X and Y axes in the plane space. \n\n<br>\n\n**Hint**: After you find the point where the ray intersects the plane in world space, you will need to translate its position to the local plane space. To do this, apply to the point the inverse transformation that was applied to the plane. In this task we only rotate the plane along the Y axis.",
                                "hints": [],
                                "restrictions": [],
                                "order": 1,
                                "cost": 20,
                                "threshold": 95,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": true,
                                "animationSteps": 6,
                                "animationStepTime": 1000,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nconst vec3 shapeColor = vec3(1.0, 0.3, 0.3);\n\nvec3 rotateY(vec3 position, float angle) {\n  float x = +position.x * cos(angle) + position.z * sin(angle);\n  float z = -position.x * sin(angle) + position.z * cos(angle);\n  return vec3(x, position.y, z);\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  vec3 rayOrigin = vec3(0.0, 0.0, 2.0);\n\n  // Plane normal\n  vec3 N = normalize(rotateY(vec3(0.0, 0.0, 1.0), iTime));\n  \n  // Point on the plane\n  vec3 P = rotateY(vec3(-1.0, 1.0, 0.0), iTime);\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "postProcessShader": "",
                            "properties": "",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nconst vec3 shapeColor = vec3(1.0, 0.3, 0.3);\n\nvec3 rotateY(vec3 position, float angle) {\n  float x = +position.x * cos(angle) + position.z * sin(angle);\n  float z = -position.x * sin(angle) + position.z * cos(angle);\n  return vec3(x, position.y, z);\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  vec3 rayOrigin = vec3(0.0, 0.0, 2.0);\n\n  // Plane normal\n  vec3 N = normalize(rotateY(vec3(0.0, 0.0, 1.0), iTime));\n  \n  // Point on the plane\n  vec3 P = rotateY(vec3(-1.0, 1.0, 0.0), iTime);\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "defaultPostProcessShader": "",
                            "defaultProperties": "",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 114,
                        "slug": "barycentric-coordinates",
                        "moduleId": 10,
                        "name": "Barycentric coordinates",
                        "order": 2,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": true,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 114,
                                "slug": "barycentric-coordinates",
                                "moduleId": 10,
                                "name": "Barycentric coordinates",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\n\nconst float c_Epsilon = 0.001;\n\nvoid main() {\n  vec3 P = vec3(gl_FragCoord.xy / iResolution, 1.0);\n  \n  vec3 P0 = vec3(0.25, 0.25, 1.0);\n  vec3 P1 = vec3(0.50, 0.75, 1.0);\n  vec3 P2 = vec3(0.75, 0.25, 1.0);\n  \t\t\n  mat3 m = mat3(P0, P1, P2);\n  \n  vec3 w = inverse(m) * P;\n  float w_sum = w.x + w.y + w.z;\n  \n  vec3 color = vec3(1.0, 0.0, 0.0);\n  color *= (1.0 - step(1.0 + c_Epsilon, w_sum)) * step(c_Epsilon, w_sum);\n  color *= step(0.0, w.x);\n  color *= step(0.0, w.y);\n  color *= step(0.0, w.z);\n  \n  gl_FragColor = vec4(color, 1.0);\n}",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\n\nconst float c_Epsilon = 0.001;\n\nvoid main() {\n  vec3 P = vec3(gl_FragCoord.xy / iResolution, 1.0);\n  \n  vec3 P0 = vec3(0.25, 0.25, 1.0);\n  vec3 P1 = vec3(0.50, 0.75, 1.0);\n  vec3 P2 = vec3(0.75, 0.25, 1.0);\n  \n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"object\":{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1},\"backgroundRGBA\":\"FFFFFF\",\"background\":16777215}",
                                "description": "The *barycentric coordinates* represent a weighted average of the triangle's vertices and are expressed as the scalars *w0*, *w1*, *w2* such that:\n\n```\nP = (w0 * P0) + (w1 * P1) + (w2 * P2)\n```\n\nWe can rewrite the first equation as a matrix equation:\n\n```\n[ P0.x P1.x P2.x ] [ w0 ]   [ P.x ]\n[ P0.y P1.y P2.y ] [ w1 ] = [ P.y ]\n[ P0.z P1.z P2.z ] [ w2 ]   [ P.z ]\n```\n\nWe can solve for *w0*, *w1*, and *w2* using matrix inversion:\n\n```\n[ w0 ]          [[ P0.x P1.x P2.x ]] [ P.x ]\n[ w1 ] = inverse[[ P0.y P1.y P2.y ]] [ P.y ]\n[ w2 ]          [[ P0.z P1.z P2.z ]] [ P.z ]\n```\nThe point **P** lies inside the triangle if and only if all three weights are non-negative and their sum is 1.\n\n### Task\nFor each fragment on the screen, determine whether it lies inside a triangle defined by three vertices:\n\n```\nP0 = (0.25, 0.25, 1.0);\nP1 = (0.50, 0.75, 1.0);\nP2 = (0.75, 0.25, 1.0);\n```\n\nIf the fragment is inside the triangle, paint it red. Use 1.0 value for *z* coordinate and `c_Epsilon` constant for value comparisons.",
                                "hints": [],
                                "restrictions": [],
                                "order": 2,
                                "cost": 5,
                                "threshold": 95,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\n\nconst float c_Epsilon = 0.001;\n\nvoid main() {\n  vec3 P = vec3(gl_FragCoord.xy / iResolution, 1.0);\n  \n  vec3 P0 = vec3(0.25, 0.25, 1.0);\n  vec3 P1 = vec3(0.50, 0.75, 1.0);\n  vec3 P2 = vec3(0.75, 0.25, 1.0);\n  \n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\n\nconst float c_Epsilon = 0.001;\n\nvoid main() {\n  vec3 P = vec3(gl_FragCoord.xy / iResolution, 1.0);\n  \n  vec3 P0 = vec3(0.25, 0.25, 1.0);\n  vec3 P1 = vec3(0.50, 0.75, 1.0);\n  vec3 P2 = vec3(0.75, 0.25, 1.0);\n  \n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 115,
                        "slug": "interpolation-in-barycentric-coordinates",
                        "moduleId": 10,
                        "name": "Interpolation in barycentric coordinates",
                        "order": 3,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": true,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 115,
                                "slug": "interpolation-in-barycentric-coordinates",
                                "moduleId": 10,
                                "name": "Interpolation in barycentric coordinates",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\n\nconst float c_Epsilon = 0.001;\n\nvoid main() {\n  vec3 P = vec3(gl_FragCoord.xy / iResolution, 1.0);\n  \n  vec3 P1 = vec3(0.25, 0.25, 1.0);\n  vec3 P2 = vec3(0.50, 0.75, 1.0);\n  vec3 P3 = vec3(0.75, 0.25, 1.0);\n  \n  vec3 C1 = vec3(1.0, 0.0, 0.0);\n  vec3 C2 = vec3(0.0, 1.0, 0.0);\n  vec3 C3 = vec3(0.0, 0.0, 1.0);\n  \t\t\n  mat3 m = mat3(P1, P2, P3);\n  \n  vec3 w = inverse(m) * P;\n  float w_sum = w.x + w.y + w.z;\n  \n  vec3 color = C1 * w.x + C2 * w.y + C3 * w.z;\n  \n  color *= (1.0 - step(1.0 + c_Epsilon, w_sum)) * step(c_Epsilon, w_sum);\n  color *= step(0.0, w.x);\n  color *= step(0.0, w.y);\n  color *= step(0.0, w.z);\n  \n  gl_FragColor = vec4(color, 1.0);\n}",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\n\nconst float c_Epsilon = 0.001;\n\nvoid main() {\n  vec3 P = vec3(gl_FragCoord.xy / iResolution, 1.0);\n  \n  vec3 P1 = vec3(0.25, 0.25, 1.0);\n  vec3 P2 = vec3(0.50, 0.75, 1.0);\n  vec3 P3 = vec3(0.75, 0.25, 1.0);\n  \n  vec3 C1 = vec3(1.0, 0.0, 0.0);\n  vec3 C2 = vec3(0.0, 1.0, 0.0);\n  vec3 C3 = vec3(0.0, 0.0, 1.0);\n  \n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"object\":{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1},\"backgroundRGBA\":\"FFFFFF\",\"background\":16777215}",
                                "description": "### Task\nThe triangle is defined by three vertices:\n\n```\nP0 = (0.25, 0.25, 1.0);\nP1 = (0.50, 0.75, 1.0);\nP2 = (0.75, 0.25, 1.0);\n```\n\nEach vertex of the triangle has a specific color:\n\n```\nvec3 C1 = vec3(1.0, 0.0, 0.0);\nvec3 C2 = vec3(0.0, 1.0, 0.0);\nvec3 C3 = vec3(0.0, 0.0, 1.0);\n```\n\nUsing barycentric weights, interpolate the color over the entire area of the triangle.",
                                "hints": [],
                                "restrictions": [],
                                "order": 3,
                                "cost": 5,
                                "threshold": 95,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\n\nconst float c_Epsilon = 0.001;\n\nvoid main() {\n  vec3 P = vec3(gl_FragCoord.xy / iResolution, 1.0);\n  \n  vec3 P1 = vec3(0.25, 0.25, 1.0);\n  vec3 P2 = vec3(0.50, 0.75, 1.0);\n  vec3 P3 = vec3(0.75, 0.25, 1.0);\n  \n  vec3 C1 = vec3(1.0, 0.0, 0.0);\n  vec3 C2 = vec3(0.0, 1.0, 0.0);\n  vec3 C3 = vec3(0.0, 0.0, 1.0);\n  \n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\n\nconst float c_Epsilon = 0.001;\n\nvoid main() {\n  vec3 P = vec3(gl_FragCoord.xy / iResolution, 1.0);\n  \n  vec3 P1 = vec3(0.25, 0.25, 1.0);\n  vec3 P2 = vec3(0.50, 0.75, 1.0);\n  vec3 P3 = vec3(0.75, 0.25, 1.0);\n  \n  vec3 C1 = vec3(1.0, 0.0, 0.0);\n  vec3 C2 = vec3(0.0, 1.0, 0.0);\n  vec3 C3 = vec3(0.0, 0.0, 1.0);\n  \n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 118,
                        "slug": "ray-triangle-intersection",
                        "moduleId": 10,
                        "name": "Ray-triangle intersection",
                        "order": 4,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": true,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 118,
                                "slug": "ray-triangle-intersection",
                                "moduleId": 10,
                                "name": "Ray-triangle intersection",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nconst float c_Epsilon = 0.001;\n\nvec3 rotateY(vec3 position)\n{\n  float angle = sin(iTime * 0.5) * 3.14;\n  \n  float x = position.x * cos(angle) + position.z * sin(angle);\n  float z = -position.x * sin(angle) + position.z * cos(angle);\n  \n  return vec3(x, position.y, z);\n}\n\nvoid main() {\n  vec2 uv = vec2(gl_FragCoord.xy / iResolution);\n  \n  vec3 P0 = vec3(0.0, -1.0, -0.5) + rotateY(vec3(-0.5, 0.0, 0.0));\n  vec3 P1 = vec3(0.0,  1.0, -0.5);\n  vec3 P2 = vec3(0.0, -1.0, -0.5) + rotateY(vec3(0.5, 0.0, 0.0));\n  \n  vec4 RayOrigin = vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 RayDir = vec4(normalize(vec3(uv * 2.0 - 1.0, -1.0)), 0.0);\n  \n  vec3 N = cross(P1 - P0, P2 - P0);\n  vec4 L = vec4(N, -dot(N, P1));\n  float t = - (dot(L, RayOrigin) / dot(L, RayDir));\n  \n  vec3 P = RayOrigin.xyz + RayDir.xyz * t;\n  float dist = abs(RayDir.z * t);\n  \t\t\n  mat3 m = mat3(P0, P1, P2);\n  \n  vec3 w = inverse(m) * P;\n  float w_sum = w.x + w.y + w.z;\n  \n  vec3 color = vec3(2.0 - dist, 0.0, 0.0);\n  color *= (1.0 - step(1.0 + c_Epsilon, w_sum)) * step(c_Epsilon, w_sum);\n  color *= step(0.0, w.x);\n  color *= step(0.0, w.y);\n  color *= step(0.0, w.z);\n  \n  gl_FragColor = vec4(color, 1.0);\n}",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nconst float c_Epsilon = 0.001;\n\nvec3 rotateY(vec3 position)\n{\n  float angle = sin(iTime * 0.5) * 3.14;\n  \n  float x = position.x * cos(angle) + position.z * sin(angle);\n  float z = -position.x * sin(angle) + position.z * cos(angle);\n  \n  return vec3(x, position.y, z);\n}\n\nvoid main() {\n  vec2 uv = vec2(gl_FragCoord.xy / iResolution);\n  \n  vec3 P0 = vec3(0.0, -1.0, -0.5) + rotateY(vec3(-0.5, 0.0, 0.0));\n  vec3 P1 = vec3(0.0,  1.0, -0.5);\n  vec3 P2 = vec3(0.0, -1.0, -0.5) + rotateY(vec3(0.5, 0.0, 0.0));\n  \n  vec4 RayOrigin = vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 RayDir = vec4(normalize(vec3(uv * 2.0 - 1.0, -1.0)), 0.0);\n  \n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"object\":{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1},\"backgroundRGBA\":\"FFFFFF\",\"background\":16777215}",
                                "description": "A triangle is described by three vertices **P0**, **P1**, **P2**. We determine the plane in which the triangle lies by calculating the normal vector **N**:\n\n```\nN = (P1 - P0) X (P2 - P0)\n```\n\nThe ray intersects the plane by solving the equation:\n\n```\nN * (P(t) - P0) = 0\n```\n\nNext, we need to determine whether the found intersection point lies inside the triangle using *barycentric coordinates*.\n\n### Task\nLet's assume that the lower left corner of the screen corresponds to the *(-1.0, -1.0)*, the upper right is *(1.0, 1.0)*. The *z* coordinate is 0.\n\n<br>\n\nThere is a ray from the *(0.0, 0.0, 1.0)* to the point with coordinates of the current fragment.\n\n<br>\n\nFor each fragment on the screen, determine whether its ray intersects with a triangle defined by three vertices *P0*, *P1* and *P3*. Determine the possible values for the distance to the triangle, cast it to [0.0, 1.0] interval, and output the value  as the red color channel.",
                                "hints": [],
                                "restrictions": [],
                                "order": 4,
                                "cost": 5,
                                "threshold": 95,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nconst float c_Epsilon = 0.001;\n\nvec3 rotateY(vec3 position)\n{\n  float angle = sin(iTime * 0.5) * 3.14;\n  \n  float x = position.x * cos(angle) + position.z * sin(angle);\n  float z = -position.x * sin(angle) + position.z * cos(angle);\n  \n  return vec3(x, position.y, z);\n}\n\nvoid main() {\n  vec2 uv = vec2(gl_FragCoord.xy / iResolution);\n  \n  vec3 P0 = vec3(0.0, -1.0, -0.5) + rotateY(vec3(-0.5, 0.0, 0.0));\n  vec3 P1 = vec3(0.0,  1.0, -0.5);\n  vec3 P2 = vec3(0.0, -1.0, -0.5) + rotateY(vec3(0.5, 0.0, 0.0));\n  \n  vec4 RayOrigin = vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 RayDir = vec4(normalize(vec3(uv * 2.0 - 1.0, -1.0)), 0.0);\n  \n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nconst float c_Epsilon = 0.001;\n\nvec3 rotateY(vec3 position)\n{\n  float angle = sin(iTime * 0.5) * 3.14;\n  \n  float x = position.x * cos(angle) + position.z * sin(angle);\n  float z = -position.x * sin(angle) + position.z * cos(angle);\n  \n  return vec3(x, position.y, z);\n}\n\nvoid main() {\n  vec2 uv = vec2(gl_FragCoord.xy / iResolution);\n  \n  vec3 P0 = vec3(0.0, -1.0, -0.5) + rotateY(vec3(-0.5, 0.0, 0.0));\n  vec3 P1 = vec3(0.0,  1.0, -0.5);\n  vec3 P2 = vec3(0.0, -1.0, -0.5) + rotateY(vec3(0.5, 0.0, 0.0));\n  \n  vec4 RayOrigin = vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 RayDir = vec4(normalize(vec3(uv * 2.0 - 1.0, -1.0)), 0.0);\n  \n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    }
                ],
                "cover": true,
                "pageHeaderImage": true,
                "fullDesc": "This module is designed for users who want to learn how to create highly realistic images by simulating the physical behavior of light. You will explore the principles of ray tracing, including how light interacts with surfaces to produce effects such reflections and refractions. Each topic includes theoretical material and practical tasks that can be completed directly on the website.",
                "skillsDesc": "algorithms for detecting intersections between rays and surfaces<br>simulating how light bounces off surfaces and passes through transparent materials.<br>statistical methods for simulating complex lighting scenarios (Monte Carlo Methods).<br>techniques to remove noise from rendered images (Denoising).",
                "importanceDesc": "Ray tracing is a powerful technique for generating photorealistic images in computer graphics. By accurately simulating the behavior of light, developers can create scenes with unparalleled realism.",
                "certifiable": false,
                "images": []
            }
        },
        {
            "id": 4,
            "slug": "water",
            "name": "Water",
            "description": "Explore techniques for visualising realistic waves, reflections and refractions.",
            "tasks": 8,
            "acceptedTasks": 0,
            "isOpen": false,
            "order": 9,
            "locked": false,
            "cover": true,
            "child": {
                "id": 4,
                "slug": "water",
                "name": "Water",
                "description": "Explore techniques for visualising realistic waves, reflections and refractions.",
                "order": 9,
                "createdBy": {
                    "id": 3,
                    "name": "Alexander"
                },
                "locked": false,
                "tasks": [
                    {
                        "id": 41,
                        "slug": "distortion",
                        "moduleId": 4,
                        "name": "Distortion",
                        "order": 0,
                        "cost": 10,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": 0,
                        "premium": false,
                        "child": {
                            "task": {
                                "id": 41,
                                "slug": "distortion",
                                "moduleId": 4,
                                "name": "Distortion",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\nuniform sampler2D iChannel0;\n\nconst float PI = 6.28;\nconst float frequency = 5.0;\nconst float amplitude = 0.1;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  float distortion = sin(uv.x * PI * frequency + iTime) * amplitude;\n  vec2 texCoords = vec2(uv.x, uv.y + distortion);\n  \n  vec3 color = texture(iChannel0, texCoords).rgb;\n\n  gl_FragColor = vec4(color, 1.0);\n}",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "\nuniform vec2 iResolution;\nuniform float iTime;\nuniform sampler2D iChannel0;\n\nconst float PI = 6.28;\nconst float frequency = 5.0;\nconst float amplitude = 0.1;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"object\":{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1},\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "Sine distortion is a technique used to create wave-like effects in graphics and animation. It involves applying a sinusoidal function to the coordinates of a texture, which results in a wavy, distorted appearance.\n\n<br>\n\nThe sine function has a period of 2π, which means that it repeats itself every 2π units. By multiplying the sine argument by a factor of 2π, we can create a wave pattern.\n\n<br>\n\nThe resulting formula for creating a wave distortion effect might look something like this:\n\n```\ndistortion = amplitude * sin(2 * PI * distance * frequency)\n```\n\nIn this formula, amplitude and frequency are variables that can be adjusted to control the intensity and number of the waves. Adding `iTime` to the sine period allows for the creation of wave animations that evolve over time.\n\n<br>\n\nTo create the distorted texture coordinates, you can just add the distortion value to the X or/and Y texture coordinates.\n\n\n### Task\nCreate a shader that animates vertical waves moving horizontally across an image. Implement the wave distortion by applying the sine function to the texture coordinates, using `amplitude` and `frequency` variables. To animate the waves over time, use the `iTime` value.",
                                "hints": [],
                                "restrictions": [],
                                "order": 0,
                                "cost": 10,
                                "threshold": 95,
                                "likes": 7,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [
                                    {
                                        "index": 0
                                    }
                                ],
                                "animated": true,
                                "animationSteps": 5,
                                "animationStepTime": 200,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": false
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "\nuniform vec2 iResolution;\nuniform float iTime;\nuniform sampler2D iChannel0;\n\nconst float PI = 6.28;\nconst float frequency = 5.0;\nconst float amplitude = 0.1;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "\nuniform vec2 iResolution;\nuniform float iTime;\nuniform sampler2D iChannel0;\n\nconst float PI = 6.28;\nconst float frequency = 5.0;\nconst float amplitude = 0.1;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 42,
                        "slug": "circle-waves",
                        "moduleId": 4,
                        "name": "Circle Waves",
                        "order": 1,
                        "cost": 10,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": true,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 42,
                                "slug": "circle-waves",
                                "moduleId": 4,
                                "name": "Circle Waves",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\nuniform sampler2D iChannel0;\n\nconst float PI = 6.28;\nconst float frequency = 5.0;\nconst float amplitude = 0.25;\n\nvec2 getDistortion(vec2 pos, vec2 origin) {\n  float distanceToOrigin = distance(pos, origin);\n  float t = distanceToOrigin * PI * frequency - iTime * 2.0;\n  float distortion = sin(t) * amplitude;\n  return vec2(distortion);\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  vec2 distortion = getDistortion(uv, vec2(0.5));  \n  vec2 texCoords = uv + distortion;\n  vec3 color = texture(iChannel0, texCoords).rgb;\n\n  gl_FragColor = vec4(color, 1.0);\n}",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\nuniform sampler2D iChannel0;\n\nconst float PI = 6.28;\nconst float frequency = 5.0;\nconst float amplitude = 0.25;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"object\":{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1},\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "To generate the circular wave distortion effect, we can leverage the pixel-to-center texture distance. By multiplying this distance value by 2π and subsequently passing it through the sine function, we can produce a wave pattern that varies in intensity based on the distance from the center.\n\n### Task\nCreate a shader that animates circular waves emanating from the center of an image. Implement the wave distortion using the sine function with `amplitude` and `frequency` variables. To animate the waves over time, use `iTime` times 2 value.",
                                "hints": [],
                                "restrictions": [],
                                "order": 1,
                                "cost": 10,
                                "threshold": 95,
                                "likes": 1,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [
                                    {
                                        "index": 0
                                    }
                                ],
                                "animated": true,
                                "animationSteps": 5,
                                "animationStepTime": 200,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\nuniform sampler2D iChannel0;\n\nconst float PI = 6.28;\nconst float frequency = 5.0;\nconst float amplitude = 0.25;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\nuniform sampler2D iChannel0;\n\nconst float PI = 6.28;\nconst float frequency = 5.0;\nconst float amplitude = 0.25;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 46,
                        "slug": "attenuation",
                        "moduleId": 4,
                        "name": "Attenuation",
                        "order": 2,
                        "cost": 10,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": true,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 46,
                                "slug": "attenuation",
                                "moduleId": 4,
                                "name": "Attenuation",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\nuniform sampler2D iChannel0;\n\nconst float PI = 6.28;\nconst float frequency = 10.0;\nconst float amplitude = 0.25;\n\nvec2 getDistortion(vec2 pos, vec2 origin) {\n  float distanceToOrigin = distance(pos, origin);\n  float A = mix(amplitude, 0.0, clamp(distanceToOrigin * 2.0, 0.0, 1.0));\n  float t = distanceToOrigin * PI * frequency - iTime * 2.0;\n  float distortion = sin(t) * A;\n  return vec2(distortion);\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  vec2 distortion = getDistortion(uv, vec2(0.5));   \n  vec2 texCoords = uv + distortion;\n  vec3 color = texture(iChannel0, texCoords).rgb;\n\n  gl_FragColor = vec4(color, 1.0);\n}",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\nuniform sampler2D iChannel0;\n\nconst float PI = 6.28;\nconst float frequency = 10.0;\nconst float amplitude = 0.25;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"object\":{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1},\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "Interpolation can be used to create an attenuation effect for circular waves emanating from the center of an image. This is achieved by calculating the distance of each pixel from the center point and using this distance to interpolate the amplitude value of the wave.\n\n### Task\nCreate a shader that animates circular waves emanating from the center of an image, with an attenuation effect.\n\n<br>\n\nUse the sine function with `amplitude` and `frequency` variables to create the wave distortion. \n\n<br>\n\nThe amplitude of the waves should linearly decrease as they move further away from the center point. It should be 0 at a distance from the center equal to 0.5 and beyond.\n\n<br>\n\nTo animate the waves over time, multiply `iTime` by 2.\n\n\n",
                                "hints": [],
                                "restrictions": [],
                                "order": 2,
                                "cost": 10,
                                "threshold": 95,
                                "likes": 1,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [
                                    {
                                        "index": 0
                                    }
                                ],
                                "animated": true,
                                "animationSteps": 5,
                                "animationStepTime": 200,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\nuniform sampler2D iChannel0;\n\nconst float PI = 6.28;\nconst float frequency = 10.0;\nconst float amplitude = 0.25;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\nuniform sampler2D iChannel0;\n\nconst float PI = 6.28;\nconst float frequency = 10.0;\nconst float amplitude = 0.25;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 43,
                        "slug": "interference",
                        "moduleId": 4,
                        "name": "Interference",
                        "order": 3,
                        "cost": 10,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": true,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 43,
                                "slug": "interference",
                                "moduleId": 4,
                                "name": "Interference",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\nuniform sampler2D iChannel0;\n\nconst float PI = 6.28;\nconst float frequency = 16.0;\nconst float amplitude = 0.25;\n\nvec2 getDistortion(vec2 pos, vec2 origin) {\n  float distanceToOrigin = distance(pos, origin);\n  float A = mix(amplitude, 0.0, clamp(distanceToOrigin * 2.0, 0.0, 1.0));\n  float distortion = sin(distanceToOrigin * PI * frequency - iTime * 3.0) * A;\n  return vec2(distortion);\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  vec2 distortion = getDistortion(uv, vec2(0.3));\n  distortion += getDistortion(uv, vec2(0.7));\n    \n  vec2 texCoords = uv + distortion;\n  \n  vec3 color = texture(iChannel0, texCoords).rgb;\n\n  gl_FragColor = vec4(color, 1.0);\n}",
                                "postProcessShader": "",
                                "properties": "",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nconst float PI = 6.28;\nconst float frequency = 16.0;\nconst float amplitude = 0.25;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                                "defaultPostProcessShader": "",
                                "defaultProperties": "",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1,\"model\":null,\"meshes\":[{\"name\":\"main\",\"materialId\":0}],\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"materials\":[],\"actions\":[],\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250,\"customDepthBufferTexture\":false,\"glslVersion\":1}",
                                "description": "implementing interference of circular waves using sine function involves generating waveforms for each wave, adding them together to obtain the resulting waveform, and visualizing the interference pattern.\n\n### Task \nCreate a shader that animates circular waves with the attenuation effect coming from two sources at (0.3, 0.3) and (0.7, 0.7). The shader should demonstrate the interference of circular waves.\n\n<br>\n\nUse the sine function with `amplitude` and `frequency` variables to create the wave distortion.\n\n<br>\n\nThe amplitude of the waves should linearly decrease as they move further away from the source point. It should be 0 at a distance from the source equal to 0.5 and beyond.\n\n<br>\n\nTo animate the waves over time, multiply `iTime` by 3.",
                                "hints": [],
                                "restrictions": [],
                                "order": 3,
                                "cost": 10,
                                "threshold": 95,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [
                                    {
                                        "index": 0
                                    }
                                ],
                                "animated": true,
                                "animationSteps": 200,
                                "animationStepTime": 5,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nconst float PI = 6.28;\nconst float frequency = 16.0;\nconst float amplitude = 0.25;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "postProcessShader": "",
                            "properties": "",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nconst float PI = 6.28;\nconst float frequency = 16.0;\nconst float amplitude = 0.25;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "defaultPostProcessShader": "",
                            "defaultProperties": "",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 12,
                        "slug": "surface-and-bottom",
                        "moduleId": 4,
                        "name": "Surface and Bottom",
                        "order": 4,
                        "cost": 20,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": true,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 12,
                                "slug": "surface-and-bottom",
                                "moduleId": 4,
                                "name": "Surface and Bottom",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\nuniform sampler2D iChannel0;\nuniform sampler2D iChannel1;\n\nconst float PI = 6.28;\nconst float frequency = 10.0;\nconst float amplitude = 0.25;\n\nvec2 getDistortion(vec2 pos, vec2 origin) {\n  float distanceToOrigin = distance(pos, origin);\n  float A = mix(amplitude, 0.0, clamp(distanceToOrigin * 2.0, 0.0, 1.0));\n  float distortion = sin(distanceToOrigin * PI * frequency - iTime * 3.0) * A;\n  return vec2(distortion);\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  vec2 distortion = getDistortion(uv, vec2(0.3));\n  distortion += getDistortion(uv, vec2(0.7));\n    \n  vec2 reflectionCoords = uv + distortion;\n  vec2 refractionCoords = uv + distortion * 0.2;\n  \n  float refractFactor = 0.3;\n   \n  vec3 reflection = texture(iChannel0, reflectionCoords).rgb;\n  vec3 refraction = texture(iChannel1, refractionCoords).rgb;\n  \n  vec3 color = mix(reflection, refraction, refractFactor);\n\n  gl_FragColor = vec4(color, 1.0);\n}",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nconst float PI = 6.28;\nconst float frequency = 10.0;\nconst float amplitude = 0.25;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"object\":{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1},\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "### Task \nCreate a shader that animates circular waves with the attenuation effect coming from two sources at (0.3, 0.3) and (0.7, 0.7).\n\n<br>\n\nUse the sine function with `amplitude` and `frequency` variables to create the wave distortion.\n\n<br>\n\nThe amplitude of the waves should linearly decrease as they move further away from the source point. It should be 0 at a distance from the source equal to 0.5 and beyond.\n\n<br>\n\nTo animate the waves over time, multiply `iTime` by 3.\n\n<br>\n\nTo create the effect of water with a surface and a bottom, use the second texture as the bottom layer. Apply the same distortion effect as the surface of the water, but with a reduced strength of 5 times. Finally, blend the colors of the surface and bottom layers together using a mix parameter of 0.3.",
                                "hints": [],
                                "restrictions": [],
                                "order": 4,
                                "cost": 20,
                                "threshold": 95,
                                "likes": 1,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [
                                    {
                                        "index": 0
                                    },
                                    {
                                        "index": 1
                                    }
                                ],
                                "animated": true,
                                "animationSteps": 5,
                                "animationStepTime": 200,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nconst float PI = 6.28;\nconst float frequency = 10.0;\nconst float amplitude = 0.25;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nconst float PI = 6.28;\nconst float frequency = 10.0;\nconst float amplitude = 0.25;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 121,
                        "slug": "surface-normal",
                        "moduleId": 4,
                        "name": "Surface Normal",
                        "order": 5,
                        "cost": 10,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": true,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 121,
                                "slug": "surface-normal",
                                "moduleId": 4,
                                "name": "Surface Normal",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nconst float PI = 6.28;\nconst float frequency = 10.0;\nconst float amplitude = 2.0;\n\nconst vec2 w1 = vec2(0.3);\nconst vec2 w2 = vec2(0.7);\n\nfloat getX(vec2 pos, vec2 origin) {\n  float distanceToCenter = distance(pos, origin);\n  float x = distanceToCenter * PI * frequency - iTime * 3.0;\n  return x;\n}\n\nfloat getAmplitude(vec2 pos, vec2 origin) {\n  float distanceToOrigin = distance(pos, origin);\n  return mix(amplitude, 0.0, clamp(distanceToOrigin * 2.0, 0.0, 1.0));\n}\n\nvec2 getNormal(vec2 pos, vec2 origin) {\n  float x = getX(pos, origin);\n  float A = getAmplitude(pos, origin);\n  vec2 normal = normalize(vec2(-1.0 * A * cos(x), 1.0));\n  return normal;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  vec2 normal = normalize(getNormal(uv, w1) + getNormal(uv, w2));\n  normal.x = normal.x * 0.5 + 0.5;\n\n  gl_FragColor = vec4(normal, 0.0, 1.0);\n}",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nconst float PI = 6.28;\nconst float frequency = 10.0;\nconst float amplitude = 2.0;\n\nconst vec2 w1 = vec2(0.3);\nconst vec2 w2 = vec2(0.7);\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"object\":{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1},\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "To find the unit normal vector of a two-dimensional curve, we first need to find the unit tangent vector by taking the derivative of the curve and dividing it by its magnitude. After this, we can rotate the tangent vector counterclockwise by 90 degrees to get the unit normal vector.\n\n<br>\n\nFor the sine curve\n\n```\nY = sin(x)\n```\n\nthe derivative is \n\n```\nY' = cos(x)\n```\n\nThis derivative represents the rate of change of **Y** with respect to `x` at any given point on the curve.\n\n<br>\n\nThe tangent vector at any point *(x, y)* on the sine curve is\n\n```\nT = |(1, cos(x))|\n```\n\nHere, the x-component of the tangent vector represents the change in **X** for a unit change in the parameter. Since the parameter change expression is simply `x`:\n\n```\nX = x\n```\n\nthe derivative of this expression is 1:\n```\nX' = 1\n```\n\nTo get the unit normal vector, we need to rotate **T** counterclockwise by 90 degrees:\n\n```\nN = |(-cos(x)), 1|\n```\n\n### Task\nCreate a shader that animates circular waves with the attenuation effect coming from two sources at (0.3, 0.3) and (0.7, 0.7). The shader should demonstrate the interference of circular waves and utilize the surface normal vector for the resulting output. Represent the `x` component as red and the `y` component as green, and bring the values of the vector components to a range of 0 to 1 for visualization purposes.\n\n<br>\n\nUse the sine function with `amplitude` and `frequency` variables to create the wave distortion.\n\n<br>\n\nThe amplitude of the waves should linearly decrease as they move further away from the source point. It should be 0 at a distance from the source equal to 0.5 and beyond.\n\n<br>\n\nTo animate the waves over time, multiply `iTime` by 3.",
                                "hints": [],
                                "restrictions": [],
                                "order": 5,
                                "cost": 10,
                                "threshold": 95,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": true,
                                "animationSteps": 5,
                                "animationStepTime": 200,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nconst float PI = 6.28;\nconst float frequency = 10.0;\nconst float amplitude = 2.0;\n\nconst vec2 w1 = vec2(0.3);\nconst vec2 w2 = vec2(0.7);\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nconst float PI = 6.28;\nconst float frequency = 10.0;\nconst float amplitude = 2.0;\n\nconst vec2 w1 = vec2(0.3);\nconst vec2 w2 = vec2(0.7);\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 45,
                        "slug": "fresnel",
                        "moduleId": 4,
                        "name": "Fresnel",
                        "order": 6,
                        "cost": 20,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": true,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 45,
                                "slug": "fresnel",
                                "moduleId": 4,
                                "name": "Fresnel",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\nuniform sampler2D iChannel0;\nuniform sampler2D iChannel1;\n\nconst vec2 viewDir = normalize(vec2(0.5, 1.0));\n\nconst float PI = 6.28;\nconst float frequency = 10.0;\nconst float amplitude = 0.25;\n\nfloat getX(vec2 pos, vec2 origin) {\n  float distanceToCenter = distance(pos, origin);\n  float x = distanceToCenter * PI * frequency - iTime * 3.0;\n  return x;\n}\n\nfloat getAmplitude(vec2 pos, vec2 origin) {\n  float distanceToOrigin = distance(pos, origin);\n  return mix(amplitude, 0.0, clamp(distanceToOrigin * 2.0, 0.0, 1.0));\n}\n\nvec2 getDistortion(vec2 pos, vec2 origin) {\n  float distortion = sin(getX(pos, origin)) * getAmplitude(pos, origin);\n  return vec2(distortion);\n}\n\nvec2 getNormal(vec2 pos, vec2 origin) {\n  float x = getX(pos, origin);\n  float A = getAmplitude(pos, origin);\n  vec2 normal = normalize(vec2(-1.0 * A * cos(x), 1.0));\n  return normal;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  vec2 w1 = vec2(0.3);\n  vec2 w2 = vec2(0.7);\n\n  vec2 distortion = getDistortion(uv, w1) + getDistortion(uv, w2);\n\n  vec2 reflectCoord = uv + distortion;\n  vec2 refractCoord = uv + distortion * 0.2;\n\n  vec2 normal = normalize(getNormal(uv, w1) + getNormal(uv, w2));\n  float reflectance = dot(viewDir, normal);\n\n  vec3 reflection = texture2D(iChannel0, reflectCoord).rgb;\n  vec3 refraction = texture2D(iChannel1, refractCoord).rgb;\n\n  vec3 color = mix(refraction, reflection, pow(reflectance, 5.0));\n\n  gl_FragColor = vec4(color, 1.0);\n}",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nconst vec2 viewDir = normalize(vec2(0.5, 1.0));\n\nconst float PI = 6.28;\nconst float frequency = 10.0;\nconst float amplitude = 0.25;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"object\":{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1},\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250}",
                                "description": "According to the Fresnel law, the amount of light reflected off a water surface varies with the angle of incidence or the view direction. When light hits the surface of water at a perpendicular angle only a small amount of light is reflected back, and most of it is transmitted through the water. However, as the angle of incidence increases, more and more light is reflected off the surface, and less is transmitted through it.\n\n<br>\n\nTo use the Fresnel law to mix water surface and bottom in a shader, you can calculate the reflection coefficient of the water surface based on the angle between the view direction and the surface normal vector. This reflection coefficient can then be used to blend between the water surface and the bottom color or texture.\n\n```\nReflectance = dot(ViewDir, Normal)\n```\n\n### Task\nCreate a shader that animates circular waves with the attenuation effect coming from two sources at (0.3, 0.3) and (0.7, 0.7). The shader should demonstrate the interference of circular waves. Compute the water surface reflectance based on the surface normal vector and view direction in accordance with the Fresnel law. Utilize the water surface reflectance to blend water surface and bottom textures, raising the reflectance to the power of 5 for a more realistic look.\n\n<br>\n\nUse the sine function with `amplitude` and `frequency` variables to create the wave distortion.\n\n<br>\n\nThe amplitude of the waves should linearly decrease as they move further away from the source point. It should be 0 at a distance from the source equal to 0.5 and beyond.\n\n<br>\n\nTo animate the waves over time, multiply `iTime` by 3.",
                                "hints": [],
                                "restrictions": [],
                                "order": 6,
                                "cost": 20,
                                "threshold": 95,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [
                                    {
                                        "index": 0
                                    },
                                    {
                                        "index": 1
                                    }
                                ],
                                "animated": true,
                                "animationSteps": 5,
                                "animationStepTime": 200,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nconst vec2 viewDir = normalize(vec2(0.5, 1.0));\n\nconst float PI = 6.28;\nconst float frequency = 10.0;\nconst float amplitude = 0.25;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nconst vec2 viewDir = normalize(vec2(0.5, 1.0));\n\nconst float PI = 6.28;\nconst float frequency = 10.0;\nconst float amplitude = 0.25;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 44,
                        "slug": "light",
                        "moduleId": 4,
                        "name": "Light",
                        "order": 7,
                        "cost": 30,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": true,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 44,
                                "slug": "light",
                                "moduleId": 4,
                                "name": "Light",
                                "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\nuniform sampler2D iChannel0;\nuniform sampler2D iChannel1;\n\nconst vec2 viewPos = vec2(-3.0, 7.0);\nconst vec2 lightDir = normalize(vec2(0.25, 1.0));\nconst float shininess = 128.0;\n\nconst float PI = 6.28;\nconst float frequency = 10.0;\nconst float amplitude = 0.25;\n\nfloat getX(vec2 pos, vec2 origin) {\n  float distanceToCenter = distance(pos, origin);\n  float x = distanceToCenter * PI * frequency - iTime * 3.0;\n  return x;\n}\n\nfloat getAmplitude(vec2 pos, vec2 origin) {\n  float distanceToOrigin = distance(pos, origin);\n  return mix(amplitude, 0.0, clamp(distanceToOrigin * 2.0, 0.0, 1.0));\n}\n\nvec2 getDistortion(vec2 pos, vec2 origin) {\n  float distortion = sin(getX(pos, origin)) * getAmplitude(pos, origin);\n  return vec2(distortion);\n}\n\nvec2 getNormal(vec2 pos, vec2 origin) {\n  float x = getX(pos, origin);\n  float A = getAmplitude(pos, origin);\n  vec2 normal = normalize(vec2(-1.0 * A * cos(x), 1.0));\n  return normal;\n}\n\nfloat getLight(vec2 normal, vec2 viewDir) {\n  vec2 reflectDir = reflect(-lightDir, normal);  \n  float specular = (max(dot(viewDir, reflectDir), 0.0));\n  specular = pow(specular, shininess);\n\n  return 1.0 + specular;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  \n  vec2 w1 = vec2(0.3);\n  vec2 w2 = vec2(0.7);\n\n  vec2 distortion = getDistortion(uv, w1) + getDistortion(uv, w2);\n\n  vec2 reflectCoord = uv + distortion;\n  vec2 refractCoord = uv + distortion * 0.2;\n\n  vec2 viewDir = normalize(viewPos - reflectCoord);\n\n  vec2 normal = normalize(getNormal(uv, w1) + getNormal(uv, w2));\n  float reflectance = pow(dot(viewDir, normal), 5.0);\n\n  vec3 reflection = texture2D(iChannel0, reflectCoord).rgb;\n  vec3 refraction = texture2D(iChannel1, refractCoord).rgb;\n\n  vec3 color = mix(refraction, reflection, reflectance);\n  color *= getLight(normal, viewDir);\n\n  gl_FragColor = vec4(color, 1.0);\n}",
                                "postProcessShader": "",
                                "properties": "",
                                "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                                "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nconst vec2 viewPos = vec2(-3.0, 7.0);\nconst vec2 lightDir = normalize(vec2(0.25, 1.0));\nconst float shininess = 128.0;\n\nconst float PI = 6.28;\nconst float frequency = 10.0;\nconst float amplitude = 0.25;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                                "defaultPostProcessShader": "",
                                "defaultProperties": "",
                                "vertexCodeEditable": false,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":-0.5,\"y\":-0.5,\"z\":1},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":true,\"near\":0.1,\"far\":100,\"fov\":75,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":1,\"model\":null,\"meshes\":[{\"name\":\"main\",\"materialId\":0}],\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"materials\":[],\"actions\":[],\"backgroundRGBA\":\"FAFAFA\",\"background\":16448250,\"customDepthBufferTexture\":false,\"glslVersion\":1}",
                                "description": "### Specular Light\n\n<br>\n\nFirst, we need to determine the view direction vector. For this, we have the observer's position and the surface coordinates `uv`. However, using `uv` to calculate the view direction vector is incorrect, as we need to apply lighting to the curved surface of the water:\n\n<br>\n\n![](/files/water-light-view-dir.png)\n\n<br>\n\nTo get specular light component we need to calculate a reflection vector **L'** by reflecting the light direction **L** around the object's normal vector **N**:\n\n<br>\n\n![](/files/specular-lighting-reflect.png)\n\n<br>\n\nThen we calculate the angular distance between the reflection vector **L'** and the view direction **V** (make sure it's not negative):\n\n<br>\n\n![](/files/specular-lighting-eye.png)\n\n<br>\n\n```\nspecular = dot(V, L`)\n```\n\nThe closer the angle between **L'** and **V**, the greater the impact of the specular light.\n\n<br>\n\n### Shininess \n\n<br>\n\nThe higher the shininess value of an object, the more it properly reflects the light instead of scattering it all around and thus the smaller the highlight becomes. To apply shininess first calculate specular component, then raise it to the power of `shininess`:\n```\nspecular = pow(specular, shininess);\n```\n\n### Task\nCreate a shader that animates circular waves with the attenuation effect coming from two sources at (0.3, 0.3) and (0.7, 0.7). The shader should demonstrate the interference of circular waves. \n\n<br>\n\nCompute the water surface reflectance based on the surface normal vector and view direction in accordance with the Fresnel law. To calculate view direction, use `viewPos` and surface coordinates. Utilize the water surface reflectance to blend water surface and bottom textures, raising the reflectance to the power of 5 for a more realistic appearance. \n\n<br>\n\nUse the sine function with `amplitude` and `frequency` variables to create the wave distortion.\n\n<br>\n\nThe amplitude of the waves should linearly decrease as they move further away from the source point. It should be 0 at a distance from the source equal to 0.5 and beyond.\n\n<br>\n\nTo animate the waves over time, multiply `iTime` by 3.\n\n<br>\n\nAdditionally, incorporate Blinn-Phong specular light into the water surface using `viewPos`, `lightDir` and `shininess`.",
                                "hints": [],
                                "restrictions": [],
                                "order": 7,
                                "cost": 30,
                                "threshold": 95,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [
                                    {
                                        "index": 0
                                    },
                                    {
                                        "index": 1
                                    }
                                ],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "fragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nconst vec2 viewPos = vec2(-3.0, 7.0);\nconst vec2 lightDir = normalize(vec2(0.25, 1.0));\nconst float shininess = 128.0;\n\nconst float PI = 6.28;\nconst float frequency = 10.0;\nconst float amplitude = 0.25;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "postProcessShader": "",
                            "properties": "",
                            "defaultVertexShader": "\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",
                            "defaultFragmentShader": "uniform vec2 iResolution;\nuniform float iTime;\n\nconst vec2 viewPos = vec2(-3.0, 7.0);\nconst vec2 lightDir = normalize(vec2(0.25, 1.0));\nconst float shininess = 128.0;\n\nconst float PI = 6.28;\nconst float frequency = 10.0;\nconst float amplitude = 0.25;\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",
                            "defaultPostProcessShader": "",
                            "defaultProperties": "",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    }
                ],
                "cover": true,
                "pageHeaderImage": true,
                "fullDesc": "This module is designed for users who want to learn how to visualize water effects in computer graphics. You will explore different techniques for simulating water surface using fragment shader. Each topic includes theoretical material and practical tasks that can be completed directly on the website.",
                "skillsDesc": "how to use fragment shaders to create wave patterns and animations.<br>techniques for simulating water surfaces.<br>explore the physics of wave interference and how it affects water simulation.<br>understand and apply the Fresnel law to simulate realistic reflections and refractions.",
                "importanceDesc": "A solid grasp of different simulation techniques and the physical laws behind them is fundamental for creating high-quality, realistic, and efficient visual effects in computer graphics. It empowers developers to produce visually stunning and technically sound work, enhancing both their projects and their professional capabilities.",
                "certifiable": false,
                "images": [
                    "img-1.png",
                    "img-2.png",
                    "img-3.png"
                ]
            }
        },
        {
            "id": 13,
            "slug": "grass",
            "name": "Grass",
            "description": "Exploration of hight-quality grass rendering techniques",
            "tasks": 9,
            "acceptedTasks": 1,
            "isOpen": false,
            "order": 10,
            "locked": false,
            "cover": true,
            "child": {
                "id": 13,
                "slug": "grass",
                "name": "Grass",
                "description": "Exploration of hight-quality grass rendering techniques",
                "order": 10,
                "createdBy": {
                    "id": 3,
                    "name": "Alexander"
                },
                "locked": false,
                "tasks": [
                    {
                        "id": 202,
                        "slug": "grass-blade",
                        "moduleId": 13,
                        "name": "Grass - Blade",
                        "order": 0,
                        "cost": 5,
                        "score": 0,
                        "accepted": true,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": 0,
                        "premium": false,
                        "child": {
                            "task": {
                                "id": 202,
                                "slug": "grass-blade",
                                "moduleId": 13,
                                "name": "Grass - Blade",
                                "vertexShader": "attribute int index;\n\nvoid main() {\n  float h = float(index / 2) / 9.0;\n  float sideX = mod(float(index), 2.0) * 2.0 - 1.0;\n  \n  vec3 pos = vec3(sideX * mix(0.05, 0.0, h * h), h, 0.0);\n  \n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n",
                                "fragmentShader": "void main() {\n  gl_FragColor = vec4(0.6, 0.8, 0.2, 1.0);\n}",
                                "postProcessShader": "",
                                "properties": "",
                                "defaultVertexShader": "attribute int index;\n\nvoid main() {\n  vec3 pos = vec3(0.0);\n  \n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n",
                                "defaultFragmentShader": "void main() {\n  gl_FragColor = vec4(0.6, 0.8, 0.2, 1.0);\n}",
                                "defaultPostProcessShader": "",
                                "defaultProperties": "",
                                "vertexCodeEditable": true,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":0,\"y\":0.55,\"z\":1.4},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":45,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":\"16\",\"model\":null,\"meshes\":[{\"name\":\"main\",\"materialId\":0}],\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"materials\":[],\"actions\":[],\"backgroundRGBA\":\"506060\",\"background\":5267552,\"customDepthBufferTexture\":false,\"glslVersion\":1}",
                                "description": "In a mesh consisting of 20 vertices, 9 adjacent rectangles are formed, stacked on top of each other. The height increases every two vertices, so to determine the current height, you need to identify the pair number first and then divide it by the number of rectangles to find the height of the pair.\n\n<br>\n\n![](/files/grass-mesh-axis.png)\n\n<br>\n\nFurthermore, it can be noted that all even vertices are on the left, while odd vertices are on the right. Therefore, the parity of the vertex index can be used to determine the direction of the shift along the X-axis.\n\n<br>\n\nThe width should vary quadratically based on the current height. This means that the width will decrease parabolically from 0.1 at the base to 0 at the top.\n\n<br>\n\nThe formula for calculating the width can look like this:\n```\nwidth = 0.1 * (1.0 - height * height)\n```\n\n### Task \n\nGiven a mesh consisting of 20 vertices, initially all vertices are located at the origin. You need to move the vertices using their index to form a block on the screen with a total height of 1, consisting of 9 equal rectangular segments.\n\n<br>\n\n![](/files/grass-mesh-axis.png)\n\n<br>\n\nThen change the width quadratically based on the current height, starting from 0.1 at the base and decreasing to 0 at the top.",
                                "hints": [],
                                "restrictions": [],
                                "order": 0,
                                "cost": 5,
                                "threshold": 99,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": false,
                                "animationSteps": null,
                                "animationStepTime": null,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": false
                            },
                            "vertexShader": "attribute int index;\n\nvoid main() {\n  float h = float(index / 2) / 9.0;\n  float sideX = mod(float(index), 2.0) * 2.0 - 1.0;\n  \n  vec3 pos = vec3(sideX * mix(0.05, 0.0, h * h), h, 0.0);\n  \n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}",
                            "fragmentShader": "void main() {\n  gl_FragColor = vec4(0.6, 0.8, 0.2, 1.0);\n}",
                            "postProcessShader": "",
                            "properties": "",
                            "defaultVertexShader": "attribute int index;\n\nvoid main() {\n  vec3 pos = vec3(0.0);\n  \n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n",
                            "defaultFragmentShader": "void main() {\n  gl_FragColor = vec4(0.6, 0.8, 0.2, 1.0);\n}",
                            "defaultPostProcessShader": "",
                            "defaultProperties": "",
                            "liked": false,
                            "disliked": false,
                            "accepted": true,
                            "answerViewed": true,
                            "submissions": [
                                {
                                    "score": 5,
                                    "accepted": true,
                                    "vertexShader": "attribute int index;\n\nvoid main() {\n  float h = float(index / 2) / 9.0;\n  float sideX = mod(float(index), 2.0) * 2.0 - 1.0;\n  \n  vec3 pos = vec3(sideX * mix(0.05, 0.0, h * h), h, 0.0);\n  \n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}",
                                    "fragmentShader": "void main() {\n  gl_FragColor = vec4(0.6, 0.8, 0.2, 1.0);\n}",
                                    "postProcessShader": "",
                                    "properties": "",
                                    "at": "2025-03-14T03:11:17.000Z"
                                }
                            ]
                        }
                    },
                    {
                        "id": 203,
                        "slug": "grass-bending",
                        "moduleId": 13,
                        "name": "Grass - Bending",
                        "order": 1,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": false,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 203,
                                "slug": "grass-bending",
                                "moduleId": 13,
                                "name": "Grass - Bending",
                                "vertexShader": "uniform float iTime;\n\nattribute int index;\n\nvec2 bezier(vec2 p0, vec2 p1, vec2 p2, float t) {\n  float u = 1.0 - t;\n  float tt = t * t;\n  float uu = u * u;\n\n  vec2 p = uu * p0;\n  p += 2.0 * u * t * p1;\n  p += tt * p2;\n  \n  return p;\n}\n\nvoid main() {\n  float h = float(index / 2) / 9.0;\n  float sideX = mod(float(index), 2.0) * 2.0 - 1.0;\n  float bend = cos(iTime) * 0.5;\n  \n  vec2 curve = bezier(\n    vec2(0.0, 0.0),\n    vec2(0.0, 0.5),\n    vec2(sin(bend), cos(bend)),\n    h\n  );\n\n  float dw = mix(0.05, 0.0, h * h);\n  vec3 pos = vec3(curve.x + sideX * dw, curve.y, 0.0);\n  \n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n",
                                "fragmentShader": "void main() {\n  gl_FragColor = vec4(0.6, 0.8, 0.2, 1.0);\n}",
                                "postProcessShader": "",
                                "properties": "",
                                "defaultVertexShader": "uniform float iTime;\n\nattribute int index;\n\nvec2 bezier(vec2 p0, vec2 p1, vec2 p2, float t) {\n  float u = 1.0 - t;\n  float tt = t * t;\n  float uu = u * u;\n\n  vec2 p = uu * p0;\n  p += 2.0 * u * t * p1;\n  p += tt * p2;\n  \n  return p;\n}\n\nvoid main() {\n  float h = float(index / 2) / 9.0;\n  float sideX = mod(float(index), 2.0) * 2.0 - 1.0;\n  float bend = cos(iTime) * 0.5;\n  \n  vec2 curve = bezier(\n    vec2(0.0, 0.0),\n    vec2(0.0, 0.5),\n    vec2(sin(bend), cos(bend)),\n    h\n  );\n\n  float dw = mix(0.05, 0.0, h * h);\n  vec3 pos = vec3(sideX * dw, h, 0.0);\n  \n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n",
                                "defaultFragmentShader": "void main() {\n  gl_FragColor = vec4(0.6, 0.8, 0.2, 1.0);\n}",
                                "defaultPostProcessShader": "",
                                "defaultProperties": "",
                                "vertexCodeEditable": true,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":0,\"y\":0.55,\"z\":1.4},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":45,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":\"16\",\"model\":null,\"meshes\":[{\"name\":\"main\",\"materialId\":0}],\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"materials\":[],\"actions\":[],\"backgroundRGBA\":\"506060\",\"background\":5267552,\"customDepthBufferTexture\":false,\"glslVersion\":1}",
                                "description": "Using **Bezier curves** to deform a mesh over time is a powerful method that allows for smooth and controlled animations.\n\n<br>\n\n### Define the Bezier Curve\n\n<br>\n\nA Bezier curve is defined by a set of control points. For simplicity, let's consider a quadratic Bezier curve, which is defined by three control points **P0**, **P1**, and **P2**.\n\n<br>\n\n![](/files/grass-bezier-demo.png)\n\n<br>\n\nThe formula for a quadratic Bezier curve is:\n\n```\nB(t) = (1 − t)^2 * P0 + 2 * (1 − t) * t * P1 + t^2 * P2\n```\n\nwhere **t** ranges from 0 to 1.\n\n<br>\n\nHere you can find more theory: [Bezier Curve](https://javascript.info/bezier-curve).\n\n<br>\n\n### Animate the Curve Over Time\n\n<br>\n\nTo create an animation over time, you can change the positions of the control points **P0**, **P1**, and **P2** based on time. For example, you can make them move according to a sine function or any other function that creates the desired effect.\n\n<br>\n\n### Apply the Curve to the Mesh\n\n<br>\n\nTo deform the mesh, you need to apply the Bezier curve to each vertex of the mesh. This can be done in the vertex shader.\n\n### Task \n\nApply the given Bezier curve to each vertex of the mesh to perform the mesh bending animation.",
                                "hints": [],
                                "restrictions": [],
                                "order": 1,
                                "cost": 5,
                                "threshold": 99,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": true,
                                "animationSteps": 10,
                                "animationStepTime": 200,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "uniform float iTime;\n\nattribute int index;\n\nvec2 bezier(vec2 p0, vec2 p1, vec2 p2, float t) {\n  float u = 1.0 - t;\n  float tt = t * t;\n  float uu = u * u;\n\n  vec2 p = uu * p0;\n  p += 2.0 * u * t * p1;\n  p += tt * p2;\n  \n  return p;\n}\n\nvoid main() {\n  float h = float(index / 2) / 9.0;\n  float sideX = mod(float(index), 2.0) * 2.0 - 1.0;\n  float bend = cos(iTime) * 0.5;\n  \n  vec2 curve = bezier(\n    vec2(0.0, 0.0),\n    vec2(0.0, 0.5),\n    vec2(sin(bend), cos(bend)),\n    h\n  );\n\n  float dw = mix(0.05, 0.0, h * h);\n  vec3 pos = vec3(sideX * dw, h, 0.0);\n  \n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n",
                            "fragmentShader": "void main() {\n  gl_FragColor = vec4(0.6, 0.8, 0.2, 1.0);\n}",
                            "postProcessShader": "",
                            "properties": "",
                            "defaultVertexShader": "uniform float iTime;\n\nattribute int index;\n\nvec2 bezier(vec2 p0, vec2 p1, vec2 p2, float t) {\n  float u = 1.0 - t;\n  float tt = t * t;\n  float uu = u * u;\n\n  vec2 p = uu * p0;\n  p += 2.0 * u * t * p1;\n  p += tt * p2;\n  \n  return p;\n}\n\nvoid main() {\n  float h = float(index / 2) / 9.0;\n  float sideX = mod(float(index), 2.0) * 2.0 - 1.0;\n  float bend = cos(iTime) * 0.5;\n  \n  vec2 curve = bezier(\n    vec2(0.0, 0.0),\n    vec2(0.0, 0.5),\n    vec2(sin(bend), cos(bend)),\n    h\n  );\n\n  float dw = mix(0.05, 0.0, h * h);\n  vec3 pos = vec3(sideX * dw, h, 0.0);\n  \n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n",
                            "defaultFragmentShader": "void main() {\n  gl_FragColor = vec4(0.6, 0.8, 0.2, 1.0);\n}",
                            "defaultPostProcessShader": "",
                            "defaultProperties": "",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 204,
                        "slug": "grass-3d-blade",
                        "moduleId": 13,
                        "name": "Grass - 3D Blade",
                        "order": 2,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": true,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 204,
                                "slug": "grass-3d-blade",
                                "moduleId": 13,
                                "name": "Grass - 3D Blade",
                                "vertexShader": "uniform float iTime;\n\nattribute int index;\n\nvec3 bezier3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    float tt = t * t;\n    float uu = u * u;\n\n    vec3 p = uu * p0;\n    p += 2.0 * u * t * p1;\n    p += tt * p2;\n\n    return p;\n}\n\nvoid main() {\n  int   localIndex = index % 20;\n  float h = float(localIndex / 2) / 9.0;\n  float sideX = mod(float(localIndex), 2.0) * 2.0 - 1.0;\n  float bend = sin(iTime) * 1.5;\n  \n  vec3 curve = bezier3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.5, 0.0),\n    vec3(0.0, cos(bend), sin(bend)),\n    h\n  );\n\n  float dw = mix(0.1, 0.0, h * h);\n  vec3 pos = curve + vec3(sideX * dw, 0.0, 0.0);\n  \n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n",
                                "fragmentShader": "void main() {\n  gl_FragColor = vec4(0.6, 0.8, 0.2, 1.0);\n}",
                                "postProcessShader": "",
                                "properties": "",
                                "defaultVertexShader": "uniform float iTime;\n\nattribute int index;\n\nvec3 bezier3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    float tt = t * t;\n    float uu = u * u;\n\n    vec3 p = uu * p0;\n    p += 2.0 * u * t * p1;\n    p += tt * p2;\n\n    return p;\n}\n\nvoid main() {\n  float h = float(index / 2) / 9.0;\n  float sideX = mod(float(index), 2.0) * 2.0 - 1.0;\n  float bend = sin(iTime) * 1.5;\n  \n  vec3 curve = bezier3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.5, 0.0),\n    vec3(0.0, cos(bend), sin(bend)),\n    h\n  );\n\n  float dw = mix(0.1, 0.0, h * h);\n  vec3 pos = vec3(sideX * dw, h, 0.0);\n  \n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n",
                                "defaultFragmentShader": "void main() {\n  gl_FragColor = vec4(0.6, 0.8, 0.2, 1.0);\n}",
                                "defaultPostProcessShader": "",
                                "defaultProperties": "",
                                "vertexCodeEditable": true,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":1.45,\"y\":0.55,\"z\":0.9},\"rotation\":{\"x\":0,\"y\":1,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":45,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":\"15\",\"model\":null,\"meshes\":[{\"name\":\"main\",\"materialId\":0}],\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"materials\":[],\"actions\":[],\"backgroundRGBA\":\"506060\",\"background\":5267552,\"customDepthBufferTexture\":false,\"glslVersion\":1}",
                                "description": "In 3D space, we need the grass blade to be two-sided so that it doesn't disappear when viewed from the other side. To achieve this, we need to double the number of vertices per blade, and reverse the clock ordering of the back part in the index buffer:\n\n<br>\n\n![](/files/grass-mesh-double-sided.png)\n\n<br>\n\nThe Bezier function works the same for both two-dimensional and three-dimensional points. The main difference is that in three-dimensional space, an additional coordinate **z** is added, which allows describing curves in three dimensions. Otherwise, the mathematical principles and algorithms remain the same.\n\n### Task \n\nIn this task, you need to fix the drawing of the blade of grass, ensuring that its back part is also drawn. We are going to use 20 vertices for the front side and 20 vertices for the back. Additionally, apply the Bezier curve to the mesh to perform the bending animation.",
                                "hints": [],
                                "restrictions": [],
                                "order": 2,
                                "cost": 5,
                                "threshold": 99,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": true,
                                "animationSteps": 10,
                                "animationStepTime": 200,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "uniform float iTime;\n\nattribute int index;\n\nvec3 bezier3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    float tt = t * t;\n    float uu = u * u;\n\n    vec3 p = uu * p0;\n    p += 2.0 * u * t * p1;\n    p += tt * p2;\n\n    return p;\n}\n\nvoid main() {\n  float h = float(index / 2) / 9.0;\n  float sideX = mod(float(index), 2.0) * 2.0 - 1.0;\n  float bend = sin(iTime) * 1.5;\n  \n  vec3 curve = bezier3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.5, 0.0),\n    vec3(0.0, cos(bend), sin(bend)),\n    h\n  );\n\n  float dw = mix(0.1, 0.0, h * h);\n  vec3 pos = vec3(sideX * dw, h, 0.0);\n  \n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n",
                            "fragmentShader": "void main() {\n  gl_FragColor = vec4(0.6, 0.8, 0.2, 1.0);\n}",
                            "postProcessShader": "",
                            "properties": "",
                            "defaultVertexShader": "uniform float iTime;\n\nattribute int index;\n\nvec3 bezier3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    float tt = t * t;\n    float uu = u * u;\n\n    vec3 p = uu * p0;\n    p += 2.0 * u * t * p1;\n    p += tt * p2;\n\n    return p;\n}\n\nvoid main() {\n  float h = float(index / 2) / 9.0;\n  float sideX = mod(float(index), 2.0) * 2.0 - 1.0;\n  float bend = sin(iTime) * 1.5;\n  \n  vec3 curve = bezier3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.5, 0.0),\n    vec3(0.0, cos(bend), sin(bend)),\n    h\n  );\n\n  float dw = mix(0.1, 0.0, h * h);\n  vec3 pos = vec3(sideX * dw, h, 0.0);\n  \n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n",
                            "defaultFragmentShader": "void main() {\n  gl_FragColor = vec4(0.6, 0.8, 0.2, 1.0);\n}",
                            "defaultPostProcessShader": "",
                            "defaultProperties": "",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 205,
                        "slug": "grass-more-blades",
                        "moduleId": 13,
                        "name": "Grass - More Blades",
                        "order": 3,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": true,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 205,
                                "slug": "grass-more-blades",
                                "moduleId": 13,
                                "name": "Grass - More Blades",
                                "vertexShader": "uniform float iTime;\n\nattribute int index;\n\nvec3 bezier3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    float tt = t * t;\n    float uu = u * u;\n\n    vec3 p = uu * p0;\n    p += 2.0 * u * t * p1;\n    p += tt * p2;\n\n    return p;\n}\n\nvec2 random2(vec2 st){\n  float d1 = dot(st, vec2(12.3, 32.1));\n  float d2 = dot(st, vec2(45.6, 65.4));\n  \n  st = vec2(d1, d2);\n  return fract(sin(st) * 78.9) * 2.0 - 1.0;\n}\n\nfloat random(float x) {\n  float r = fract(sin(x * 12.34) * 1234.5678);\n  return r * 2.0 - 1.0;\n}\n\nmat3 rotationYMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      vec3(cosAngle, 0, -sinAngle),\n      vec3(0, 1, 0),\n      vec3(sinAngle, 0, cosAngle)\n    );\n}\n\nvoid main() {\n  int   instance = index / 40;\n  float instanceHash = random(float(instance));\n  int   localIndex = index % 20;\n  float h = float(localIndex / 2) / 9.0;\n  float sideX = mod(float(localIndex), 2.0) * 2.0 - 1.0;\n  float bend = sin(iTime + instanceHash * 3.14) * 0.2;\n  vec2  worldPos = random2(vec2(instance)) * 3.0;\n  mat3  rotateY  = rotationYMatrix(instanceHash * 3.14);\n  \n  vec3 curve = bezier3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.5, 0.0),\n    vec3(0.0, cos(bend), sin(bend)),\n    h\n  );\n\n  vec3 pos = curve + vec3(sideX * mix(0.05, 0.0, h * h), 0.0, 0.0);\n  pos = rotateY * pos;\n  pos += vec3(worldPos.x, 0.0, worldPos.y);\n  \n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n",
                                "fragmentShader": "void main() {\n  gl_FragColor = vec4(0.6, 0.8, 0.2, 1.0);\n}",
                                "postProcessShader": "",
                                "properties": "",
                                "defaultVertexShader": "uniform float iTime;\n\nattribute int index;\n\nvec3 bezier3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    float tt = t * t;\n    float uu = u * u;\n\n    vec3 p = uu * p0;\n    p += 2.0 * u * t * p1;\n    p += tt * p2;\n\n    return p;\n}\n\nvec2 random2(vec2 st){\n  float d1 = dot(st, vec2(12.3, 32.1));\n  float d2 = dot(st, vec2(45.6, 65.4));\n  \n  st = vec2(d1, d2);\n  return fract(sin(st) * 78.9) * 2.0 - 1.0;\n}\n\nfloat random(float x) {\n  float r = fract(sin(x * 12.34) * 1234.5678);\n  return r * 2.0 - 1.0;\n}\n\nmat3 rotationYMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      vec3(cosAngle, 0, -sinAngle),\n      vec3(0, 1, 0),\n      vec3(sinAngle, 0, cosAngle)\n    );\n}\n\nvoid main() {\n  int   localIndex = index % 20;\n  float h = float(localIndex / 2) / 9.0;\n  float sideX = mod(float(localIndex), 2.0) * 2.0 - 1.0;\n  float bend = sin(iTime) * 0.2;\n  \n  vec3 curve = bezier3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.5, 0.0),\n    vec3(0.0, cos(bend), sin(bend)),\n    h\n  );\n\n  vec3 pos = curve + vec3(sideX * mix(0.05, 0.0, h * h), 0.0, 0.0);\n  \n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n",
                                "defaultFragmentShader": "void main() {\n  gl_FragColor = vec4(0.6, 0.8, 0.2, 1.0);\n}",
                                "defaultPostProcessShader": "",
                                "defaultProperties": "",
                                "vertexCodeEditable": true,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":3,\"y\":4,\"z\":4},\"rotation\":{\"x\":-0.75,\"y\":0.7,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":45,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":\"17\",\"model\":null,\"meshes\":[{\"name\":\"main\",\"materialId\":0}],\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"materials\":[],\"actions\":[],\"backgroundRGBA\":\"506060\",\"background\":5267552,\"customDepthBufferTexture\":false,\"glslVersion\":1}",
                                "description": "To increase the number of grass blades, we need to extend our vertex buffer for one grass blade of size **N** by the number of grass blades **K** we plan to draw.\n\n<br>\n\nBy knowing the number of vertices **N** used for one blade, we can use the vertex index to determine the blade instance index:\n\n```\nInstanceIndex = VertexIndex / N\n```\n\nThis instance index will be the same for all vertices of that blade, allowing us to apply a common transformation to its vertices.\n\n<br>\n\nTo determine the local index number of a vertex within a single blade instance, we take the global vertex index value modulo the number of vertices in one instance **N**:\n\n```\nInstanceVertexIndex = VertexIndex % N\n```\n\nWe can use this local vertex index to draw the blade the old way.\n\n### Task \n\nThe grass buffer has been extended by N times. One blade uses 40 vertices (20 for the front side and 20 for the back side). Determine the instance index of the blade and use it as an argument to the `random` and `random2` functions to set:\n\n1. random position of the blade within [-3.0; 3.0];\n2. random rotation in [-3.14, 3.14] around the Y axis;\n3. random bending phase shift in [-3.14, 3.14].\n\nUse the `rotationYMatrix` function to get the rotation matrix. Draw all grass blades.",
                                "hints": [],
                                "restrictions": [],
                                "order": 3,
                                "cost": 5,
                                "threshold": 99,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": true,
                                "animationSteps": 10,
                                "animationStepTime": 200,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "uniform float iTime;\n\nattribute int index;\n\nvec3 bezier3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    float tt = t * t;\n    float uu = u * u;\n\n    vec3 p = uu * p0;\n    p += 2.0 * u * t * p1;\n    p += tt * p2;\n\n    return p;\n}\n\nvec2 random2(vec2 st){\n  float d1 = dot(st, vec2(12.3, 32.1));\n  float d2 = dot(st, vec2(45.6, 65.4));\n  \n  st = vec2(d1, d2);\n  return fract(sin(st) * 78.9) * 2.0 - 1.0;\n}\n\nfloat random(float x) {\n  float r = fract(sin(x * 12.34) * 1234.5678);\n  return r * 2.0 - 1.0;\n}\n\nmat3 rotationYMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      vec3(cosAngle, 0, -sinAngle),\n      vec3(0, 1, 0),\n      vec3(sinAngle, 0, cosAngle)\n    );\n}\n\nvoid main() {\n  int   localIndex = index % 20;\n  float h = float(localIndex / 2) / 9.0;\n  float sideX = mod(float(localIndex), 2.0) * 2.0 - 1.0;\n  float bend = sin(iTime) * 0.2;\n  \n  vec3 curve = bezier3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.5, 0.0),\n    vec3(0.0, cos(bend), sin(bend)),\n    h\n  );\n\n  vec3 pos = curve + vec3(sideX * mix(0.05, 0.0, h * h), 0.0, 0.0);\n  \n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n",
                            "fragmentShader": "void main() {\n  gl_FragColor = vec4(0.6, 0.8, 0.2, 1.0);\n}",
                            "postProcessShader": "",
                            "properties": "",
                            "defaultVertexShader": "uniform float iTime;\n\nattribute int index;\n\nvec3 bezier3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    float tt = t * t;\n    float uu = u * u;\n\n    vec3 p = uu * p0;\n    p += 2.0 * u * t * p1;\n    p += tt * p2;\n\n    return p;\n}\n\nvec2 random2(vec2 st){\n  float d1 = dot(st, vec2(12.3, 32.1));\n  float d2 = dot(st, vec2(45.6, 65.4));\n  \n  st = vec2(d1, d2);\n  return fract(sin(st) * 78.9) * 2.0 - 1.0;\n}\n\nfloat random(float x) {\n  float r = fract(sin(x * 12.34) * 1234.5678);\n  return r * 2.0 - 1.0;\n}\n\nmat3 rotationYMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      vec3(cosAngle, 0, -sinAngle),\n      vec3(0, 1, 0),\n      vec3(sinAngle, 0, cosAngle)\n    );\n}\n\nvoid main() {\n  int   localIndex = index % 20;\n  float h = float(localIndex / 2) / 9.0;\n  float sideX = mod(float(localIndex), 2.0) * 2.0 - 1.0;\n  float bend = sin(iTime) * 0.2;\n  \n  vec3 curve = bezier3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.5, 0.0),\n    vec3(0.0, cos(bend), sin(bend)),\n    h\n  );\n\n  vec3 pos = curve + vec3(sideX * mix(0.05, 0.0, h * h), 0.0, 0.0);\n  \n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n",
                            "defaultFragmentShader": "void main() {\n  gl_FragColor = vec4(0.6, 0.8, 0.2, 1.0);\n}",
                            "defaultPostProcessShader": "",
                            "defaultProperties": "",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 206,
                        "slug": "grass-color",
                        "moduleId": 13,
                        "name": "Grass - Color",
                        "order": 4,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": true,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 206,
                                "slug": "grass-color",
                                "moduleId": 13,
                                "name": "Grass - Color",
                                "vertexShader": "uniform float iTime;\n\nattribute int index;\n\nout float vH;\nout float vX;\nout float vRand;\n\nvec3 bezier3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    float tt = t * t;\n    float uu = u * u;\n\n    vec3 p = uu * p0;\n    p += 2.0 * u * t * p1;\n    p += tt * p2;\n\n    return p;\n}\n\nvec2 random2(vec2 st){\n  float d1 = dot(st, vec2(12.3, 32.1));\n  float d2 = dot(st, vec2(45.6, 65.4));\n  \n  st = vec2(d1, d2);\n  return fract(sin(st) * 78.9) * 2.0 - 1.0;\n}\n\nfloat random(float x) {\n  float r = fract(sin(x * 12.34) * 1234.5678);\n  return r * 2.0 - 1.0;\n}\n\nmat3 rotationYMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      vec3(cosAngle, 0, -sinAngle),\n      vec3(0, 1, 0),\n      vec3(sinAngle, 0, cosAngle)\n    );\n}\n\nvoid main() {\n  int   instance = index / 40;\n  float instanceHash = random(float(instance));\n  int   localIndex = index % 20;\n  float h = float(localIndex / 2) / 9.0;\n  float sideX = mod(float(localIndex), 2.0) * 2.0 - 1.0;\n  float bend = sin(iTime + instanceHash * 3.14) * 0.3;\n  vec2  worldPos = random2(vec2(instance)) * 3.0;\n  mat3  rotateY = rotationYMatrix(instanceHash * 3.14);\n  \n  vec3 curve = bezier3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.5, 0.0),\n    vec3(0.0, cos(bend), sin(bend)),\n    h\n  );\n\n  vec3 pos = curve;\n  pos.x += sideX * mix(0.05, 0.0, h * h);\n  pos = rotateY * pos;\n  pos += vec3(worldPos.x, 0.0, worldPos.y);\n\n  vH = h;\n  vX = sideX;\n  vRand = instanceHash;\n  \n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n",
                                "fragmentShader": "in float vH;\nin float vX;\nin float vRand;\n\nvoid main() {\n  vec3 color = mix(vec3(0.6, 0.8, 0.0), vec3(0.8, 0.9, 0.3), vRand * 0.5 + 0.5);\n  color = mix(vec3(0.1, 0.2, 0.0), color, vH);\n  color *= mix(0.8, 1.0, vX * vX);\n  \n  gl_FragColor = vec4(color, 1.0);\n}\n",
                                "postProcessShader": "",
                                "properties": "",
                                "defaultVertexShader": "uniform float iTime;\n\nattribute int index;\n\nvec3 bezier3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    float tt = t * t;\n    float uu = u * u;\n\n    vec3 p = uu * p0;\n    p += 2.0 * u * t * p1;\n    p += tt * p2;\n\n    return p;\n}\n\nvec2 random2(vec2 st){\n  float d1 = dot(st, vec2(12.3, 32.1));\n  float d2 = dot(st, vec2(45.6, 65.4));\n  \n  st = vec2(d1, d2);\n  return fract(sin(st) * 78.9) * 2.0 - 1.0;\n}\n\nfloat random(float x) {\n  float r = fract(sin(x * 12.34) * 1234.5678);\n  return r * 2.0 - 1.0;\n}\n\nmat3 rotationYMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      vec3(cosAngle, 0, -sinAngle),\n      vec3(0, 1, 0),\n      vec3(sinAngle, 0, cosAngle)\n    );\n}\n\nvoid main() {\n  int   instance = index / 40;\n  float instanceHash = random(float(instance));\n  int   localIndex = index % 20;\n  float h = float(localIndex / 2) / 9.0;\n  float sideX = mod(float(localIndex), 2.0) * 2.0 - 1.0;\n  float bend = sin(iTime + instanceHash * 3.14) * 0.3;\n  vec2  worldPos = random2(vec2(instance)) * 3.0;\n  mat3  rotateY = rotationYMatrix(instanceHash * 3.14);\n  \n  vec3 curve = bezier3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.5, 0.0),\n    vec3(0.0, cos(bend), sin(bend)),\n    h\n  );\n\n  vec3 pos = curve;\n  pos.x += sideX * mix(0.05, 0.0, h * h);\n  pos = rotateY * pos;\n  pos += vec3(worldPos.x, 0.0, worldPos.y);\n\n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n",
                                "defaultFragmentShader": "void main() {\n  gl_FragColor = vec4(0.6, 0.8, 0.2, 1.0);\n}",
                                "defaultPostProcessShader": "",
                                "defaultProperties": "",
                                "vertexCodeEditable": true,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":3,\"y\":4,\"z\":4},\"rotation\":{\"x\":-0.75,\"y\":0.7,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":45,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":\"17\",\"model\":null,\"meshes\":[{\"name\":\"main\",\"materialId\":0}],\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"materials\":[],\"actions\":[],\"backgroundRGBA\":\"506060\",\"background\":5267552,\"customDepthBufferTexture\":false,\"glslVersion\":1}",
                                "description": "### Random Color Blending\n\n<br>\n\nTo give grass blades a more natural look, you can use random color blending. Each instance of a grass blade is assigned a random value based on its instance index. This value is used to blend the base color of the blade with an additional color.\n\n<br>\n\n### Shading the Base Color\n\n<br>\n\nGrass blades are usually darker at the base because less light reaches there. To account for this, you can shade the color closer to the base of the blade. For example:\n```\nbladeColor = mix(bladeBase, bladeColor, heightFactor);\n```\n\n### Adding Volume\n\n<br>\n\nTo give the grass blade volume, you can use linear interpolation to shade or lighten the color closer to the blade center. Example formula:\n```\nfloat innerFactor = 0.8; // coefficient for the center\nfloat outerFactor = 1.0; // coefficient for the edges\n\nbladeColor *= mix(innerFactor, outerFactor, distanceToBladeCenter ^ 2);\n```\nwhere distanceToBladeCenter is in the range [-1.0, 1.0].\n\n### Task \n\nEnhance grass rendering with color:\n\n1. blend the blade color between `(0.6, 0.8, 0.0)` and `(0.8, 0.9, 0.3)` using the `instanceHash` value;\n2. linearly blend the blade color with `(0.1, 0.2, 0.0)` based on the distance to the base of the blade;\n3. darken the color of the grass blade closer to the center quadratically so that the center color is 20% darker than the edges.",
                                "hints": [],
                                "restrictions": [],
                                "order": 4,
                                "cost": 5,
                                "threshold": 99,
                                "likes": 1,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": true,
                                "animationSteps": 10,
                                "animationStepTime": 200,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "uniform float iTime;\n\nattribute int index;\n\nvec3 bezier3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    float tt = t * t;\n    float uu = u * u;\n\n    vec3 p = uu * p0;\n    p += 2.0 * u * t * p1;\n    p += tt * p2;\n\n    return p;\n}\n\nvec2 random2(vec2 st){\n  float d1 = dot(st, vec2(12.3, 32.1));\n  float d2 = dot(st, vec2(45.6, 65.4));\n  \n  st = vec2(d1, d2);\n  return fract(sin(st) * 78.9) * 2.0 - 1.0;\n}\n\nfloat random(float x) {\n  float r = fract(sin(x * 12.34) * 1234.5678);\n  return r * 2.0 - 1.0;\n}\n\nmat3 rotationYMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      vec3(cosAngle, 0, -sinAngle),\n      vec3(0, 1, 0),\n      vec3(sinAngle, 0, cosAngle)\n    );\n}\n\nvoid main() {\n  int   instance = index / 40;\n  float instanceHash = random(float(instance));\n  int   localIndex = index % 20;\n  float h = float(localIndex / 2) / 9.0;\n  float sideX = mod(float(localIndex), 2.0) * 2.0 - 1.0;\n  float bend = sin(iTime + instanceHash * 3.14) * 0.3;\n  vec2  worldPos = random2(vec2(instance)) * 3.0;\n  mat3  rotateY = rotationYMatrix(instanceHash * 3.14);\n  \n  vec3 curve = bezier3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.5, 0.0),\n    vec3(0.0, cos(bend), sin(bend)),\n    h\n  );\n\n  vec3 pos = curve;\n  pos.x += sideX * mix(0.05, 0.0, h * h);\n  pos = rotateY * pos;\n  pos += vec3(worldPos.x, 0.0, worldPos.y);\n\n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n",
                            "fragmentShader": "void main() {\n  gl_FragColor = vec4(0.6, 0.8, 0.2, 1.0);\n}",
                            "postProcessShader": "",
                            "properties": "",
                            "defaultVertexShader": "uniform float iTime;\n\nattribute int index;\n\nvec3 bezier3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    float tt = t * t;\n    float uu = u * u;\n\n    vec3 p = uu * p0;\n    p += 2.0 * u * t * p1;\n    p += tt * p2;\n\n    return p;\n}\n\nvec2 random2(vec2 st){\n  float d1 = dot(st, vec2(12.3, 32.1));\n  float d2 = dot(st, vec2(45.6, 65.4));\n  \n  st = vec2(d1, d2);\n  return fract(sin(st) * 78.9) * 2.0 - 1.0;\n}\n\nfloat random(float x) {\n  float r = fract(sin(x * 12.34) * 1234.5678);\n  return r * 2.0 - 1.0;\n}\n\nmat3 rotationYMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      vec3(cosAngle, 0, -sinAngle),\n      vec3(0, 1, 0),\n      vec3(sinAngle, 0, cosAngle)\n    );\n}\n\nvoid main() {\n  int   instance = index / 40;\n  float instanceHash = random(float(instance));\n  int   localIndex = index % 20;\n  float h = float(localIndex / 2) / 9.0;\n  float sideX = mod(float(localIndex), 2.0) * 2.0 - 1.0;\n  float bend = sin(iTime + instanceHash * 3.14) * 0.3;\n  vec2  worldPos = random2(vec2(instance)) * 3.0;\n  mat3  rotateY = rotationYMatrix(instanceHash * 3.14);\n  \n  vec3 curve = bezier3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.5, 0.0),\n    vec3(0.0, cos(bend), sin(bend)),\n    h\n  );\n\n  vec3 pos = curve;\n  pos.x += sideX * mix(0.05, 0.0, h * h);\n  pos = rotateY * pos;\n  pos += vec3(worldPos.x, 0.0, worldPos.y);\n\n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n",
                            "defaultFragmentShader": "void main() {\n  gl_FragColor = vec4(0.6, 0.8, 0.2, 1.0);\n}",
                            "defaultPostProcessShader": "",
                            "defaultProperties": "",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 207,
                        "slug": "grass-wind",
                        "moduleId": 13,
                        "name": "Grass - Wind",
                        "order": 5,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": true,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 207,
                                "slug": "grass-wind",
                                "moduleId": 13,
                                "name": "Grass - Wind",
                                "vertexShader": "uniform float iTime;\n\nattribute int index;\n\nout float vH;\nout float vX;\n\nvec3 bezier3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    float tt = t * t;\n    float uu = u * u;\n\n    vec3 p = uu * p0;\n    p += 2.0 * u * t * p1;\n    p += tt * p2;\n\n    return p;\n}\n\nvec2 random2(vec2 st){\n  float d1 = dot(st, vec2(12.3, 32.1));\n  float d2 = dot(st, vec2(45.6, 65.4));\n  \n  st = vec2(d1, d2);\n  return fract(sin(st) * 78.9) * 2.0 - 1.0;\n}\n\nfloat random(float x) {\n  float r = fract(sin(x * 12.34) * 1234.5678);\n  return r * 2.0 - 1.0;\n}\n\nmat3 rotationYMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      vec3(cosAngle, 0, -sinAngle),\n      vec3(0, 1, 0),\n      vec3(sinAngle, 0, cosAngle)\n    );\n}\n\nmat3 rotationXMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      1.0, 0, 0,\n      0, cosAngle, sinAngle,\n      0, -sinAngle, cosAngle\n    );\n}\n\nvoid main() {\n  int   instance = index / 40;\n  float instanceHash = random(float(instance));\n  int   localIndex = index % 20;\n  float h = float(localIndex / 2) / 9.0;\n  float sideX = mod(float(localIndex), 2.0) * 2.0 - 1.0;\n  float bend = sin(iTime + instanceHash * 3.14) * 0.2;\n  mat3  rotateY = rotationYMatrix(instanceHash * 3.14);\n  vec2  worldPos = random2(vec2(instance)) * 3.0;\n\n  float windStength = sin(worldPos.y * 0.5 + iTime * 2.0) * h;\n  mat3  windRot = rotationXMatrix(windStength);\n  \n  vec3 curve = bezier3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.5, 0.0),\n    vec3(0.0, cos(bend), sin(bend)),\n    h\n  );\n\n  vec3 pos = curve;\n  pos.x += sideX * mix(0.05, 0.0, h * h);\n  pos = windRot * rotateY * pos;\n  pos += vec3(worldPos.x, 0.0, worldPos.y);\n\n  vH = h;\n  vX = sideX;\n  \n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n",
                                "fragmentShader": "in float vH;\nin float vX;\n\nvoid main() {\n  vec3 color = mix(vec3(0.1, 0.2, 0.0), vec3(0.6, 0.8, 0.2), vH);\n  color *= 0.9 + vX * vX * 0.1;\n  \n  gl_FragColor = vec4(color, 1.0);\n}",
                                "postProcessShader": "",
                                "properties": "",
                                "defaultVertexShader": "uniform float iTime;\n\nattribute int index;\n\nout float vH;\nout float vX;\n\nvec3 bezier3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    float tt = t * t;\n    float uu = u * u;\n\n    vec3 p = uu * p0;\n    p += 2.0 * u * t * p1;\n    p += tt * p2;\n\n    return p;\n}\n\nvec2 random2(vec2 st){\n  float d1 = dot(st, vec2(12.3, 32.1));\n  float d2 = dot(st, vec2(45.6, 65.4));\n  \n  st = vec2(d1, d2);\n  return fract(sin(st) * 78.9) * 2.0 - 1.0;\n}\n\nfloat random(float x) {\n  float r = fract(sin(x * 12.34) * 1234.5678);\n  return r * 2.0 - 1.0;\n}\n\nmat3 rotationYMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      vec3(cosAngle, 0, -sinAngle),\n      vec3(0, 1, 0),\n      vec3(sinAngle, 0, cosAngle)\n    );\n}\n\nmat3 rotationXMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      1.0, 0, 0,\n      0, cosAngle, sinAngle,\n      0, -sinAngle, cosAngle\n    );\n}\n\nvoid main() {\n  int   instance = index / 40;\n  float instanceHash = random(float(instance));\n  int   localIndex = index % 20;\n  float h = float(localIndex / 2) / 9.0;\n  float sideX = mod(float(localIndex), 2.0) * 2.0 - 1.0;\n  float bend = sin(iTime + instanceHash * 3.14) * 0.2;\n  mat3  rotateY = rotationYMatrix(instanceHash * 3.14);\n  vec2  worldPos = random2(vec2(instance)) * 3.0;\n\n  float windStength = sin(worldPos.y * 0.5 + iTime * 2.0);\n  \n  vec3 curve = bezier3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.5, 0.0),\n    vec3(0.0, cos(bend), sin(bend)),\n    h\n  );\n\n  vec3 pos = curve;\n  pos.x += sideX * mix(0.05, 0.0, h * h);\n  pos = rotateY * pos;\n  pos += vec3(worldPos.x, 0.0, worldPos.y);\n\n  vH = h;\n  vX = sideX;\n  \n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n",
                                "defaultFragmentShader": "in float vH;\nin float vX;\n\nvoid main() {\n  vec3 color = mix(vec3(0.1, 0.2, 0.0), vec3(0.6, 0.8, 0.2), vH);\n  color *= 0.9 + vX * vX * 0.1;\n  \n  gl_FragColor = vec4(color, 1.0);\n}",
                                "defaultPostProcessShader": "",
                                "defaultProperties": "",
                                "vertexCodeEditable": true,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":3,\"y\":4,\"z\":4},\"rotation\":{\"x\":-0.75,\"y\":0.7,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":45,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":\"17\",\"model\":null,\"meshes\":[{\"name\":\"main\",\"materialId\":0}],\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"materials\":[],\"actions\":[],\"backgroundRGBA\":\"506060\",\"background\":5267552,\"customDepthBufferTexture\":false,\"glslVersion\":1}",
                                "description": "To simulate the wind effect on grass blades, we can use a rotation matrix because it is relatively simple and effective. The rotation matrix allows easy control of the angle and strength of the rotation, making this method convenient for implementation and calculations:\n\n```\nbladePos = windRotationMatrix * bladePos\n```\n\nIf the base of the blade is at position `(0, 0, 0)`, the rotation matrix will naturally have no effect at the base, as the rotation will be zero. However, reducing the rotation strength along the height of the blade can be useful for creating a smoother and more realistic wind effect, especially if the base is not exactly at `(0, 0, 0)` or if you want more detailed control over the blade's movement:\n\n```\nangle *= bladeHeightFactor;\n\n// Rotation matrix around the X-axis\n                 | 1   0          0           | \nrotationMatrix = | 0   cos(angle) -sin(angle) |\n                 | 0   sin(angle) cos(angle)  |\n```\n\nRotation angle can also be controlled by a function based on time and the grass position in the world. This helps simulate wind movement across the field, making the animation more dynamic and realistic:\n\n```\nangle *= sin(worldPos.y + iTime);\n```\n\nRotation matrix helps control the angle and strength of the movement, making it look like the wind is blowing. However, if you need more precise and realistic simulation, you might consider using Bezier curves.\n\n### Task \n\nUse the `windStrength` value to simulate the wind effect on grass blades. The `windStrength` should control the angle of the blade's movement along the X-axis, making it look like the wind is blowing. The rotation strength should decrease as it gets closer to the base of the blade, so the top part of the blade sways in the wind while the bottom remains stationary.\n\n<br>\n\nYou can use `rotationXMatrix` function to get the rotation matrix.",
                                "hints": [],
                                "restrictions": [],
                                "order": 5,
                                "cost": 5,
                                "threshold": 99,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": true,
                                "animationSteps": 10,
                                "animationStepTime": 200,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "uniform float iTime;\n\nattribute int index;\n\nout float vH;\nout float vX;\n\nvec3 bezier3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    float tt = t * t;\n    float uu = u * u;\n\n    vec3 p = uu * p0;\n    p += 2.0 * u * t * p1;\n    p += tt * p2;\n\n    return p;\n}\n\nvec2 random2(vec2 st){\n  float d1 = dot(st, vec2(12.3, 32.1));\n  float d2 = dot(st, vec2(45.6, 65.4));\n  \n  st = vec2(d1, d2);\n  return fract(sin(st) * 78.9) * 2.0 - 1.0;\n}\n\nfloat random(float x) {\n  float r = fract(sin(x * 12.34) * 1234.5678);\n  return r * 2.0 - 1.0;\n}\n\nmat3 rotationYMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      vec3(cosAngle, 0, -sinAngle),\n      vec3(0, 1, 0),\n      vec3(sinAngle, 0, cosAngle)\n    );\n}\n\nmat3 rotationXMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      1.0, 0, 0,\n      0, cosAngle, sinAngle,\n      0, -sinAngle, cosAngle\n    );\n}\n\nvoid main() {\n  int   instance = index / 40;\n  float instanceHash = random(float(instance));\n  int   localIndex = index % 20;\n  float h = float(localIndex / 2) / 9.0;\n  float sideX = mod(float(localIndex), 2.0) * 2.0 - 1.0;\n  float bend = sin(iTime + instanceHash * 3.14) * 0.2;\n  mat3  rotateY = rotationYMatrix(instanceHash * 3.14);\n  vec2  worldPos = random2(vec2(instance)) * 3.0;\n\n  float windStength = sin(worldPos.y * 0.5 + iTime * 2.0);\n  \n  vec3 curve = bezier3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.5, 0.0),\n    vec3(0.0, cos(bend), sin(bend)),\n    h\n  );\n\n  vec3 pos = curve;\n  pos.x += sideX * mix(0.05, 0.0, h * h);\n  pos = rotateY * pos;\n  pos += vec3(worldPos.x, 0.0, worldPos.y);\n\n  vH = h;\n  vX = sideX;\n  \n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n",
                            "fragmentShader": "in float vH;\nin float vX;\n\nvoid main() {\n  vec3 color = mix(vec3(0.1, 0.2, 0.0), vec3(0.6, 0.8, 0.2), vH);\n  color *= 0.9 + vX * vX * 0.1;\n  \n  gl_FragColor = vec4(color, 1.0);\n}",
                            "postProcessShader": "",
                            "properties": "",
                            "defaultVertexShader": "uniform float iTime;\n\nattribute int index;\n\nout float vH;\nout float vX;\n\nvec3 bezier3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    float tt = t * t;\n    float uu = u * u;\n\n    vec3 p = uu * p0;\n    p += 2.0 * u * t * p1;\n    p += tt * p2;\n\n    return p;\n}\n\nvec2 random2(vec2 st){\n  float d1 = dot(st, vec2(12.3, 32.1));\n  float d2 = dot(st, vec2(45.6, 65.4));\n  \n  st = vec2(d1, d2);\n  return fract(sin(st) * 78.9) * 2.0 - 1.0;\n}\n\nfloat random(float x) {\n  float r = fract(sin(x * 12.34) * 1234.5678);\n  return r * 2.0 - 1.0;\n}\n\nmat3 rotationYMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      vec3(cosAngle, 0, -sinAngle),\n      vec3(0, 1, 0),\n      vec3(sinAngle, 0, cosAngle)\n    );\n}\n\nmat3 rotationXMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      1.0, 0, 0,\n      0, cosAngle, sinAngle,\n      0, -sinAngle, cosAngle\n    );\n}\n\nvoid main() {\n  int   instance = index / 40;\n  float instanceHash = random(float(instance));\n  int   localIndex = index % 20;\n  float h = float(localIndex / 2) / 9.0;\n  float sideX = mod(float(localIndex), 2.0) * 2.0 - 1.0;\n  float bend = sin(iTime + instanceHash * 3.14) * 0.2;\n  mat3  rotateY = rotationYMatrix(instanceHash * 3.14);\n  vec2  worldPos = random2(vec2(instance)) * 3.0;\n\n  float windStength = sin(worldPos.y * 0.5 + iTime * 2.0);\n  \n  vec3 curve = bezier3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.5, 0.0),\n    vec3(0.0, cos(bend), sin(bend)),\n    h\n  );\n\n  vec3 pos = curve;\n  pos.x += sideX * mix(0.05, 0.0, h * h);\n  pos = rotateY * pos;\n  pos += vec3(worldPos.x, 0.0, worldPos.y);\n\n  vH = h;\n  vX = sideX;\n  \n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n",
                            "defaultFragmentShader": "in float vH;\nin float vX;\n\nvoid main() {\n  vec3 color = mix(vec3(0.1, 0.2, 0.0), vec3(0.6, 0.8, 0.2), vH);\n  color *= 0.9 + vX * vX * 0.1;\n  \n  gl_FragColor = vec4(color, 1.0);\n}",
                            "defaultPostProcessShader": "",
                            "defaultProperties": "",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 208,
                        "slug": "grass-wind-with-noise",
                        "moduleId": 13,
                        "name": "Grass - Wind with Noise",
                        "order": 6,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": true,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 208,
                                "slug": "grass-wind-with-noise",
                                "moduleId": 13,
                                "name": "Grass - Wind with Noise",
                                "vertexShader": "uniform float iTime;\nuniform sampler2D iChannel0; \n\nattribute int index;\n\nout float vH;\nout vec3 vNormal;\nout float vX;\n\nvec3 bezier3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    float tt = t * t;\n    float uu = u * u;\n\n    vec3 p = uu * p0;\n    p += 2.0 * u * t * p1;\n    p += tt * p2;\n\n    return p;\n}\n\nvec2 random2(vec2 st){\n  float d1 = dot(st, vec2(12.3, 32.1));\n  float d2 = dot(st, vec2(45.6, 65.4));\n  \n  st = vec2(d1, d2);\n  return fract(sin(st) * 78.9) * 2.0 - 1.0;\n}\n\nfloat random(float x) {\n  float r = fract(sin(x * 12.34) * 1234.5678);\n  return r * 2.0 - 1.0;\n}\n\nmat3 rotationYMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      vec3(cosAngle, 0, -sinAngle),\n      vec3(0, 1, 0),\n      vec3(sinAngle, 0, cosAngle)\n    );\n}\n\nmat3 rotationXMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      1.0, 0, 0,\n      0, cosAngle, sinAngle,\n      0, -sinAngle, cosAngle\n    );\n}\n\nfloat noise(vec3 st) {\n  vec2 offset = vec2(st.z, 0.0);\n  return texture(iChannel0, fract(st.xy + offset)).r * 2.0 - 1.0;\n}\n\nvoid main() {\n  int   instance = index / 40;\n  float instanceHash = random(float(instance));\n  int   localIndex = index % 20;\n  float h = float(localIndex / 2) / 9.0;\n  float sideX = mod(float(localIndex), 2.0) * 2.0 - 1.0;\n  float bend = sin(iTime) * 0.2;\n  vec2  worldPos = random2(vec2(instance)) * 3.0;\n  mat3  rotateY = rotationYMatrix(instanceHash * 3.14);\n\n  float windStength = noise(vec3(worldPos * 0.05, 0.0) + iTime * 0.1) * h * 4.0;\n  mat3  windRot = rotationXMatrix(windStength);\n  \n  vec3 curve = bezier3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.5, 0.0),\n    vec3(0.0, cos(bend), sin(bend)),\n    h\n  );\n\n  vec3 pos = curve;\n  pos.x += sideX * mix(0.05, 0.0, h * h);\n  pos = windRot * rotateY * pos;\n  pos += vec3(worldPos.x, 0.0, worldPos.y);\n\n  vH = h;\n  vX = sideX;\n  \n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n",
                                "fragmentShader": "in float vH;\nin float vX;\n\nvoid main() {\n  vec3 color = mix(vec3(0.1, 0.2, 0.0), vec3(0.6, 0.8, 0.2), vH);\n  color *= 1.0 - abs(vX) * 0.1;\n  \n  gl_FragColor = vec4(color, 1.0);\n}",
                                "postProcessShader": "",
                                "properties": "",
                                "defaultVertexShader": "uniform float iTime;\nuniform sampler2D iChannel0; \n\nattribute int index;\n\nout float vH;\nout vec3 vNormal;\nout float vX;\n\nvec3 bezier3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    float tt = t * t;\n    float uu = u * u;\n\n    vec3 p = uu * p0;\n    p += 2.0 * u * t * p1;\n    p += tt * p2;\n\n    return p;\n}\n\nvec2 random2(vec2 st){\n  float d1 = dot(st, vec2(12.3, 32.1));\n  float d2 = dot(st, vec2(45.6, 65.4));\n  \n  st = vec2(d1, d2);\n  return fract(sin(st) * 78.9) * 2.0 - 1.0;\n}\n\nfloat random(float x) {\n  float r = fract(sin(x * 12.34) * 1234.5678);\n  return r * 2.0 - 1.0;\n}\n\nmat3 rotationYMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      vec3(cosAngle, 0, -sinAngle),\n      vec3(0, 1, 0),\n      vec3(sinAngle, 0, cosAngle)\n    );\n}\n\nmat3 rotationXMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      1.0, 0, 0,\n      0, cosAngle, sinAngle,\n      0, -sinAngle, cosAngle\n    );\n}\n\nfloat noise(vec3 st) {\n  vec2 offset = vec2(st.z, 0.0);\n  return texture(iChannel0, fract(st.xy + offset)).r * 2.0 - 1.0;\n}\n\nvoid main() {\n  int   instance = index / 40;\n  float instanceHash = random(float(instance));\n  int   localIndex = index % 20;\n  float h = float(localIndex / 2) / 9.0;\n  float sideX = mod(float(localIndex), 2.0) * 2.0 - 1.0;\n  float bend = sin(iTime) * 0.2;\n  vec2  worldPos = random2(vec2(instance)) * 3.0;\n  mat3  rotateY = rotationYMatrix(instanceHash * 3.14);\n\n  float windStength = noise(vec3(worldPos * 0.02, 0.0) + iTime * 0.1) * h;\n  mat3  windRot = rotationXMatrix(windStength);\n  \n  vec3 curve = bezier3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.5, 0.0),\n    vec3(0.0, cos(bend), sin(bend)),\n    h\n  );\n\n  vec3 pos = curve;\n  pos.x += sideX * mix(0.05, 0.0, h * h);\n  pos = windRot * rotateY * pos;\n  pos += vec3(worldPos.x, 0.0, worldPos.y);\n\n  vH = h;\n  vX = sideX;\n  \n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n",
                                "defaultFragmentShader": "in float vH;\nin float vX;\n\nvoid main() {\n  vec3 color = mix(vec3(0.1, 0.2, 0.0), vec3(0.6, 0.8, 0.2), vH);\n  color *= 1.0 - abs(vX) * 0.1;\n  \n  gl_FragColor = vec4(color, 1.0);\n}",
                                "defaultPostProcessShader": "",
                                "defaultProperties": "",
                                "vertexCodeEditable": true,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":3,\"y\":4,\"z\":4},\"rotation\":{\"x\":-0.75,\"y\":0.7,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":45,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":\"17\",\"model\":null,\"meshes\":[{\"name\":\"main\",\"materialId\":0}],\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"materials\":[],\"actions\":[],\"backgroundRGBA\":\"506060\",\"background\":5267552,\"customDepthBufferTexture\":false,\"glslVersion\":1}",
                                "description": "To create a more natural and random wind effect, we can use Perlin noise. For efficiency, we can store the noise in a texture and scroll it. This approach allows us to simulate wind movement across the grass blades dynamically and realistically. By adjusting the texture coordinates over time, we can create the illusion of wind blowing through the grass:\n\n```\nwindStrength = texture(noiseTexture, fract(xy + vec2(0.0, time))).r\n```\n\nYou can change the scale of the noise by multiplying the `xy` coordinates, which allows you to control the nature of the wind movement, making it smoother or more chaotic depending on your needs.\n\n### Task \n\nTo simulate a more chaotic wind effect on grass blades, you need to adjust the blade coordinates multiplier and increase the wind strength. Specifically, change the blade coordinates multiplier to `0.05` to enhance the randomness of the wind effect. Additionally, increase the wind strength by a factor of `4.0` to make the wind effect more pronounced.",
                                "hints": [],
                                "restrictions": [],
                                "order": 6,
                                "cost": 5,
                                "threshold": 99,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [
                                    {
                                        "index": 0
                                    }
                                ],
                                "animated": true,
                                "animationSteps": 10,
                                "animationStepTime": 200,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "uniform float iTime;\nuniform sampler2D iChannel0; \n\nattribute int index;\n\nout float vH;\nout vec3 vNormal;\nout float vX;\n\nvec3 bezier3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    float tt = t * t;\n    float uu = u * u;\n\n    vec3 p = uu * p0;\n    p += 2.0 * u * t * p1;\n    p += tt * p2;\n\n    return p;\n}\n\nvec2 random2(vec2 st){\n  float d1 = dot(st, vec2(12.3, 32.1));\n  float d2 = dot(st, vec2(45.6, 65.4));\n  \n  st = vec2(d1, d2);\n  return fract(sin(st) * 78.9) * 2.0 - 1.0;\n}\n\nfloat random(float x) {\n  float r = fract(sin(x * 12.34) * 1234.5678);\n  return r * 2.0 - 1.0;\n}\n\nmat3 rotationYMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      vec3(cosAngle, 0, -sinAngle),\n      vec3(0, 1, 0),\n      vec3(sinAngle, 0, cosAngle)\n    );\n}\n\nmat3 rotationXMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      1.0, 0, 0,\n      0, cosAngle, sinAngle,\n      0, -sinAngle, cosAngle\n    );\n}\n\nfloat noise(vec3 st) {\n  vec2 offset = vec2(st.z, 0.0);\n  return texture(iChannel0, fract(st.xy + offset)).r * 2.0 - 1.0;\n}\n\nvoid main() {\n  int   instance = index / 40;\n  float instanceHash = random(float(instance));\n  int   localIndex = index % 20;\n  float h = float(localIndex / 2) / 9.0;\n  float sideX = mod(float(localIndex), 2.0) * 2.0 - 1.0;\n  float bend = sin(iTime) * 0.2;\n  vec2  worldPos = random2(vec2(instance)) * 3.0;\n  mat3  rotateY = rotationYMatrix(instanceHash * 3.14);\n\n  float windStength = noise(vec3(worldPos * 0.02, 0.0) + iTime * 0.1) * h;\n  mat3  windRot = rotationXMatrix(windStength);\n  \n  vec3 curve = bezier3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.5, 0.0),\n    vec3(0.0, cos(bend), sin(bend)),\n    h\n  );\n\n  vec3 pos = curve;\n  pos.x += sideX * mix(0.05, 0.0, h * h);\n  pos = windRot * rotateY * pos;\n  pos += vec3(worldPos.x, 0.0, worldPos.y);\n\n  vH = h;\n  vX = sideX;\n  \n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n",
                            "fragmentShader": "in float vH;\nin float vX;\n\nvoid main() {\n  vec3 color = mix(vec3(0.1, 0.2, 0.0), vec3(0.6, 0.8, 0.2), vH);\n  color *= 1.0 - abs(vX) * 0.1;\n  \n  gl_FragColor = vec4(color, 1.0);\n}",
                            "postProcessShader": "",
                            "properties": "",
                            "defaultVertexShader": "uniform float iTime;\nuniform sampler2D iChannel0; \n\nattribute int index;\n\nout float vH;\nout vec3 vNormal;\nout float vX;\n\nvec3 bezier3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    float tt = t * t;\n    float uu = u * u;\n\n    vec3 p = uu * p0;\n    p += 2.0 * u * t * p1;\n    p += tt * p2;\n\n    return p;\n}\n\nvec2 random2(vec2 st){\n  float d1 = dot(st, vec2(12.3, 32.1));\n  float d2 = dot(st, vec2(45.6, 65.4));\n  \n  st = vec2(d1, d2);\n  return fract(sin(st) * 78.9) * 2.0 - 1.0;\n}\n\nfloat random(float x) {\n  float r = fract(sin(x * 12.34) * 1234.5678);\n  return r * 2.0 - 1.0;\n}\n\nmat3 rotationYMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      vec3(cosAngle, 0, -sinAngle),\n      vec3(0, 1, 0),\n      vec3(sinAngle, 0, cosAngle)\n    );\n}\n\nmat3 rotationXMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      1.0, 0, 0,\n      0, cosAngle, sinAngle,\n      0, -sinAngle, cosAngle\n    );\n}\n\nfloat noise(vec3 st) {\n  vec2 offset = vec2(st.z, 0.0);\n  return texture(iChannel0, fract(st.xy + offset)).r * 2.0 - 1.0;\n}\n\nvoid main() {\n  int   instance = index / 40;\n  float instanceHash = random(float(instance));\n  int   localIndex = index % 20;\n  float h = float(localIndex / 2) / 9.0;\n  float sideX = mod(float(localIndex), 2.0) * 2.0 - 1.0;\n  float bend = sin(iTime) * 0.2;\n  vec2  worldPos = random2(vec2(instance)) * 3.0;\n  mat3  rotateY = rotationYMatrix(instanceHash * 3.14);\n\n  float windStength = noise(vec3(worldPos * 0.02, 0.0) + iTime * 0.1) * h;\n  mat3  windRot = rotationXMatrix(windStength);\n  \n  vec3 curve = bezier3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.5, 0.0),\n    vec3(0.0, cos(bend), sin(bend)),\n    h\n  );\n\n  vec3 pos = curve;\n  pos.x += sideX * mix(0.05, 0.0, h * h);\n  pos = windRot * rotateY * pos;\n  pos += vec3(worldPos.x, 0.0, worldPos.y);\n\n  vH = h;\n  vX = sideX;\n  \n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n",
                            "defaultFragmentShader": "in float vH;\nin float vX;\n\nvoid main() {\n  vec3 color = mix(vec3(0.1, 0.2, 0.0), vec3(0.6, 0.8, 0.2), vH);\n  color *= 1.0 - abs(vX) * 0.1;\n  \n  gl_FragColor = vec4(color, 1.0);\n}",
                            "defaultPostProcessShader": "",
                            "defaultProperties": "",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 209,
                        "slug": "grass-blade-normal",
                        "moduleId": 13,
                        "name": "Grass - Blade Normal",
                        "order": 7,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": true,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 209,
                                "slug": "grass-blade-normal",
                                "moduleId": 13,
                                "name": "Grass - Blade Normal",
                                "vertexShader": "uniform float iTime;\n\nattribute int index;\n\nout vec3 vNormal;\n\nvec3 bezier3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    float tt = t * t;\n    float uu = u * u;\n\n    vec3 p = uu * p0;\n    p += 2.0 * u * t * p1;\n    p += tt * p2;\n\n    return p;\n}\n\nvec3 bezierGradient3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    vec3 gradient = 2.0 * u * (p1 - p0) + 2.0 * t * (p2 - p1);\n    return gradient;\n}\n\nvoid main() {\n  int   localIndex = index % 20;\n  float h = float(localIndex / 2) / 9.0;\n  float sideX = mod(float(localIndex), 2.0) * 2.0 - 1.0;\n  float sideZ = (index / 20 == 1) ? 1.0 : -1.0;\n  float bend = sin(iTime) * 1.5;\n  \n  vec3 curve = bezier3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.5, 0.0),\n    vec3(0.0, cos(bend), sin(bend)),\n    h\n  );\n\n  vec3 grad = bezierGradient3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.5, 0.0),\n    vec3(0.0, cos(bend), sin(bend)),\n    h\n  );\n\n  vec3 pos = curve;\n  pos.x += sideX * mix(0.1, 0.0, h * h);\n\n  vNormal = normalize(sideZ * vec3(0.0, grad.z, -grad.y));\n  \n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n",
                                "fragmentShader": "in vec3 vNormal;\n\nvoid main() {\n  gl_FragColor = vec4(normalize(vNormal), 1.0);\n}",
                                "postProcessShader": "",
                                "properties": "",
                                "defaultVertexShader": "uniform float iTime;\n\nattribute int index;\n\nvec3 bezier3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    float tt = t * t;\n    float uu = u * u;\n\n    vec3 p = uu * p0;\n    p += 2.0 * u * t * p1;\n    p += tt * p2;\n\n    return p;\n}\n\nvec3 bezierGradient3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    vec3 gradient = 2.0 * u * (p1 - p0) + 2.0 * t * (p2 - p1);\n    return gradient;\n}\n\nvoid main() {\n  int   localIndex = index % 20;\n  float h = float(localIndex / 2) / 9.0;\n  float sideX = mod(float(localIndex), 2.0) * 2.0 - 1.0;\n  float sideZ = (index / 20 == 1) ? 1.0 : -1.0;\n  float bend = sin(iTime) * 1.5;\n  \n  vec3 curve = bezier3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.5, 0.0),\n    vec3(0.0, cos(bend), sin(bend)),\n    h\n  );\n\n  vec3 pos = curve;\n  pos.x += sideX * mix(0.1, 0.0, h * h);\n  \n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n",
                                "defaultFragmentShader": "void main() {\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}",
                                "defaultPostProcessShader": "",
                                "defaultProperties": "",
                                "vertexCodeEditable": true,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":1.45,\"y\":0.55,\"z\":0.9},\"rotation\":{\"x\":0,\"y\":1,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":45,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":\"15\",\"model\":null,\"meshes\":[{\"name\":\"main\",\"materialId\":0}],\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"materials\":[],\"actions\":[],\"backgroundRGBA\":\"506060\",\"background\":5267552,\"customDepthBufferTexture\":false,\"glslVersion\":1}",
                                "description": "To determine the normal on the surface of a grass blade when using a double-sided mesh and a Bézier curve for bending it, you need to follow these steps:\n\n<br>\n\n1\\. Determine the first derivative of the Bézier curve at each point. This will give you the tangent to the curve at that point:\n\n```\nB′(t) = 3(1 − t)^2 * (P1 − P0) + 6(1 − t) * t * (P2 − P1) + 3t^2 * (P3 − P2)\n```\n\n2\\. Use the tangent to calculate the normal. Since we are bending the curve only in the YZ plane, we just need to rotate the tangent by 90 degrees:\n\n```\nN = (0.0, B′.z, -B′.y)\n```\n\n3\\. Determine the current side of the grass blade. If you have information about the number of vertices used for each side of the grass blade, you can determine the current side by checking the vertex index. For example, if each side of the grass blade consists of **N** vertices, then vertices with indices from **0** to **N-1** will belong to one side, and vertices with indices from **N** to **2N-1** will belong to the other side:\n\n```\nN *= side\n```\n\n\n### Task \n\nYour task is to determine the normal of a grass blade using the provided `bezierGradient3D` function and output the normal as a color. The grass blade is represented by a double-sided mesh and bent using a Bézier curve.",
                                "hints": [],
                                "restrictions": [],
                                "order": 7,
                                "cost": 5,
                                "threshold": 99,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": true,
                                "animationSteps": 10,
                                "animationStepTime": 200,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "uniform float iTime;\n\nattribute int index;\n\nvec3 bezier3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    float tt = t * t;\n    float uu = u * u;\n\n    vec3 p = uu * p0;\n    p += 2.0 * u * t * p1;\n    p += tt * p2;\n\n    return p;\n}\n\nvec3 bezierGradient3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    vec3 gradient = 2.0 * u * (p1 - p0) + 2.0 * t * (p2 - p1);\n    return gradient;\n}\n\nvoid main() {\n  int   localIndex = index % 20;\n  float h = float(localIndex / 2) / 9.0;\n  float sideX = mod(float(localIndex), 2.0) * 2.0 - 1.0;\n  float sideZ = (index / 20 == 1) ? 1.0 : -1.0;\n  float bend = sin(iTime) * 1.5;\n  \n  vec3 curve = bezier3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.5, 0.0),\n    vec3(0.0, cos(bend), sin(bend)),\n    h\n  );\n\n  vec3 pos = curve;\n  pos.x += sideX * mix(0.1, 0.0, h * h);\n  \n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n",
                            "fragmentShader": "void main() {\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}",
                            "postProcessShader": "",
                            "properties": "",
                            "defaultVertexShader": "uniform float iTime;\n\nattribute int index;\n\nvec3 bezier3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    float tt = t * t;\n    float uu = u * u;\n\n    vec3 p = uu * p0;\n    p += 2.0 * u * t * p1;\n    p += tt * p2;\n\n    return p;\n}\n\nvec3 bezierGradient3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    vec3 gradient = 2.0 * u * (p1 - p0) + 2.0 * t * (p2 - p1);\n    return gradient;\n}\n\nvoid main() {\n  int   localIndex = index % 20;\n  float h = float(localIndex / 2) / 9.0;\n  float sideX = mod(float(localIndex), 2.0) * 2.0 - 1.0;\n  float sideZ = (index / 20 == 1) ? 1.0 : -1.0;\n  float bend = sin(iTime) * 1.5;\n  \n  vec3 curve = bezier3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.5, 0.0),\n    vec3(0.0, cos(bend), sin(bend)),\n    h\n  );\n\n  vec3 pos = curve;\n  pos.x += sideX * mix(0.1, 0.0, h * h);\n  \n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n",
                            "defaultFragmentShader": "void main() {\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}",
                            "defaultPostProcessShader": "",
                            "defaultProperties": "",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    },
                    {
                        "id": 210,
                        "slug": "grass-light",
                        "moduleId": 13,
                        "name": "Grass - Light",
                        "order": 8,
                        "cost": 5,
                        "score": 0,
                        "accepted": false,
                        "rejected": false,
                        "match": 0,
                        "locked": true,
                        "premiumLock": false,
                        "premium": true,
                        "child": {
                            "task": {
                                "id": 210,
                                "slug": "grass-light",
                                "moduleId": 13,
                                "name": "Grass - Light",
                                "vertexShader": "uniform float iTime;\n\nattribute int index;\n\nout vec3 vNormal;\nout float vH;\nout float vX;\n\nvec3 bezier3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    float tt = t * t;\n    float uu = u * u;\n\n    vec3 p = uu * p0;\n    p += 2.0 * u * t * p1;\n    p += tt * p2;\n\n    return p;\n}\n\nvec3 bezierGradient3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    vec3 gradient = 2.0 * u * (p1 - p0) + 2.0 * t * (p2 - p1);\n    return gradient;\n}\n\nvec2 random2(vec2 st){\n  float d1 = dot(st, vec2(12.3, 32.1));\n  float d2 = dot(st, vec2(45.6, 65.4));\n  \n  st = vec2(d1, d2);\n  return fract(sin(st) * 78.9) * 2.0 - 1.0;\n}\n\nfloat random(float x) {\n  float r = fract(sin(x * 12.34) * 1234.5678);\n  return r * 2.0 - 1.0;\n}\n\nmat3 rotationYMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      vec3(cosAngle, 0, -sinAngle),\n      vec3(0, 1, 0),\n      vec3(sinAngle, 0, cosAngle)\n    );\n}\n\nmat3 rotationXMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      1.0, 0, 0,\n      0, cosAngle, sinAngle,\n      0, -sinAngle, cosAngle\n    );\n}\n\nvoid main() {\n  int   instance = index / 40;\n  float instanceHash = random(float(instance));\n  int   localIndex = index % 20;\n  float h = float(localIndex / 2) / 9.0;\n  float sideX = mod(float(localIndex), 2.0) * 2.0 - 1.0;\n  float sideZ = ((index % 40) / 20 == 1) ? 1.0 : -1.0;\n  float bend = sin(iTime) * 0.2;\n  vec2  worldPos = random2(vec2(instance)) * 3.0;\n  mat3  rotateY = rotationYMatrix(instanceHash * 3.14);\n\n  float windStength = sin(worldPos.y * 0.5 + iTime * 2.0) * h;\n  mat3  windRot = rotationXMatrix(windStength);\n  \n  vec3 curve = bezier3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.5, 0.0),\n    vec3(0.0, cos(bend), sin(bend)),\n    h\n  );\n\n  vec3 grad = bezierGradient3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.5, 0.0),\n    vec3(0.0, cos(bend), sin(bend)),\n    h\n  );\n\n  vec3 pos = curve;\n  pos.x += sideX * mix(0.05, 0.0, h * h);\n  pos = windRot * rotateY * pos;\n  pos += vec3(worldPos.x, 0.0, worldPos.y);\n\n  vNormal = normalize(windRot * rotateY * sideZ * vec3(0.0, grad.z, -grad.y));\n  vH = h;\n  vX = sideX;\n  \n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n",
                                "fragmentShader": "in vec3 vNormal;\nin float vH;\nin float vX;\n\nvoid main() {\n  vec3 fragColor = mix(vec3(0.1, 0.2, 0.0), vec3(0.6, 0.8, 0.4), vH);\n  vec3 fragNormal = normalize(vNormal);\n  vec3 lightDir   = normalize(vec3(0.0, -1.0, 1.0));\n\n  float diffuse = max(0.0, dot(fragNormal, lightDir));\n\n  vec3 result = (diffuse + 0.5) * fragColor.rgb;\n  \n  gl_FragColor = vec4(result, 1.0);\n}",
                                "postProcessShader": "",
                                "properties": "",
                                "defaultVertexShader": "uniform float iTime;\n\nattribute int index;\n\nout vec3 vPos;\nout vec3 vNormal;\nout float vH;\nout float vX;\n\nvec3 bezier3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    float tt = t * t;\n    float uu = u * u;\n\n    vec3 p = uu * p0;\n    p += 2.0 * u * t * p1;\n    p += tt * p2;\n\n    return p;\n}\n\nvec3 bezierGradient3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    vec3 gradient = 2.0 * u * (p1 - p0) + 2.0 * t * (p2 - p1);\n    return gradient;\n}\n\nvec2 random2(vec2 st){\n  float d1 = dot(st, vec2(12.3, 32.1));\n  float d2 = dot(st, vec2(45.6, 65.4));\n  \n  st = vec2(d1, d2);\n  return fract(sin(st) * 78.9) * 2.0 - 1.0;\n}\n\nfloat random(float x) {\n  float r = fract(sin(x * 12.34) * 1234.5678);\n  return r * 2.0 - 1.0;\n}\n\nmat3 rotationYMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      vec3(cosAngle, 0, -sinAngle),\n      vec3(0, 1, 0),\n      vec3(sinAngle, 0, cosAngle)\n    );\n}\n\nmat3 rotationXMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      1.0, 0, 0,\n      0, cosAngle, sinAngle,\n      0, -sinAngle, cosAngle\n    );\n}\n\nvoid main() {\n  int   instance = index / 40;\n  float instanceHash = random(float(instance));\n  int   localIndex = index % 20;\n  float h = float(localIndex / 2) / 9.0;\n  float sideX = mod(float(localIndex), 2.0) * 2.0 - 1.0;\n  float sideZ = ((index % 40) / 20 == 1) ? 1.0 : -1.0;\n  float bend = sin(iTime) * 0.2;\n  vec2  worldPos = random2(vec2(instance)) * 3.0;\n  mat3  rotateY = rotationYMatrix(instanceHash * 3.14);\n\n  float windStength = sin(worldPos.y * 0.5 + iTime * 2.0) * h;\n  mat3  windRot = rotationXMatrix(windStength);\n  \n  vec3 curve = bezier3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.5, 0.0),\n    vec3(0.0, cos(bend), sin(bend)),\n    h\n  );\n\n  vec3 grad = bezierGradient3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.5, 0.0),\n    vec3(0.0, cos(bend), sin(bend)),\n    h\n  );\n\n  vec3 pos = curve;\n  pos.x += sideX * mix(0.05, 0.0, h * h);\n  pos = windRot * rotateY * pos;\n  pos += vec3(worldPos.x, 0.0, worldPos.y);\n\n  vNormal = normalize(windRot * rotateY * sideZ * vec3(0.0, grad.z, -grad.y));\n  vH = h;\n  vX = sideX;\n  \n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n",
                                "defaultFragmentShader": "in vec3 vNormal;\nin float vH;\nin float vX;\n\nvoid main() {\n  vec3 fragColor = mix(vec3(0.1, 0.2, 0.0), vec3(0.6, 0.8, 0.4), vH);\n  vec3 lightDir  = normalize(vec3(0.0, -1.0, 1.0));\n\n  vec3 result = fragColor.rgb;\n  \n  gl_FragColor = vec4(result, 1.0);\n}",
                                "defaultPostProcessShader": "",
                                "defaultProperties": "",
                                "vertexCodeEditable": true,
                                "fragmentCodeEditable": true,
                                "postProcessCodeEditable": false,
                                "propertiesEditable": false,
                                "sceneSettings": "{\"camera\":{\"position\":{\"x\":3,\"y\":4,\"z\":4},\"rotation\":{\"x\":-0.75,\"y\":0.7,\"z\":0},\"isOrthographic\":false,\"near\":0.1,\"far\":100,\"fov\":45,\"left\":0,\"right\":1,\"top\":1,\"bottom\":0},\"objects\":[{\"position\":{\"x\":0,\"y\":0,\"z\":0},\"rotation\":{\"x\":0,\"y\":0,\"z\":0},\"scale\":{\"x\":1,\"y\":1,\"z\":1},\"geometry\":\"17\",\"model\":null,\"meshes\":[{\"name\":\"main\",\"materialId\":0}],\"colorRGBA\":\"FFFFFF\",\"color\":null}],\"materials\":[],\"actions\":[],\"backgroundRGBA\":\"506060\",\"background\":5267552,\"customDepthBufferTexture\":false,\"glslVersion\":1}",
                                "description": "To add ambient lighting to the scene, we calculate the product of the light, the object color and the ambient light factor.\n\n```\ncolor = ambient * object * light\n```\n\nTo get diffuse light component we need calculate the angular distance between the light direction **L** and the plane normal **N**:\n\n```\ndiffuse = dot(N, L)\n```\n\nCombine ambient and diffuse lighting:\n\n```\ncolor = (ambient+ diffuse ) * object * light\n```\n\n### Task \n\nYour task is to add simple Phong diffuse lighting to the grass blades with an ambient light component of `0.5`.",
                                "hints": [],
                                "restrictions": [],
                                "order": 8,
                                "cost": 5,
                                "threshold": 99,
                                "likes": 0,
                                "dislikes": 0,
                                "visibility": true,
                                "createdBy": {
                                    "id": 3,
                                    "name": "Alexander"
                                },
                                "channels": [],
                                "animated": true,
                                "animationSteps": 10,
                                "animationStepTime": 200,
                                "rules": [
                                    {
                                        "id": 1,
                                        "default": true,
                                        "keyword": "if",
                                        "message": "Branching can slow down the speed of your program",
                                        "severity": 1
                                    }
                                ],
                                "premium": true
                            },
                            "vertexShader": "uniform float iTime;\n\nattribute int index;\n\nout vec3 vPos;\nout vec3 vNormal;\nout float vH;\nout float vX;\n\nvec3 bezier3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    float tt = t * t;\n    float uu = u * u;\n\n    vec3 p = uu * p0;\n    p += 2.0 * u * t * p1;\n    p += tt * p2;\n\n    return p;\n}\n\nvec3 bezierGradient3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    vec3 gradient = 2.0 * u * (p1 - p0) + 2.0 * t * (p2 - p1);\n    return gradient;\n}\n\nvec2 random2(vec2 st){\n  float d1 = dot(st, vec2(12.3, 32.1));\n  float d2 = dot(st, vec2(45.6, 65.4));\n  \n  st = vec2(d1, d2);\n  return fract(sin(st) * 78.9) * 2.0 - 1.0;\n}\n\nfloat random(float x) {\n  float r = fract(sin(x * 12.34) * 1234.5678);\n  return r * 2.0 - 1.0;\n}\n\nmat3 rotationYMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      vec3(cosAngle, 0, -sinAngle),\n      vec3(0, 1, 0),\n      vec3(sinAngle, 0, cosAngle)\n    );\n}\n\nmat3 rotationXMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      1.0, 0, 0,\n      0, cosAngle, sinAngle,\n      0, -sinAngle, cosAngle\n    );\n}\n\nvoid main() {\n  int   instance = index / 40;\n  float instanceHash = random(float(instance));\n  int   localIndex = index % 20;\n  float h = float(localIndex / 2) / 9.0;\n  float sideX = mod(float(localIndex), 2.0) * 2.0 - 1.0;\n  float sideZ = ((index % 40) / 20 == 1) ? 1.0 : -1.0;\n  float bend = sin(iTime) * 0.2;\n  vec2  worldPos = random2(vec2(instance)) * 3.0;\n  mat3  rotateY = rotationYMatrix(instanceHash * 3.14);\n\n  float windStength = sin(worldPos.y * 0.5 + iTime * 2.0) * h;\n  mat3  windRot = rotationXMatrix(windStength);\n  \n  vec3 curve = bezier3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.5, 0.0),\n    vec3(0.0, cos(bend), sin(bend)),\n    h\n  );\n\n  vec3 grad = bezierGradient3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.5, 0.0),\n    vec3(0.0, cos(bend), sin(bend)),\n    h\n  );\n\n  vec3 pos = curve;\n  pos.x += sideX * mix(0.05, 0.0, h * h);\n  pos = windRot * rotateY * pos;\n  pos += vec3(worldPos.x, 0.0, worldPos.y);\n\n  vNormal = normalize(windRot * rotateY * sideZ * vec3(0.0, grad.z, -grad.y));\n  vH = h;\n  vX = sideX;\n  \n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n",
                            "fragmentShader": "in vec3 vNormal;\nin float vH;\nin float vX;\n\nvoid main() {\n  vec3 fragColor = mix(vec3(0.1, 0.2, 0.0), vec3(0.6, 0.8, 0.4), vH);\n  vec3 lightDir  = normalize(vec3(0.0, -1.0, 1.0));\n\n  vec3 result = fragColor.rgb;\n  \n  gl_FragColor = vec4(result, 1.0);\n}",
                            "postProcessShader": "",
                            "properties": "",
                            "defaultVertexShader": "uniform float iTime;\n\nattribute int index;\n\nout vec3 vPos;\nout vec3 vNormal;\nout float vH;\nout float vX;\n\nvec3 bezier3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    float tt = t * t;\n    float uu = u * u;\n\n    vec3 p = uu * p0;\n    p += 2.0 * u * t * p1;\n    p += tt * p2;\n\n    return p;\n}\n\nvec3 bezierGradient3D(vec3 p0, vec3 p1, vec3 p2, float t) {\n    float u = 1.0 - t;\n    vec3 gradient = 2.0 * u * (p1 - p0) + 2.0 * t * (p2 - p1);\n    return gradient;\n}\n\nvec2 random2(vec2 st){\n  float d1 = dot(st, vec2(12.3, 32.1));\n  float d2 = dot(st, vec2(45.6, 65.4));\n  \n  st = vec2(d1, d2);\n  return fract(sin(st) * 78.9) * 2.0 - 1.0;\n}\n\nfloat random(float x) {\n  float r = fract(sin(x * 12.34) * 1234.5678);\n  return r * 2.0 - 1.0;\n}\n\nmat3 rotationYMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      vec3(cosAngle, 0, -sinAngle),\n      vec3(0, 1, 0),\n      vec3(sinAngle, 0, cosAngle)\n    );\n}\n\nmat3 rotationXMatrix(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n      1.0, 0, 0,\n      0, cosAngle, sinAngle,\n      0, -sinAngle, cosAngle\n    );\n}\n\nvoid main() {\n  int   instance = index / 40;\n  float instanceHash = random(float(instance));\n  int   localIndex = index % 20;\n  float h = float(localIndex / 2) / 9.0;\n  float sideX = mod(float(localIndex), 2.0) * 2.0 - 1.0;\n  float sideZ = ((index % 40) / 20 == 1) ? 1.0 : -1.0;\n  float bend = sin(iTime) * 0.2;\n  vec2  worldPos = random2(vec2(instance)) * 3.0;\n  mat3  rotateY = rotationYMatrix(instanceHash * 3.14);\n\n  float windStength = sin(worldPos.y * 0.5 + iTime * 2.0) * h;\n  mat3  windRot = rotationXMatrix(windStength);\n  \n  vec3 curve = bezier3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.5, 0.0),\n    vec3(0.0, cos(bend), sin(bend)),\n    h\n  );\n\n  vec3 grad = bezierGradient3D(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.5, 0.0),\n    vec3(0.0, cos(bend), sin(bend)),\n    h\n  );\n\n  vec3 pos = curve;\n  pos.x += sideX * mix(0.05, 0.0, h * h);\n  pos = windRot * rotateY * pos;\n  pos += vec3(worldPos.x, 0.0, worldPos.y);\n\n  vNormal = normalize(windRot * rotateY * sideZ * vec3(0.0, grad.z, -grad.y));\n  vH = h;\n  vX = sideX;\n  \n  gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);\n}\n",
                            "defaultFragmentShader": "in vec3 vNormal;\nin float vH;\nin float vX;\n\nvoid main() {\n  vec3 fragColor = mix(vec3(0.1, 0.2, 0.0), vec3(0.6, 0.8, 0.4), vH);\n  vec3 lightDir  = normalize(vec3(0.0, -1.0, 1.0));\n\n  vec3 result = fragColor.rgb;\n  \n  gl_FragColor = vec4(result, 1.0);\n}",
                            "defaultPostProcessShader": "",
                            "defaultProperties": "",
                            "liked": false,
                            "disliked": false,
                            "accepted": false,
                            "answerViewed": false,
                            "submissions": []
                        }
                    }
                ],
                "cover": true,
                "pageHeaderImage": true,
                "fullDesc": "This module is designed for developers who want to master high-quality techniques for rendering grass fields",
                "skillsDesc": "render large numbers of grass blades efficiently<br>use of Bezier curves to animate grass bending<br>how to simulate wind effects",
                "importanceDesc": "Realistic grass rendering enhances the visual appeal of virtual environments, making them more immersive and engaging.",
                "certifiable": false,
                "images": [
                    "img-1.png",
                    "img-2.png",
                    "img-3.png"
                ]
            }
        }
    ]
}